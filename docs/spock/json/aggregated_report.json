{"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":69},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the observable `Noticeable` interface\n    and the fireable `Event` interface which is a sub type of `Noticeable`.\n    The `Event` interface is used to fire events, and the `Noticeable` interface\n    is used to listen for events by registering `Listener` instances.\n    \n    The `Event` interface is a sub type of `Noticeable` and as such\n    can be used to listen for events as well as fire them.\n    \n    `Event`s can be created using various factory methods on the `Events` class,\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Noticeable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Listener` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Noticeable`.","The `fireSet` method will also lead to registered `Listener` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Events","narrative":"The `Noticeable` interface is a thing that can be listened to\n    Not only is it the super type of `Event`, it is also the super type of \n    sprouts `Val` and `Var` property wrappers as well as the `Vals` and `Vars`\n    property list types.\n    \n    This means that you can listen to all of these types for changes\n    through the `Noticeable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":130},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":28},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":9},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":8,"passed":1,"successRate":1.0,"time":41},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":66},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the observable `Noticeable` interface\n    and the fireable `Event` interface which is a sub type of `Noticeable`.\n    The `Event` interface is used to fire events, and the `Noticeable` interface\n    is used to listen for events by registering `Listener` instances.\n    \n    The `Event` interface is a sub type of `Noticeable` and as such\n    can be used to listen for events as well as fire them.\n    \n    `Event`s can be created using various factory methods on the `Events` class,\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Noticeable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Listener` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Noticeable`.","The `fireSet` method will also lead to registered `Listener` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Events","narrative":"The `Noticeable` interface is a thing that can be listened to\n    Not only is it the super type of `Event`, it is also the super type of \n    sprouts `Val` and `Var` property wrappers as well as the `Vals` and `Vars`\n    property list types.\n    \n    This means that you can listen to all of these types for changes\n    through the `Noticeable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":132},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":28},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":10},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":15},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":65},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the observable `Noticeable` interface\n    and the fireable `Event` interface which is a sub type of `Noticeable`.\n    The `Event` interface is used to fire events, and the `Noticeable` interface\n    is used to listen for events by registering `Listener` instances.\n    \n    The `Event` interface is a sub type of `Noticeable` and as such\n    can be used to listen for events as well as fire them.\n    \n    `Event`s can be created using various factory methods on the `Events` class,\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Noticeable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Listener` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Noticeable`.","The `fireSet` method will also lead to registered `Listener` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Events","narrative":"The `Noticeable` interface is a thing that can be listened to\n    Not only is it the super type of `Event`, it is also the super type of \n    sprouts `Val` and `Var` property wrappers as well as the `Vals` and `Vars`\n    property list types.\n    \n    This means that you can listen to all of these types for changes\n    through the `Noticeable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":114},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":9},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":14},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":66},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Occurrence`,\n    defining something that can be triggered so that the `Observer` may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Occurrence_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":15},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Occurrence` interface where `Occurrence` is a sub type of `Observable`.\n    The `Occurrence` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Occurrence`s can be created using various factory methods (like for example `Occurrence.create()`),\n    one of which even allows the specification of a custom `Occurrence.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":29},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":134},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":36},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":16},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":47},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":41},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Occurrence`,\n    defining something that can be triggered so that the `Observer` may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Occurrence_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Occurrence` interface where `Occurrence` is a sub type of `Observable`.\n    The `Occurrence` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Occurrence`s can be created using various factory methods (like for example `Occurrence.create()`),\n    one of which even allows the specification of a custom `Occurrence.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":133},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":31},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":19},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":144},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":30},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":54},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":187},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":37},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":133},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":35},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":15},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":63},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":128},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":30},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":16},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":54},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":110},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":22},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":10},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":12},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":55},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":111},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":24},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":9},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":14},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":56},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":180},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":25},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":9},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":12},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":69},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":1,"successRate":0.5,"time":33},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":3,"successRate":0.75,"time":28},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":229},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":4,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":14,"successRate":0.7777777777777778,"time":39},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":12},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":49},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":56},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":2,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":16,"successRate":0.8888888888888888,"time":62},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":16},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":147},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":1,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":16,"successRate":0.8888888888888888,"time":161},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":40},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":143},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":157},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":36},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":72},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":158},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":28},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":113},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":38},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":9},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":198},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":59},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":141},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":37},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":19},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":54},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":24},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":147},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":30},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":59},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":130},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":34},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":61},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":28},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":127},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the \"act\" method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":29},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":62},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":134},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":31},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":63},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":22},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":125},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":44},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":14},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":135},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":30},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":11},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":77},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":138},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":15},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":143},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":28},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":28},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":76},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":115},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":143},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":28},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":29},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":12},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":67},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":8},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":117},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":15},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":139},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":27},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":13},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":7},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":133},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":14},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":17,"successRate":0.9444444444444444,"time":143},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":37},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":10},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":81},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":132},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":4,"successRate":0.8,"time":13},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":11},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":16},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an Optional.","A property constructed using the \"of\" factory method, does not allow null items.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the \"Optional\" class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Properties not only have a value but also a type and id!","The \"get\" method will throw an exception if there is no element present.","The \"ifPresent\" method allows us to see if a property has a value or not.","The \"withID(..)\" method produces a new property with all bindings inherited.","The UI uses the \"act(T)\" method to change the property state to avoid feedback looping.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":18,"totalFeatures":18,"passed":18,"successRate":1.0,"time":108},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    Therefore properties are a root concept in the Sprouts library.\n    The decoupling between your UI and the UIs state and logic \n    is achieved by binding properties to UI components.\n    This specification shows you how to model UI state \n    and business logic using properties \n    and how to bind them to UI components."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":22},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":27},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Spec":{"executedFeatures":["Changing a property through the `act` method will not trigger `Observer` instances to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","The `fireSet` method will also lead to registered `Observer` instances to be notified.","You can treat a property as a noticeable, and register `Listeners`s on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":6},"title":"Observable Events","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":74},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":102},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":14},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the \"onSetItem(..)\" method.","Subscribing to the `From.ANY` channel will notify you of all changes.","The \"withID(..)\" method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":56},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ANY` channel will notify you of all changes.","The \"withID(..)\" method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":68},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ANY` channel will notify you of all changes.","The \"withID(..)\" method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":62},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ANY` channel will notify you of all changes.","The \"withID(..)\" method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":69},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ANY` channel will notify you of all changes.","The \"withID(..)\" method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":0,"successRate":0.0,"time":76},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ANY` channel will notify you of all changes.","The \"withID(..)\" method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":5,"passed":1,"successRate":1.0,"time":47},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":71},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":136},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":25},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":19},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":65},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":135},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":23},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":78},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":33},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":20},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":186},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":46},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":18},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":21},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":56},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":32},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":135},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":17},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":24},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":192},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":21},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":21},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":57},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":114},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":18},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":10},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":12},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":71},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":33},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":126},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":27},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":20},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":66},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":105},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":20},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":6},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":9},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":14},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":64},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":147},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":54},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":136},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":19},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":52},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":25},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":134},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":27},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":16},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be called if they report \"canBeRemoved()\"","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":116},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":19},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":9},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":12},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":1,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":32,"passed":0,"successRate":0.0,"time":90},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":32,"passed":1,"successRate":1.0,"time":53},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":54},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":55},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the \"sort\" method.","Lists of properties can be sorted using a custom comparator through the \"sort\" method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":151},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":25},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":18},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":27},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":131},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":24},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":21},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":28},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":120},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":22},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":61},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":39},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":116},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":25},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":58},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":37},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":126},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":14,"passed":14,"successRate":1.0,"time":22},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":1,"totalFeatures":15,"passed":1,"successRate":1.0,"time":36},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":90},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":31},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":117},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":23},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":15},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":15},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":63},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":48},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":121},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":38},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":18},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":111},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":18},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":66},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":17},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":126},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":16},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":51},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":29},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":19},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":122},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":26},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":13},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":16},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":60},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":30},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fire(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":20},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":32,"passed":32,"successRate":1.0,"time":133},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":15,"totalFeatures":15,"passed":15,"successRate":1.0,"time":36},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":108},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.of(..)` does not update when receiving null items","A composite property view created using the `Val.ofNullable(..)` allows null.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.of(..)` method cannot deal with null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":39},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":33},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":33,"totalFeatures":33,"passed":33,"successRate":1.0,"time":158},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":32},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":21},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":25},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":24},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":86},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.of(..)` does not update when receiving null items","A composite property view created using the `Val.ofNullable(..)` allows null.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.of(..)` method cannot deal with null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":35},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":16},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":33,"totalFeatures":33,"passed":33,"successRate":1.0,"time":150},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":32},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":14},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":21},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":24},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":85},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.of(..)` does not update when receiving null items","A composite property view created using the `Val.ofNullable(..)` allows null.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.of(..)` method cannot deal with null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":34},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":37},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":33,"totalFeatures":33,"passed":33,"successRate":1.0,"time":146},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":30},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":22},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":82},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.of(..)` does not update when receiving null items","A composite property view created using the `Val.ofNullable(..)` allows null.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.of(..)` method cannot deal with null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":38},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":32},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":20},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":33,"totalFeatures":33,"passed":33,"successRate":1.0,"time":137},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":29},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Just like a `Val` property, a Result has a type and id.","Results can be mapped to a property.","Results can be turned into an Optional.","We can create a result from any kind of value.","You can create a Result from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":23},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":25},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":80},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.of(..)` does not update when receiving null items","A composite property view created using the `Val.ofNullable(..)` allows null.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.of(..)` method cannot deal with null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":43},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":30},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":14},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":33,"totalFeatures":33,"passed":33,"successRate":1.0,"time":116},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":27},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":10,"totalFeatures":10,"passed":10,"successRate":1.0,"time":20},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":19},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":82},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":40},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":31},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":19},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":5},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":49,"totalFeatures":49,"passed":49,"successRate":1.0,"time":124},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":21},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":5},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":11},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":21},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":25},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":130},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":55},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":41},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":43},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":73,"totalFeatures":49,"passed":73,"successRate":1.0,"time":328},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":49},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":15},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":22},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":36},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":55},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":121},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":45},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":34},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":73,"totalFeatures":49,"passed":73,"successRate":1.0,"time":229},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":32},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":7},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":16},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":24},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":34},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":133},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":65},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":33},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":9},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":11},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":73,"totalFeatures":49,"passed":73,"successRate":1.0,"time":244},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":40},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":28},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":149},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":50},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":35},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":43},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":8},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":10},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can remove n leading or trailing entries from a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":73,"totalFeatures":49,"passed":73,"successRate":1.0,"time":310},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":32},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":24},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":143},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":61},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":37},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":24},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":15},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":83,"totalFeatures":59,"passed":83,"successRate":1.0,"time":382},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":41},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses":{"executedFeatures":["A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","Many lens properties can be created from a regular property.","You can create lenses from other lenses to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":65},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```"},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":24},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":29},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":39},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":150},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":64},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":40},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":83,"totalFeatures":59,"passed":83,"successRate":1.0,"time":382},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":46},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses":{"executedFeatures":["A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","Many lens properties can be created from a regular property.","You can create lenses from other lenses to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":5,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":1,"successRate":0.16666666666666666,"time":59},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```"},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":22},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":34},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":42},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Property_Lenses":{"executedFeatures":["A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","Many lens properties can be created from a regular property.","You can create lenses from other lenses to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":261},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":39},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":50},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":36},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":12},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":83,"totalFeatures":59,"passed":83,"successRate":1.0,"time":346},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":40},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":23},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":28},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":39},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":174},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":64},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":34},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":14},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":14},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":83,"totalFeatures":59,"passed":83,"successRate":1.0,"time":350},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":37},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses":{"executedFeatures":["A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","Many lens properties can be created from a regular property.","You can create lenses from other lenses to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":65},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```"},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":22},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":35},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":40},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":159},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":74},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":38},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":23},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":12},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":83,"totalFeatures":59,"passed":83,"successRate":1.0,"time":339},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":48},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":12},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":10},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses":{"executedFeatures":["A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","Many lens properties can be created from a regular property.","You can create lenses from other lenses to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":60},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```"},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":20},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":29},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":43},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"},"sprouts.Common_Property_Views":{"executedFeatures":["A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The `viewSize()` method returns a property that is equal to the size of the original property.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":140},"title":"Common Property Views","narrative":"A property or property list is more than just a wrapper around values.\n    These interfaces have rich APIs that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n    \n    The relevant methods here are `Val::isEmpty`, `Val::isPresent` and `Vals::size`.\n    But these are not going to be conversed in this specification.\n    Instead we will focus on their \"views\", which can be created\n    through the `Val::viewIsEmpty`, `Val::viewIsPresent` and `Vals::viewSize` methods.\n    \n    Each of these methods return a property which will always be \"up to date\"\n    with respect to the thing that is observed, and will be updated\n    automatically when the observed thing changes."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Val.viewOf(..)` does not update when receiving `null` items","A composite property view created using the `Val.viewOfNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Val.viewOf(..)` method cannot deal with `null`.","The second property of a composite view created using the `Val.viewOf(..)` and `Val.viewOfNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":8,"totalFeatures":8,"passed":8,"successRate":1.0,"time":62},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":35},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.MVVM_Unit_Test_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":26},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":13},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Properties_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":83,"totalFeatures":59,"passed":83,"successRate":1.0,"time":397},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Properties_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","Conveniently compare properties with another item using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around a value","Properties not only have a value but also a type and id!","The \"ifPresent\" method allows us to see if a property has a value or not.","The `get()` method will throw an exception if there is no element present.","The equality and hash code of a property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","There are various kinds of convenience methods for creating live view of properties.","Use `typeAsString()` to get the type of a property as a string.","Use the \"viewAs\" method to create a dynamically updated view of a property.","Whether a property is a `Var` or `Val` can be seen in their String representaions."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":16,"totalFeatures":16,"passed":16,"successRate":1.0,"time":45},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_Binding_Spec":{"executedFeatures":["Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property user action exposes a property that is an immutable clone."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses":{"executedFeatures":["A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","Many lens properties can be created from a regular property.","You can create lenses from other lenses to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":6,"totalFeatures":6,"passed":6,"successRate":1.0,"time":61},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```"},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property will throw an exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":12,"totalFeatures":7,"passed":12,"successRate":1.0,"time":21},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Result_Spec":{"executedFeatures":["A result can be created from multiple problems.","An empty `Result` can be mapped to any property type without an exception being thrown.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like a `Val` property, a `Result` has a type and id.","Results can be turned into an Optional.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":11,"totalFeatures":11,"passed":11,"successRate":1.0,"time":28},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    It is a sub type of the `Val` property and as such can be used to represent a value\n    that is immutable and can be observed for changes.\n    \n    The default result implementation indirectly exposed by its factory methods\n    is immutable and thread safe, effectively making it a monadic value\n    similar to the `Optional` type in Java 8."},"sprouts.Viewing_Properties_Spec":{"executedFeatures":["A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Map null to custom values when viewing them as primitive types.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","Use the \"view\" to create a view of a property of the same type."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":41},"title":"Viewing Properties","narrative":"Both the read only `Val` and the mutable `Var` are observable properties.\n    As a consequence, they expose convenient methods to observe their changes\n    in the form of \"views\", which are themselves observable properties\n    that are a live view of the original property which gets updated\n    automatically when the original property changes.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,"}}