{"sprouts.Association_Spec":{"executedFeatures":["A larger `Association` will have a trimmed string representation.","An `Association` has an intuitive string representation.","An association is invariant to a map.","An empty association is created by supplying the type of the key and value","Association maintains full invariance with Map across all operations.","Associations with same entries in different order are equal","The `Association` class is an `Iterable` which allows you to iterate over its entries.","The `clear` method creates an empty association with the same key and value types.","The `entrySet` is immutable and contains correct pairs","The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.","The `putIfAbsent` does not overwrite an existing value already stored in an association.","The `replace` method replaces the value of a key with a new value, if and only if the key is present.","The `retainAll` method keeps only specified keys","The classTyped method returns the correct class and handles null parameters","The of factory method throws NPE for null parameters","Two associations the the same operations applied to them are always equal.","Use `Association.between(Number.class, Number.class)` to create an association between all kinds of numbers.","Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.","Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Pair...)` to populate an association at once from multiple pairs.","Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.","You can iterate over the `entrySet` of all pairs in an `Association`.","You can merge a large association and a map into a single association using the `putAll` method.","You can merge two associations into one using the `putAll` method.","You can merge two large associations into one using the `putAll` method.","You can remove the entries of a large association from another, using the `removeAll` method.","You remove the entries of one association from another, using the `removeAll(Set)` method.","You remove the entries of one association from another, using the `removeAll(ValueSet)` method.","clear on empty association returns an empty instance","replaceAll ignores non-existing keys in replacement stream","replaceAll with Map only updates existing keys","values() contains all values including duplicates"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":58,"totalFeatures":33,"passed":58,"successRate":1.0,"time":3230},"title":"Associations","narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming. \n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Viewable.of(..)` does not update when receiving `null` items","A composite property view created using the `Viewable.ofNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Viewable.of(..)` method cannot deal with `null`.","The change listeners of the parents of composite properties are garbage collected when the composite is no longer referenced strongly.","The second property of a composite view created using the `Viewable.of(..)` and `Viewable.ofNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":641},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A `WeakObserver` is removed and garbage collected together with its owner.","A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","The `Observable` of an `Event` can be garbage collected alongside its `Observer`s.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":161},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Immutable_Property_Spec":{"executedFeatures":["The `Val.equals(..)` method compares two objects by value.","The `Val.hashCode(..)` method returns the hash code of the value.","The `or(Supplier)` method allows you to provide a fallback property if the property is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided properties.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":9,"passed":32,"successRate":1.0,"time":71},"title":"Immutable Properties","narrative":"Immutable properties are properties created by one\n    of the many factory methods on the `Val` interface.\n    The returned `Val` properties are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the property itself."},"sprouts.Lens_Spec":{"executedFeatures":["Lens.across allows bulk transformation of tuples of homogeneous data","Lens.across handles edge cases with empty and single-element tuples","Lens.across maintains element order during bulk operations","You can compose lenses to update a deeply nested part of a data structure.","You can create lenses from other lenses to dive deeper into nested data structures."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":62},"title":"Functional Lenses","narrative":"The `Lens` interface defines an access and update operation on an individual \n    part of a nested and immutable data structure. \n    A lens can also be composed with other lenses to focus \n    on more deeply nested parts.\n    This design concept is part of the functional \n    programming paradigm, and it emulates\n    mutable properties (getter and setter) in an immutable world \n    using a *getter* and more importantly a *wither* methods \n    (a function that returns a new structure with target field being updated).\n\n    In this specification we demonstrate how to implement and use\n    your own lenses through the `Lens` interface and then\n    we show how these lenses can be composed to focus on deeply nested parts.\n    \n    We use the following data structures to demonstrate the concept:\n    ```\n    enum Genre { FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY }\n\n    enum MembershipLevel { BASIC, SILVER, GOLD, PLATINUM }\n\n    static record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n        public Author withFirstName(String firstName) {\n            return new Author(firstName, this.lastName, this.birthDate, this.books);\n        }\n\n        public Author withLastName(String lastName) {\n            return new Author(this.firstName, lastName, this.birthDate, this.books);\n        }\n\n        public Author withBirthDate(LocalDate birthDate) {\n            return new Author(this.firstName, this.lastName, birthDate, this.books);\n        }\n\n        public Author withBooks(List<String> books) {\n            return new Author(this.firstName, this.lastName, this.birthDate, books);\n        }\n    }\n\n    public static record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n        public Book withTitle(String title) {\n            return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withAuthor(Author author) {\n            return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withGenre(Genre genre) {\n            return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withPublicationDate(LocalDate publicationDate) {\n            return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n        }\n\n        public Book withPageCount(int pageCount) {\n            return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n        }\n    }\n\n    public static record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n        public Member withMemberId(String memberId) {\n            return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withFirstName(String firstName) {\n            return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withLastName(String lastName) {\n            return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withMembershipLevel(MembershipLevel membershipLevel) {\n            return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withJoinDate(LocalDate joinDate) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n        }\n\n        public Member withEmail(String email) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n        }\n    }\n\n    public static record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n        public Loan withLoanId(String loanId) {\n            return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withBook(Book book) {\n            return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withMember(Member member) {\n            return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withLoanDate(LocalDate loanDate) {\n            return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withReturnDate(LocalDate returnDate) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n        }\n\n        public Loan withReturned(boolean returned) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n        }\n    }\n    ```"},"sprouts.MVVM_Usage_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":21},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Maybe_Spec":{"executedFeatures":["The `or(Supplier)` method allows you to provide a fallback monad if the maybe is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided `Maybe` instances.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":17},"title":"Maybe","narrative":"`Maybe` is a monadic type interface which can\n    be created by one of the many factory methods on its interface.\n    The returned `Maybe`s are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the maybe itself.\n    \n    The `Maybe` interface is also a general super\n    type for Sprouts properties as well as the `Result` monad.\n    Its API ensures that you can safely work with\n    nullable values in a functional way."},"sprouts.Memory_Unsafe_Property_Binding_Spec":{"executedFeatures":["Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":17},"title":"","narrative":""},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":22},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":15},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Property_Binding_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":120},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property exposes you to the current and previous value of the property.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property tells you how the property has changed.","The delegate of a property user action exposes a property that is an immutable clone.","The delegate of a property view exposes you to the current and previous value of the property.","The delegate of a property view tells you how the property has changed."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":32},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A chain of lenses may be garbage collected, even when the source property stays in memory.","A chain of lenses may not be garbage collected.","A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","A lens on a property an effect on a view on this same property, even if it is de-referenced.","A lens stays in memory when there is a view on it.","A lens with a default value handles updates gracefully when switching from null parent to non-null parent.","A lens with a default value throws an exception when the null object is null.","A property knows if it is mutable or not or nullable or not.","A property lens knows that it is a property lens.","A property lens with a default value focuses on specific field with a non-null parent value.","A property lens with a default value updates the parent value correctly when setting it through the lens.","A property lens with a default value uses its default value when the parent property value is null initially.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Many lens properties can be created from a regular property and instances of the `Lens` interface.","Many lens properties can be created from a regular property.","The channel of a property change event will propagate to its lenses.","The lenses of a property are garbage collected when no longer referenced strongly.","We can create nullable lenses from nullable property even if there is no initial value.","You can access the item of a lens, even if an exception occurs in its getter.","You can create lens properties from other lens properties to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You can recognize a property lens from its String representation.","You can subscribe and unsubscribe observer lambdas on property lenses.()","You can try to change the item of a lens, even if an exception occurs in its wither.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":28,"totalFeatures":28,"passed":28,"successRate":1.0,"time":2349},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        \n        static record TrainStation(String name, String description, LocalDate foundingDate, List<String> trains) {\n            public TrainStation withName(String name) {\n                return new TrainStation(name, this.description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withDescription(String description) {\n                return new TrainStation(this.name, description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withBirthDate(LocalDate birthDate) {\n                return new TrainStation(this.name, this.description, birthDate, this.trains);\n            }\n    \n            public TrainStation withBooks(List<String> books) {\n                return new TrainStation(this.name, this.description, this.foundingDate, books);\n            }\n        }\n        ```"},"sprouts.Property_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","A non-null property list can accept a nullable list through \"addAll(Vals)\" as long as there are no nulls in the list.","A non-nullable property list does not accept nullable properties.","A nullable property list does not accept non-nullable properties.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Calling `.removeOrThrow(Var.of(..))` will always throw an exception.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","How not to use a property list.","Immutable property lists are considered equal if their values are equal.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The `is(Vals)` method checks if the items of the current property list are equal to the other property list.","The `remove(..)` methods remove all matching occurrences of a property from the list.","The `removeOrThrow(Val)` method removes the given property from the list or throws an exception if the property is not in the list.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","The various `setAllAt(int,..)` methods can throw index out of bounds exceptions.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Use `addAll(Vals)` to add the items as a new properties and use `addAll(Vars)` to add them unchanged.","Use `addAllAt(int, Vals)` to add the items as a new properties and use `addAllAt(int, Vars)` to add them unchanged.","Use `addAt(int,Val)` to set the item as a new property and use `addAt(int,Var)` to set the supplied property.","Use `all(Predicate)` to check if all properties in the list satisfy a given predicate.","Use `indicesOf(T)` to get the indices of all occurrences of a property in a list.","Use `setAllAt(int, Vals)` to set items as new properties and use `setAllAt(int, Vars)` to set them unchanged.","Use `setAt(int,Val)` to set the item as a new property and use `setAt(int,Var)` to set the supplied property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Using `addAt(int,Val)`, you can add a nullable property to a non-nullable list if the item is present.","Using `setAt(int,Val)`, you can place the item of a nullable property into a non-nullable list if the item is present.","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can add a `Stream` of items all at once at a particular index in a property list.","You can add a `Stream` of items all at once to a property list.","You can add properties to a nullable \"Vars\" list that from an immutable property list.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create a nullable immutable property list from nullable properties only.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method.","You cannot construct a non-nullable property list from nullable properties.","You cannot construct a nullable property list from non-nullable properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":108,"totalFeatures":84,"passed":108,"successRate":1.0,"time":602},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_List_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views does not remain in memory, when the last view is not referenced.","A chain of views remains in memory, as long as the last view is still referenced.","A property list may be garbage collected, even if there are still views on it.","A property list view is garbage collected when no longer referenced","The views of individual properties of a property list view can be garbage collected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":325},"title":"Property List View Memory Safety","narrative":"`Vals` (read-only) and `Vars` (mutable) are designed to be used in MVVM or MVI architectures.\n    This is why they need to be observable, which is achieved by registering change listeners on their \"views\".\n    These views are weakly referenced and automatically updated when the original property changes.\n    You can subscribe to these views to get notified of changes.\n\n    This is useful for observing a property list of one type as another type or with transformations applied.\n\n    This specification demonstrates creating views from nullable and non-nullable property lists,\n    and shows how they may be garbage collected when no longer referenced."},"sprouts.Property_List_View_Spec":{"executedFeatures":["A property list view created using `view()` will receive change events from its source.","A property list view created using `view(U,U,Function<T,U>)` will receive change events from its source.","A property list view has a `toString()` method that returns a insightful string representation of the view.","Calling `revert()` on a property list will also revert its views.","The `view(U,U,Function<T,U>)` method creates a dynamically updated live view of its source list.","The `viewSize()` method returns a property that is equal to the size of the original property.","The properties of a list view can themselves be observed for changes in the source properties.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":30},"title":"Property List Views","narrative":"A property list is more than just a wrapper around values.\n    This interface has a rich API that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n\n    For these facts about any property list, we can create views.\n    These views are observable live properties that are updated\n    whenever the source property list changes."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property can throw a cached exception if you try to access its value.","An empty property can throw an un-exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items.","The \"orElseNull\" method should be used instead of \"orElseThrowUnchecked\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":9,"passed":14,"successRate":1.0,"time":21},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Property_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","A property will find the correct type of an item, even if it is an anonymous class based enum constant.","Conveniently compare properties with other properties using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Exceptions inside the function of the `update(Function)` method reach the caller.","Exceptions inside the function of the `updateNullable(Function)` method reach the caller.","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around an item","Properties not only have an item but also a type and id!","The `get()` method will throw an exception if there is no element present.","The `ifPresent` method allows us to see if a property has an item or not.","The equality and hash code of a mutable property is based on its identity!","The equality and hash code of an immutable property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","Use `typeAsString()` to get the type of a property as a string.","Use `withId(String id)` to create a new property with a new String based id.","You can map null items of a property through the `updateNullable(Function)` method.","You can see if a property is a `Var` or `Val` by looking at their String representations.","You can update a nullable property item based on the current item through the `updateNullable(Function)` method.","You can update a property item based on the current item through the `update(Function)` method.","You cannot map `null` items of a property through the `update(Function)` method.","You may not pass a `null` reference to the `update(Function)` method.","You may not pass a null function to the `updateNullable(Function)` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":25,"totalFeatures":25,"passed":25,"successRate":1.0,"time":48},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views may not be garbage collected.","A composite view of 2 properties will not break if the first observed property is garbage collected.","A composite view of 2 properties will not break if the second observed property is garbage collected.","Even if property views have change listeners, they will be garbage collected if you do not reference them.","Properties can be garbage collected, even if they are observed by a composite view.","Properties can be garbage collected, even if they are observed by a nullable composite view.","The change listener of property view parents are garbage collected when the view is no longer referenced strongly.","You can subscribe and unsubscribe action lambdas on property views.()","You can subscribe and unsubscribe observer lambdas on property views.()"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":68,"totalFeatures":9,"passed":68,"successRate":1.0,"time":7557},"title":"Property View Memory Safety","narrative":"Both the read only `Val` and the mutable `Var` are designed to be\n    used as part of a view model in a Model-View-ViewModel (MVVM) architecture\n    or Model-View-Intent (MVI) architecture.\n    As a consequence, they need to be observable in some way.\n    This is done by registering change listeners on \n    the \"views\" of properties, which are weakly referenced\n    live views of the original property which gets updated\n    automatically when the original property changes.\n    You can then subscribe to these views to get notified\n    of changes to the original property.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,\n    and it demonstrates how they may be garbage collected when they are no longer referenced."},"sprouts.Property_View_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","A composite view has an id that is the concatenation of the ids of its source properties.","A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Map null to custom values when viewing them as primitive types.","The `onChange` event delegate tells you the type of change the property experienced.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The channel of a property change event will propagate to its views.","There are various kinds of convenience methods for creating live views of properties.","This is how not to use views.","Use `viewAsDouble(double,Function)` to view a nullable property as a non null double.","Use `viewAsInt(int,Function)` to view a nullable property as a non null integer.","Use `viewAsTuple` to create a view of a property as a tuple.","Use the `view(Function)` method to create a view of a property of the same type.","Use the `viewAsString(String,Function)` method to view a nullable property as a non null String.","Use the `viewAs` method to create a dynamically updated view of a property.","You can recognize a property view from its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":27,"totalFeatures":27,"passed":27,"successRate":1.0,"time":195},"title":"Property Views","narrative":"Properties are designed to be observable, which means that you can \"react\"\n    to their items being replaced by new items. This sort of \"reaction\"\n    to changes is typically done through the \"observer pattern\", where you\n    register change listeners on a property that are invoked whenever the\n    property item changes...\n    \n    Contrary to what you might might expect, you cannot register change listeners\n    on properties directly!\n    This is to prevent you from creating memory leaks, which happen very often \n    due to change listeners not being unregistered when they are no longer needed.\n    To fix this, Sprouts provides the concept of a \"property view\" in\n    the form of instances of the `Viewable` type, \n    which is a weakly referenced live property onto which you can safely register \n    your change listeners. \n    And when you no longer use the view (by holding a reference to it), \n    it will be garbage collected along with all of the change listeners \n    that were registered on it.\n    \n    But if you keep a reference to the view and a change occurs on the source property,\n    then the view will be updated and all of the change listeners will be notified\n    of the change."},"sprouts.Result_Spec":{"executedFeatures":["A `Result` is not mutable.","A result can be created from multiple problems.","A result will find the correct type of an item, even if it is an anonymous class based enum constant.","An empty `Result` can be mapped to any property type without an exception being thrown.","An exception occurring when peeking at each problem of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with even more problems.","An exception occurring when peeking at the problems of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with yet another problem.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like many other Sprouts types, a `Result` has a type.","Results can be turned into an Optional.","The equality of two `Result` instances is based on the type and the item of the result.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list.","You can peek into a `Result` to look at all of its \u00b4Problem\u00b4s.","You can peek into a `Result` to look at each \u00b4Problem\u00b4 individually.","You can recognize a `Result` by its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":19,"totalFeatures":19,"passed":19,"successRate":1.0,"time":40},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    The problems of a `Result` are represented by the `Problem` interface,\n    which may be created from an exception or a simple message.\n    \n    A `Result` is a fully thread safe immutable value type with useful mapping\n    functions that allow you to transform the value of the result into another\n    effectively making it a monadic value similar to the `Optional` type in Java 8."},"sprouts.Sequence_Invariance_Spec":{"executedFeatures":["A property list and its changes are always invariant to its list view.","Various operations between `Tuple` and `Vars` are invariant."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":69,"totalFeatures":2,"passed":69,"successRate":1.0,"time":107},"title":"Sequence Invariance","narrative":"This specification tests the functional invariance between\n    operations on the mutable `Vars` type and the immutable `Tuple` type."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `remove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":253,"totalFeatures":43,"passed":253,"successRate":1.0,"time":1005},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.ValueSet_Spec":{"executedFeatures":["An empty ValueSet is created by specifying the element type","Bulk operations handle large datasets efficiently","Duplicate additions have no effect","Edge cases are handled gracefully","Empty set special cases","Equality and hash code follow set semantics","Immutable characteristics are preserved","Iterator behavior conforms to set semantics","Set operations maintain mathematical set properties","Set operations with Java collections","Stream integration works properly","String representation reflects contents","The `ValueSet` maintains invariance with Java Set across operations","The `clear` operation works on a non-empty value set","Use `ValueSet.classTyped(Class)` to created a typed class pointer to `ValueSet`.","addAll supports various collection types","bulk operations ignore duplicate elements in input","collector works with different stream sources","containsAll accurately checks membership across collection types","interoperates with Tuple collections","no-op operations return the same instance","operations with empty collections have no effect or clear as expected","removeAll handles different input collection types","retainAll works with diverse collection sources"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":26,"totalFeatures":24,"passed":26,"successRate":1.0,"time":130},"title":"Value Sets","narrative":"ValueSet is a fundamental building block in sprouts' data-oriented programming model.\n    It represents an immutable collection of unique elements, providing an API focused on\n    deriving new sets from existing ones rather than mutating state. Unlike traditional\n    Java sets, all operations return new `ValueSet` instances, making it ideal for\n    functional-style programming and safe concurrent usage."},"sprouts.Version_Spec":{"executedFeatures":["A lineage of successions can be ordered.","Two newly created versions have different lineage numbers but the same succession.","Two versions created from the same lineage have different succession numbers.","Use `isDirectPredecessorOf` to check if a version is the direct predecessor of another.","Use `isDirectSuccessorOf` to check if a version is the direct successor of another."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":13},"title":"Value based Identity","narrative":"When doing functional or data oriented programming then you are\n    working with value objects. These are objects that are immutable\n    and define their identity in terms of their values.\n    Which means that two objects are considered equal if they have\n    the same values, even if they are different instances.\n    \n    To model identity in value objects Sprouts provides the `Version` class.\n    It is a value object representing a unique ID. This ID consisting\n    of two numbers, a lineage and succession number allowing you to identify something\n    and also determine the order in which something was created\n    and updated.\n    This is intended to be used to emulate identity in\n    your value objects, which is useful for tracking changes\n    and synchronizing state across different parts of your application.\n    You may also use version changes to do reactive programming\n    for your value based view models, similar as you would do with\n    `Event`s in traditional place oriented view models."},"sprouts.Association_Spec":{"executedFeatures":["A larger `Association` will have a trimmed string representation.","An `Association` has an intuitive string representation.","An association is invariant to a map.","An empty association is created by supplying the type of the key and value","Association maintains full invariance with Map across all operations.","Associations with same entries in different order are equal","The `Association` class is an `Iterable` which allows you to iterate over its entries.","The `clear` method creates an empty association with the same key and value types.","The `entrySet` is immutable and contains correct pairs","The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.","The `putIfAbsent` does not overwrite an existing value already stored in an association.","The `replace` method replaces the value of a key with a new value, if and only if the key is present.","The `retainAll` method keeps only specified keys","The classTyped method returns the correct class and handles null parameters","The of factory method throws NPE for null parameters","Two associations the the same operations applied to them are always equal.","Use `Association.between(Number.class, Number.class)` to create an association between all kinds of numbers.","Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.","Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Pair...)` to populate an association at once from multiple pairs.","Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.","You can iterate over the `entrySet` of all pairs in an `Association`.","You can merge a large association and a map into a single association using the `putAll` method.","You can merge two associations into one using the `putAll` method.","You can merge two large associations into one using the `putAll` method.","You can remove the entries of a large association from another, using the `removeAll` method.","You remove the entries of one association from another, using the `removeAll(Set)` method.","You remove the entries of one association from another, using the `removeAll(ValueSet)` method.","clear on empty association returns an empty instance","replaceAll ignores non-existing keys in replacement stream","replaceAll with Map only updates existing keys","values() contains all values including duplicates"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":58,"totalFeatures":33,"passed":58,"successRate":1.0,"time":3532},"title":"Associations","narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming. \n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Viewable.of(..)` does not update when receiving `null` items","A composite property view created using the `Viewable.ofNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Viewable.of(..)` method cannot deal with `null`.","The change listeners of the parents of composite properties are garbage collected when the composite is no longer referenced strongly.","The second property of a composite view created using the `Viewable.of(..)` and `Viewable.ofNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":640},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A `WeakObserver` is removed and garbage collected together with its owner.","A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","The `Observable` of an `Event` can be garbage collected alongside its `Observer`s.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":135},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Immutable_Property_Spec":{"executedFeatures":["The `Val.equals(..)` method compares two objects by value.","The `Val.hashCode(..)` method returns the hash code of the value.","The `or(Supplier)` method allows you to provide a fallback property if the property is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided properties.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":9,"passed":32,"successRate":1.0,"time":51},"title":"Immutable Properties","narrative":"Immutable properties are properties created by one\n    of the many factory methods on the `Val` interface.\n    The returned `Val` properties are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the property itself."},"sprouts.Lens_Spec":{"executedFeatures":["Lens.across allows bulk transformation of tuples of homogeneous data","Lens.across handles edge cases with empty and single-element tuples","Lens.across maintains element order during bulk operations","You can compose lenses to update a deeply nested part of a data structure.","You can create lenses from other lenses to dive deeper into nested data structures."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":50},"title":"Functional Lenses","narrative":"The `Lens` interface defines an access and update operation on an individual \n    part of a nested and immutable data structure. \n    A lens can also be composed with other lenses to focus \n    on more deeply nested parts.\n    This design concept is part of the functional \n    programming paradigm, and it emulates\n    mutable properties (getter and setter) in an immutable world \n    using a *getter* and more importantly a *wither* methods \n    (a function that returns a new structure with target field being updated).\n\n    In this specification we demonstrate how to implement and use\n    your own lenses through the `Lens` interface and then\n    we show how these lenses can be composed to focus on deeply nested parts.\n    \n    We use the following data structures to demonstrate the concept:\n    ```\n    enum Genre { FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY }\n\n    enum MembershipLevel { BASIC, SILVER, GOLD, PLATINUM }\n\n    static record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n        public Author withFirstName(String firstName) {\n            return new Author(firstName, this.lastName, this.birthDate, this.books);\n        }\n\n        public Author withLastName(String lastName) {\n            return new Author(this.firstName, lastName, this.birthDate, this.books);\n        }\n\n        public Author withBirthDate(LocalDate birthDate) {\n            return new Author(this.firstName, this.lastName, birthDate, this.books);\n        }\n\n        public Author withBooks(List<String> books) {\n            return new Author(this.firstName, this.lastName, this.birthDate, books);\n        }\n    }\n\n    public static record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n        public Book withTitle(String title) {\n            return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withAuthor(Author author) {\n            return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withGenre(Genre genre) {\n            return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withPublicationDate(LocalDate publicationDate) {\n            return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n        }\n\n        public Book withPageCount(int pageCount) {\n            return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n        }\n    }\n\n    public static record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n        public Member withMemberId(String memberId) {\n            return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withFirstName(String firstName) {\n            return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withLastName(String lastName) {\n            return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withMembershipLevel(MembershipLevel membershipLevel) {\n            return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withJoinDate(LocalDate joinDate) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n        }\n\n        public Member withEmail(String email) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n        }\n    }\n\n    public static record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n        public Loan withLoanId(String loanId) {\n            return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withBook(Book book) {\n            return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withMember(Member member) {\n            return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withLoanDate(LocalDate loanDate) {\n            return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withReturnDate(LocalDate returnDate) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n        }\n\n        public Loan withReturned(boolean returned) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n        }\n    }\n    ```"},"sprouts.MVVM_Usage_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":17},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Maybe_Spec":{"executedFeatures":["The `or(Supplier)` method allows you to provide a fallback monad if the maybe is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided `Maybe` instances.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":18},"title":"Maybe","narrative":"`Maybe` is a monadic type interface which can\n    be created by one of the many factory methods on its interface.\n    The returned `Maybe`s are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the maybe itself.\n    \n    The `Maybe` interface is also a general super\n    type for Sprouts properties as well as the `Result` monad.\n    Its API ensures that you can safely work with\n    nullable values in a functional way."},"sprouts.Memory_Unsafe_Property_Binding_Spec":{"executedFeatures":["Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":19},"title":"","narrative":""},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":30},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":13},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Property_Binding_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":139},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property exposes you to the current and previous value of the property.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property tells you how the property has changed.","The delegate of a property user action exposes a property that is an immutable clone.","The delegate of a property view exposes you to the current and previous value of the property.","The delegate of a property view tells you how the property has changed."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":37},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A chain of lenses may be garbage collected, even when the source property stays in memory.","A chain of lenses may not be garbage collected.","A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","A lens on a property an effect on a view on this same property, even if it is de-referenced.","A lens stays in memory when there is a view on it.","A lens with a default value handles updates gracefully when switching from null parent to non-null parent.","A lens with a default value throws an exception when the null object is null.","A property knows if it is mutable or not or nullable or not.","A property lens knows that it is a property lens.","A property lens with a default value focuses on specific field with a non-null parent value.","A property lens with a default value updates the parent value correctly when setting it through the lens.","A property lens with a default value uses its default value when the parent property value is null initially.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Many lens properties can be created from a regular property and instances of the `Lens` interface.","Many lens properties can be created from a regular property.","The channel of a property change event will propagate to its lenses.","The lenses of a property are garbage collected when no longer referenced strongly.","We can create nullable lenses from nullable property even if there is no initial value.","You can access the item of a lens, even if an exception occurs in its getter.","You can create lens properties from other lens properties to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You can recognize a property lens from its String representation.","You can subscribe and unsubscribe observer lambdas on property lenses.()","You can try to change the item of a lens, even if an exception occurs in its wither.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":28,"totalFeatures":28,"passed":28,"successRate":1.0,"time":2271},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        \n        static record TrainStation(String name, String description, LocalDate foundingDate, List<String> trains) {\n            public TrainStation withName(String name) {\n                return new TrainStation(name, this.description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withDescription(String description) {\n                return new TrainStation(this.name, description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withBirthDate(LocalDate birthDate) {\n                return new TrainStation(this.name, this.description, birthDate, this.trains);\n            }\n    \n            public TrainStation withBooks(List<String> books) {\n                return new TrainStation(this.name, this.description, this.foundingDate, books);\n            }\n        }\n        ```"},"sprouts.Property_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","A non-null property list can accept a nullable list through \"addAll(Vals)\" as long as there are no nulls in the list.","A non-nullable property list does not accept nullable properties.","A nullable property list does not accept non-nullable properties.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Calling `.removeOrThrow(Var.of(..))` will always throw an exception.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","How not to use a property list.","Immutable property lists are considered equal if their values are equal.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The `is(Vals)` method checks if the items of the current property list are equal to the other property list.","The `remove(..)` methods remove all matching occurrences of a property from the list.","The `removeOrThrow(Val)` method removes the given property from the list or throws an exception if the property is not in the list.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","The various `setAllAt(int,..)` methods can throw index out of bounds exceptions.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Use `addAll(Vals)` to add the items as a new properties and use `addAll(Vars)` to add them unchanged.","Use `addAllAt(int, Vals)` to add the items as a new properties and use `addAllAt(int, Vars)` to add them unchanged.","Use `addAt(int,Val)` to set the item as a new property and use `addAt(int,Var)` to set the supplied property.","Use `all(Predicate)` to check if all properties in the list satisfy a given predicate.","Use `indicesOf(T)` to get the indices of all occurrences of a property in a list.","Use `setAllAt(int, Vals)` to set items as new properties and use `setAllAt(int, Vars)` to set them unchanged.","Use `setAt(int,Val)` to set the item as a new property and use `setAt(int,Var)` to set the supplied property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Using `addAt(int,Val)`, you can add a nullable property to a non-nullable list if the item is present.","Using `setAt(int,Val)`, you can place the item of a nullable property into a non-nullable list if the item is present.","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can add a `Stream` of items all at once at a particular index in a property list.","You can add a `Stream` of items all at once to a property list.","You can add properties to a nullable \"Vars\" list that from an immutable property list.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create a nullable immutable property list from nullable properties only.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method.","You cannot construct a non-nullable property list from nullable properties.","You cannot construct a nullable property list from non-nullable properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":108,"totalFeatures":84,"passed":108,"successRate":1.0,"time":549},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_List_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views does not remain in memory, when the last view is not referenced.","A chain of views remains in memory, as long as the last view is still referenced.","A property list may be garbage collected, even if there are still views on it.","A property list view is garbage collected when no longer referenced","The views of individual properties of a property list view can be garbage collected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":340},"title":"Property List View Memory Safety","narrative":"`Vals` (read-only) and `Vars` (mutable) are designed to be used in MVVM or MVI architectures.\n    This is why they need to be observable, which is achieved by registering change listeners on their \"views\".\n    These views are weakly referenced and automatically updated when the original property changes.\n    You can subscribe to these views to get notified of changes.\n\n    This is useful for observing a property list of one type as another type or with transformations applied.\n\n    This specification demonstrates creating views from nullable and non-nullable property lists,\n    and shows how they may be garbage collected when no longer referenced."},"sprouts.Property_List_View_Spec":{"executedFeatures":["A property list view created using `view()` will receive change events from its source.","A property list view created using `view(U,U,Function<T,U>)` will receive change events from its source.","A property list view has a `toString()` method that returns a insightful string representation of the view.","Calling `revert()` on a property list will also revert its views.","The `view(U,U,Function<T,U>)` method creates a dynamically updated live view of its source list.","The `viewSize()` method returns a property that is equal to the size of the original property.","The properties of a list view can themselves be observed for changes in the source properties.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":40},"title":"Property List Views","narrative":"A property list is more than just a wrapper around values.\n    This interface has a rich API that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n\n    For these facts about any property list, we can create views.\n    These views are observable live properties that are updated\n    whenever the source property list changes."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property can throw a cached exception if you try to access its value.","An empty property can throw an un-exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items.","The \"orElseNull\" method should be used instead of \"orElseThrowUnchecked\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":9,"passed":14,"successRate":1.0,"time":25},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Property_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","A property will find the correct type of an item, even if it is an anonymous class based enum constant.","Conveniently compare properties with other properties using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Exceptions inside the function of the `update(Function)` method reach the caller.","Exceptions inside the function of the `updateNullable(Function)` method reach the caller.","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around an item","Properties not only have an item but also a type and id!","The `get()` method will throw an exception if there is no element present.","The `ifPresent` method allows us to see if a property has an item or not.","The equality and hash code of a mutable property is based on its identity!","The equality and hash code of an immutable property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","Use `typeAsString()` to get the type of a property as a string.","Use `withId(String id)` to create a new property with a new String based id.","You can map null items of a property through the `updateNullable(Function)` method.","You can see if a property is a `Var` or `Val` by looking at their String representations.","You can update a nullable property item based on the current item through the `updateNullable(Function)` method.","You can update a property item based on the current item through the `update(Function)` method.","You cannot map `null` items of a property through the `update(Function)` method.","You may not pass a `null` reference to the `update(Function)` method.","You may not pass a null function to the `updateNullable(Function)` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":25,"totalFeatures":25,"passed":25,"successRate":1.0,"time":52},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views may not be garbage collected.","A composite view of 2 properties will not break if the first observed property is garbage collected.","A composite view of 2 properties will not break if the second observed property is garbage collected.","Even if property views have change listeners, they will be garbage collected if you do not reference them.","Properties can be garbage collected, even if they are observed by a composite view.","Properties can be garbage collected, even if they are observed by a nullable composite view.","The change listener of property view parents are garbage collected when the view is no longer referenced strongly.","You can subscribe and unsubscribe action lambdas on property views.()","You can subscribe and unsubscribe observer lambdas on property views.()"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":68,"totalFeatures":9,"passed":68,"successRate":1.0,"time":7348},"title":"Property View Memory Safety","narrative":"Both the read only `Val` and the mutable `Var` are designed to be\n    used as part of a view model in a Model-View-ViewModel (MVVM) architecture\n    or Model-View-Intent (MVI) architecture.\n    As a consequence, they need to be observable in some way.\n    This is done by registering change listeners on \n    the \"views\" of properties, which are weakly referenced\n    live views of the original property which gets updated\n    automatically when the original property changes.\n    You can then subscribe to these views to get notified\n    of changes to the original property.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,\n    and it demonstrates how they may be garbage collected when they are no longer referenced."},"sprouts.Property_View_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","A composite view has an id that is the concatenation of the ids of its source properties.","A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Map null to custom values when viewing them as primitive types.","The `onChange` event delegate tells you the type of change the property experienced.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The channel of a property change event will propagate to its views.","There are various kinds of convenience methods for creating live views of properties.","This is how not to use views.","Use `viewAsDouble(double,Function)` to view a nullable property as a non null double.","Use `viewAsInt(int,Function)` to view a nullable property as a non null integer.","Use `viewAsTuple` to create a view of a property as a tuple.","Use the `view(Function)` method to create a view of a property of the same type.","Use the `viewAsString(String,Function)` method to view a nullable property as a non null String.","Use the `viewAs` method to create a dynamically updated view of a property.","You can recognize a property view from its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":27,"totalFeatures":27,"passed":27,"successRate":1.0,"time":399},"title":"Property Views","narrative":"Properties are designed to be observable, which means that you can \"react\"\n    to their items being replaced by new items. This sort of \"reaction\"\n    to changes is typically done through the \"observer pattern\", where you\n    register change listeners on a property that are invoked whenever the\n    property item changes...\n    \n    Contrary to what you might might expect, you cannot register change listeners\n    on properties directly!\n    This is to prevent you from creating memory leaks, which happen very often \n    due to change listeners not being unregistered when they are no longer needed.\n    To fix this, Sprouts provides the concept of a \"property view\" in\n    the form of instances of the `Viewable` type, \n    which is a weakly referenced live property onto which you can safely register \n    your change listeners. \n    And when you no longer use the view (by holding a reference to it), \n    it will be garbage collected along with all of the change listeners \n    that were registered on it.\n    \n    But if you keep a reference to the view and a change occurs on the source property,\n    then the view will be updated and all of the change listeners will be notified\n    of the change."},"sprouts.Result_Spec":{"executedFeatures":["A `Result` is not mutable.","A result can be created from multiple problems.","A result will find the correct type of an item, even if it is an anonymous class based enum constant.","An empty `Result` can be mapped to any property type without an exception being thrown.","An exception occurring when peeking at each problem of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with even more problems.","An exception occurring when peeking at the problems of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with yet another problem.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like many other Sprouts types, a `Result` has a type.","Results can be turned into an Optional.","The equality of two `Result` instances is based on the type and the item of the result.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list.","You can peek into a `Result` to look at all of its \u00b4Problem\u00b4s.","You can peek into a `Result` to look at each \u00b4Problem\u00b4 individually.","You can recognize a `Result` by its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":19,"totalFeatures":19,"passed":19,"successRate":1.0,"time":96},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    The problems of a `Result` are represented by the `Problem` interface,\n    which may be created from an exception or a simple message.\n    \n    A `Result` is a fully thread safe immutable value type with useful mapping\n    functions that allow you to transform the value of the result into another\n    effectively making it a monadic value similar to the `Optional` type in Java 8."},"sprouts.Sequence_Invariance_Spec":{"executedFeatures":["A property list and its changes are always invariant to its list view.","Various operations between `Tuple` and `Vars` are invariant."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":69,"totalFeatures":2,"passed":69,"successRate":1.0,"time":117},"title":"Sequence Invariance","narrative":"This specification tests the functional invariance between\n    operations on the mutable `Vars` type and the immutable `Tuple` type."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":7,"skipped":0,"totalRuns":253,"totalFeatures":43,"passed":246,"successRate":0.9723320158102767,"time":1163},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.ValueSet_Spec":{"executedFeatures":["An empty ValueSet is created by specifying the element type","Bulk operations handle large datasets efficiently","Duplicate additions have no effect","Edge cases are handled gracefully","Empty set special cases","Equality and hash code follow set semantics","Immutable characteristics are preserved","Iterator behavior conforms to set semantics","Set operations maintain mathematical set properties","Set operations with Java collections","Stream integration works properly","String representation reflects contents","The `ValueSet` maintains invariance with Java Set across operations","The `clear` operation works on a non-empty value set","Use `ValueSet.classTyped(Class)` to created a typed class pointer to `ValueSet`.","addAll supports various collection types","bulk operations ignore duplicate elements in input","collector works with different stream sources","containsAll accurately checks membership across collection types","interoperates with Tuple collections","no-op operations return the same instance","operations with empty collections have no effect or clear as expected","removeAll handles different input collection types","retainAll works with diverse collection sources"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":26,"totalFeatures":24,"passed":26,"successRate":1.0,"time":224},"title":"Value Sets","narrative":"ValueSet is a fundamental building block in sprouts' data-oriented programming model.\n    It represents an immutable collection of unique elements, providing an API focused on\n    deriving new sets from existing ones rather than mutating state. Unlike traditional\n    Java sets, all operations return new `ValueSet` instances, making it ideal for\n    functional-style programming and safe concurrent usage."},"sprouts.Version_Spec":{"executedFeatures":["A lineage of successions can be ordered.","Two newly created versions have different lineage numbers but the same succession.","Two versions created from the same lineage have different succession numbers.","Use `isDirectPredecessorOf` to check if a version is the direct predecessor of another.","Use `isDirectSuccessorOf` to check if a version is the direct successor of another."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":11},"title":"Value based Identity","narrative":"When doing functional or data oriented programming then you are\n    working with value objects. These are objects that are immutable\n    and define their identity in terms of their values.\n    Which means that two objects are considered equal if they have\n    the same values, even if they are different instances.\n    \n    To model identity in value objects Sprouts provides the `Version` class.\n    It is a value object representing a unique ID. This ID consisting\n    of two numbers, a lineage and succession number allowing you to identify something\n    and also determine the order in which something was created\n    and updated.\n    This is intended to be used to emulate identity in\n    your value objects, which is useful for tracking changes\n    and synchronizing state across different parts of your application.\n    You may also use version changes to do reactive programming\n    for your value based view models, similar as you would do with\n    `Event`s in traditional place oriented view models."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":43,"passed":7,"successRate":1.0,"time":115},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations."],"ignoredFeatures":[],"stats":{"failures":0,"errors":1,"skipped":0,"totalRuns":8,"totalFeatures":43,"passed":7,"successRate":0.875,"time":143},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations.","You can updating a non-nullable tuple with a non-empty `Maybe`."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":44,"passed":7,"successRate":1.0,"time":125},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.Association_Spec":{"executedFeatures":["A larger `Association` will have a trimmed string representation.","An `Association` has an intuitive string representation.","An association is invariant to a map.","An empty association is created by supplying the type of the key and value","Association maintains full invariance with Map across all operations.","Associations with same entries in different order are equal","The `Association` class is an `Iterable` which allows you to iterate over its entries.","The `clear` method creates an empty association with the same key and value types.","The `entrySet` is immutable and contains correct pairs","The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.","The `putIfAbsent` does not overwrite an existing value already stored in an association.","The `replace` method replaces the value of a key with a new value, if and only if the key is present.","The `retainAll` method keeps only specified keys","The classTyped method returns the correct class and handles null parameters","The of factory method throws NPE for null parameters","Two associations the the same operations applied to them are always equal.","Use `Association.between(Number.class, Number.class)` to create an association between all kinds of numbers.","Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.","Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Pair...)` to populate an association at once from multiple pairs.","Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.","You can iterate over the `entrySet` of all pairs in an `Association`.","You can merge a large association and a map into a single association using the `putAll` method.","You can merge two associations into one using the `putAll` method.","You can merge two large associations into one using the `putAll` method.","You can remove the entries of a large association from another, using the `removeAll` method.","You remove the entries of one association from another, using the `removeAll(Set)` method.","You remove the entries of one association from another, using the `removeAll(ValueSet)` method.","clear on empty association returns an empty instance","replaceAll ignores non-existing keys in replacement stream","replaceAll with Map only updates existing keys","values() contains all values including duplicates"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":58,"totalFeatures":33,"passed":58,"successRate":1.0,"time":3604},"title":"Associations","narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming. \n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Viewable.of(..)` does not update when receiving `null` items","A composite property view created using the `Viewable.ofNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Viewable.of(..)` method cannot deal with `null`.","The change listeners of the parents of composite properties are garbage collected when the composite is no longer referenced strongly.","The second property of a composite view created using the `Viewable.of(..)` and `Viewable.ofNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":646},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A `WeakObserver` is removed and garbage collected together with its owner.","A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","The `Observable` of an `Event` can be garbage collected alongside its `Observer`s.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":115},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Immutable_Property_Spec":{"executedFeatures":["The `Val.equals(..)` method compares two objects by value.","The `Val.hashCode(..)` method returns the hash code of the value.","The `or(Supplier)` method allows you to provide a fallback property if the property is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided properties.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":9,"passed":32,"successRate":1.0,"time":61},"title":"Immutable Properties","narrative":"Immutable properties are properties created by one\n    of the many factory methods on the `Val` interface.\n    The returned `Val` properties are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the property itself."},"sprouts.Lens_Spec":{"executedFeatures":["Lens.across allows bulk transformation of tuples of homogeneous data","Lens.across handles edge cases with empty and single-element tuples","Lens.across maintains element order during bulk operations","You can compose lenses to update a deeply nested part of a data structure.","You can create lenses from other lenses to dive deeper into nested data structures."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":40},"title":"Functional Lenses","narrative":"The `Lens` interface defines an access and update operation on an individual \n    part of a nested and immutable data structure. \n    A lens can also be composed with other lenses to focus \n    on more deeply nested parts.\n    This design concept is part of the functional \n    programming paradigm, and it emulates\n    mutable properties (getter and setter) in an immutable world \n    using a *getter* and more importantly a *wither* methods \n    (a function that returns a new structure with target field being updated).\n\n    In this specification we demonstrate how to implement and use\n    your own lenses through the `Lens` interface and then\n    we show how these lenses can be composed to focus on deeply nested parts.\n    \n    We use the following data structures to demonstrate the concept:\n    ```\n    enum Genre { FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY }\n\n    enum MembershipLevel { BASIC, SILVER, GOLD, PLATINUM }\n\n    static record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n        public Author withFirstName(String firstName) {\n            return new Author(firstName, this.lastName, this.birthDate, this.books);\n        }\n\n        public Author withLastName(String lastName) {\n            return new Author(this.firstName, lastName, this.birthDate, this.books);\n        }\n\n        public Author withBirthDate(LocalDate birthDate) {\n            return new Author(this.firstName, this.lastName, birthDate, this.books);\n        }\n\n        public Author withBooks(List<String> books) {\n            return new Author(this.firstName, this.lastName, this.birthDate, books);\n        }\n    }\n\n    public static record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n        public Book withTitle(String title) {\n            return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withAuthor(Author author) {\n            return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withGenre(Genre genre) {\n            return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withPublicationDate(LocalDate publicationDate) {\n            return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n        }\n\n        public Book withPageCount(int pageCount) {\n            return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n        }\n    }\n\n    public static record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n        public Member withMemberId(String memberId) {\n            return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withFirstName(String firstName) {\n            return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withLastName(String lastName) {\n            return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withMembershipLevel(MembershipLevel membershipLevel) {\n            return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withJoinDate(LocalDate joinDate) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n        }\n\n        public Member withEmail(String email) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n        }\n    }\n\n    public static record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n        public Loan withLoanId(String loanId) {\n            return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withBook(Book book) {\n            return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withMember(Member member) {\n            return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withLoanDate(LocalDate loanDate) {\n            return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withReturnDate(LocalDate returnDate) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n        }\n\n        public Loan withReturned(boolean returned) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n        }\n    }\n    ```"},"sprouts.MVVM_Usage_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":15},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Maybe_Spec":{"executedFeatures":["The `or(Supplier)` method allows you to provide a fallback monad if the maybe is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided `Maybe` instances.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":12},"title":"Maybe","narrative":"`Maybe` is a monadic type interface which can\n    be created by one of the many factory methods on its interface.\n    The returned `Maybe`s are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the maybe itself.\n    \n    The `Maybe` interface is also a general super\n    type for Sprouts properties as well as the `Result` monad.\n    Its API ensures that you can safely work with\n    nullable values in a functional way."},"sprouts.Memory_Unsafe_Property_Binding_Spec":{"executedFeatures":["Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":16},"title":"","narrative":""},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":26},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":9},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Property_Binding_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":122},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property exposes you to the current and previous value of the property.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property tells you how the property has changed.","The delegate of a property user action exposes a property that is an immutable clone.","The delegate of a property view exposes you to the current and previous value of the property.","The delegate of a property view tells you how the property has changed."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":31},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A chain of lenses may be garbage collected, even when the source property stays in memory.","A chain of lenses may not be garbage collected.","A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","A lens on a property an effect on a view on this same property, even if it is de-referenced.","A lens stays in memory when there is a view on it.","A lens with a default value handles updates gracefully when switching from null parent to non-null parent.","A lens with a default value throws an exception when the null object is null.","A property knows if it is mutable or not or nullable or not.","A property lens knows that it is a property lens.","A property lens with a default value focuses on specific field with a non-null parent value.","A property lens with a default value updates the parent value correctly when setting it through the lens.","A property lens with a default value uses its default value when the parent property value is null initially.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Many lens properties can be created from a regular property and instances of the `Lens` interface.","Many lens properties can be created from a regular property.","The channel of a property change event will propagate to its lenses.","The lenses of a property are garbage collected when no longer referenced strongly.","We can create nullable lenses from nullable property even if there is no initial value.","You can access the item of a lens, even if an exception occurs in its getter.","You can create lens properties from other lens properties to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You can recognize a property lens from its String representation.","You can subscribe and unsubscribe observer lambdas on property lenses.()","You can try to change the item of a lens, even if an exception occurs in its wither.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":28,"totalFeatures":28,"passed":28,"successRate":1.0,"time":2215},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        \n        static record TrainStation(String name, String description, LocalDate foundingDate, List<String> trains) {\n            public TrainStation withName(String name) {\n                return new TrainStation(name, this.description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withDescription(String description) {\n                return new TrainStation(this.name, description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withBirthDate(LocalDate birthDate) {\n                return new TrainStation(this.name, this.description, birthDate, this.trains);\n            }\n    \n            public TrainStation withBooks(List<String> books) {\n                return new TrainStation(this.name, this.description, this.foundingDate, books);\n            }\n        }\n        ```"},"sprouts.Property_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","A non-null property list can accept a nullable list through \"addAll(Vals)\" as long as there are no nulls in the list.","A non-nullable property list does not accept nullable properties.","A nullable property list does not accept non-nullable properties.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Calling `.removeOrThrow(Var.of(..))` will always throw an exception.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","How not to use a property list.","Immutable property lists are considered equal if their values are equal.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The `is(Vals)` method checks if the items of the current property list are equal to the other property list.","The `remove(..)` methods remove all matching occurrences of a property from the list.","The `removeOrThrow(Val)` method removes the given property from the list or throws an exception if the property is not in the list.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","The various `setAllAt(int,..)` methods can throw index out of bounds exceptions.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Use `addAll(Vals)` to add the items as a new properties and use `addAll(Vars)` to add them unchanged.","Use `addAllAt(int, Vals)` to add the items as a new properties and use `addAllAt(int, Vars)` to add them unchanged.","Use `addAt(int,Val)` to set the item as a new property and use `addAt(int,Var)` to set the supplied property.","Use `all(Predicate)` to check if all properties in the list satisfy a given predicate.","Use `indicesOf(T)` to get the indices of all occurrences of a property in a list.","Use `setAllAt(int, Vals)` to set items as new properties and use `setAllAt(int, Vars)` to set them unchanged.","Use `setAt(int,Val)` to set the item as a new property and use `setAt(int,Var)` to set the supplied property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Using `addAt(int,Val)`, you can add a nullable property to a non-nullable list if the item is present.","Using `setAt(int,Val)`, you can place the item of a nullable property into a non-nullable list if the item is present.","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can add a `Stream` of items all at once at a particular index in a property list.","You can add a `Stream` of items all at once to a property list.","You can add properties to a nullable \"Vars\" list that from an immutable property list.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create a nullable immutable property list from nullable properties only.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method.","You cannot construct a non-nullable property list from nullable properties.","You cannot construct a nullable property list from non-nullable properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":108,"totalFeatures":84,"passed":108,"successRate":1.0,"time":559},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_List_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views does not remain in memory, when the last view is not referenced.","A chain of views remains in memory, as long as the last view is still referenced.","A property list may be garbage collected, even if there are still views on it.","A property list view is garbage collected when no longer referenced","The views of individual properties of a property list view can be garbage collected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":299},"title":"Property List View Memory Safety","narrative":"`Vals` (read-only) and `Vars` (mutable) are designed to be used in MVVM or MVI architectures.\n    This is why they need to be observable, which is achieved by registering change listeners on their \"views\".\n    These views are weakly referenced and automatically updated when the original property changes.\n    You can subscribe to these views to get notified of changes.\n\n    This is useful for observing a property list of one type as another type or with transformations applied.\n\n    This specification demonstrates creating views from nullable and non-nullable property lists,\n    and shows how they may be garbage collected when no longer referenced."},"sprouts.Property_List_View_Spec":{"executedFeatures":["A property list view created using `view()` will receive change events from its source.","A property list view created using `view(U,U,Function<T,U>)` will receive change events from its source.","A property list view has a `toString()` method that returns a insightful string representation of the view.","Calling `revert()` on a property list will also revert its views.","The `view(U,U,Function<T,U>)` method creates a dynamically updated live view of its source list.","The `viewSize()` method returns a property that is equal to the size of the original property.","The properties of a list view can themselves be observed for changes in the source properties.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":33},"title":"Property List Views","narrative":"A property list is more than just a wrapper around values.\n    This interface has a rich API that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n\n    For these facts about any property list, we can create views.\n    These views are observable live properties that are updated\n    whenever the source property list changes."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property can throw a cached exception if you try to access its value.","An empty property can throw an un-exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items.","The \"orElseNull\" method should be used instead of \"orElseThrowUnchecked\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":9,"passed":14,"successRate":1.0,"time":22},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Property_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","A property will find the correct type of an item, even if it is an anonymous class based enum constant.","Conveniently compare properties with other properties using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Exceptions inside the function of the `update(Function)` method reach the caller.","Exceptions inside the function of the `updateNullable(Function)` method reach the caller.","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around an item","Properties not only have an item but also a type and id!","The `get()` method will throw an exception if there is no element present.","The `ifPresent` method allows us to see if a property has an item or not.","The equality and hash code of a mutable property is based on its identity!","The equality and hash code of an immutable property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","Use `typeAsString()` to get the type of a property as a string.","Use `withId(String id)` to create a new property with a new String based id.","You can map null items of a property through the `updateNullable(Function)` method.","You can see if a property is a `Var` or `Val` by looking at their String representations.","You can update a nullable property item based on the current item through the `updateNullable(Function)` method.","You can update a property item based on the current item through the `update(Function)` method.","You cannot map `null` items of a property through the `update(Function)` method.","You may not pass a `null` reference to the `update(Function)` method.","You may not pass a null function to the `updateNullable(Function)` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":25,"totalFeatures":25,"passed":25,"successRate":1.0,"time":51},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views may not be garbage collected.","A composite view of 2 properties will not break if the first observed property is garbage collected.","A composite view of 2 properties will not break if the second observed property is garbage collected.","Even if property views have change listeners, they will be garbage collected if you do not reference them.","Properties can be garbage collected, even if they are observed by a composite view.","Properties can be garbage collected, even if they are observed by a nullable composite view.","The change listener of property view parents are garbage collected when the view is no longer referenced strongly.","You can subscribe and unsubscribe action lambdas on property views.()","You can subscribe and unsubscribe observer lambdas on property views.()"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":68,"totalFeatures":9,"passed":68,"successRate":1.0,"time":7030},"title":"Property View Memory Safety","narrative":"Both the read only `Val` and the mutable `Var` are designed to be\n    used as part of a view model in a Model-View-ViewModel (MVVM) architecture\n    or Model-View-Intent (MVI) architecture.\n    As a consequence, they need to be observable in some way.\n    This is done by registering change listeners on \n    the \"views\" of properties, which are weakly referenced\n    live views of the original property which gets updated\n    automatically when the original property changes.\n    You can then subscribe to these views to get notified\n    of changes to the original property.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,\n    and it demonstrates how they may be garbage collected when they are no longer referenced."},"sprouts.Property_View_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","A composite view has an id that is the concatenation of the ids of its source properties.","A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Map null to custom values when viewing them as primitive types.","The `onChange` event delegate tells you the type of change the property experienced.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The channel of a property change event will propagate to its views.","There are various kinds of convenience methods for creating live views of properties.","This is how not to use views.","Use `viewAsDouble(double,Function)` to view a nullable property as a non null double.","Use `viewAsInt(int,Function)` to view a nullable property as a non null integer.","Use `viewAsTuple` to create a view of a property as a tuple.","Use the `view(Function)` method to create a view of a property of the same type.","Use the `viewAsString(String,Function)` method to view a nullable property as a non null String.","Use the `viewAs` method to create a dynamically updated view of a property.","You can recognize a property view from its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":27,"totalFeatures":27,"passed":27,"successRate":1.0,"time":233},"title":"Property Views","narrative":"Properties are designed to be observable, which means that you can \"react\"\n    to their items being replaced by new items. This sort of \"reaction\"\n    to changes is typically done through the \"observer pattern\", where you\n    register change listeners on a property that are invoked whenever the\n    property item changes...\n    \n    Contrary to what you might might expect, you cannot register change listeners\n    on properties directly!\n    This is to prevent you from creating memory leaks, which happen very often \n    due to change listeners not being unregistered when they are no longer needed.\n    To fix this, Sprouts provides the concept of a \"property view\" in\n    the form of instances of the `Viewable` type, \n    which is a weakly referenced live property onto which you can safely register \n    your change listeners. \n    And when you no longer use the view (by holding a reference to it), \n    it will be garbage collected along with all of the change listeners \n    that were registered on it.\n    \n    But if you keep a reference to the view and a change occurs on the source property,\n    then the view will be updated and all of the change listeners will be notified\n    of the change."},"sprouts.Result_Spec":{"executedFeatures":["A `Result` is not mutable.","A result can be created from multiple problems.","A result will find the correct type of an item, even if it is an anonymous class based enum constant.","An empty `Result` can be mapped to any property type without an exception being thrown.","An exception occurring when peeking at each problem of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with even more problems.","An exception occurring when peeking at the problems of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with yet another problem.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like many other Sprouts types, a `Result` has a type.","Results can be turned into an Optional.","The equality of two `Result` instances is based on the type and the item of the result.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list.","You can peek into a `Result` to look at all of its \u00b4Problem\u00b4s.","You can peek into a `Result` to look at each \u00b4Problem\u00b4 individually.","You can recognize a `Result` by its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":19,"totalFeatures":19,"passed":19,"successRate":1.0,"time":47},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    The problems of a `Result` are represented by the `Problem` interface,\n    which may be created from an exception or a simple message.\n    \n    A `Result` is a fully thread safe immutable value type with useful mapping\n    functions that allow you to transform the value of the result into another\n    effectively making it a monadic value similar to the `Optional` type in Java 8."},"sprouts.Sequence_Invariance_Spec":{"executedFeatures":["A property list and its changes are always invariant to its list view.","Various operations between `Tuple` and `Vars` are invariant."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":69,"totalFeatures":2,"passed":69,"successRate":1.0,"time":131},"title":"Sequence Invariance","narrative":"This specification tests the functional invariance between\n    operations on the mutable `Vars` type and the immutable `Tuple` type."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations.","You can updating a non-nullable tuple with a non-empty `Maybe`."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":260,"totalFeatures":44,"passed":260,"successRate":1.0,"time":956},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.ValueSet_Spec":{"executedFeatures":["An empty ValueSet is created by specifying the element type","Bulk operations handle large datasets efficiently","Duplicate additions have no effect","Edge cases are handled gracefully","Empty set special cases","Equality and hash code follow set semantics","Immutable characteristics are preserved","Iterator behavior conforms to set semantics","Set operations maintain mathematical set properties","Set operations with Java collections","Stream integration works properly","String representation reflects contents","The `ValueSet` maintains invariance with Java Set across operations","The `clear` operation works on a non-empty value set","Use `ValueSet.classTyped(Class)` to created a typed class pointer to `ValueSet`.","addAll supports various collection types","bulk operations ignore duplicate elements in input","collector works with different stream sources","containsAll accurately checks membership across collection types","interoperates with Tuple collections","no-op operations return the same instance","operations with empty collections have no effect or clear as expected","removeAll handles different input collection types","retainAll works with diverse collection sources"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":26,"totalFeatures":24,"passed":26,"successRate":1.0,"time":181},"title":"Value Sets","narrative":"ValueSet is a fundamental building block in sprouts' data-oriented programming model.\n    It represents an immutable collection of unique elements, providing an API focused on\n    deriving new sets from existing ones rather than mutating state. Unlike traditional\n    Java sets, all operations return new `ValueSet` instances, making it ideal for\n    functional-style programming and safe concurrent usage."},"sprouts.Version_Spec":{"executedFeatures":["A lineage of successions can be ordered.","Two newly created versions have different lineage numbers but the same succession.","Two versions created from the same lineage have different succession numbers.","Use `isDirectPredecessorOf` to check if a version is the direct predecessor of another.","Use `isDirectSuccessorOf` to check if a version is the direct successor of another."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":9},"title":"Value based Identity","narrative":"When doing functional or data oriented programming then you are\n    working with value objects. These are objects that are immutable\n    and define their identity in terms of their values.\n    Which means that two objects are considered equal if they have\n    the same values, even if they are different instances.\n    \n    To model identity in value objects Sprouts provides the `Version` class.\n    It is a value object representing a unique ID. This ID consisting\n    of two numbers, a lineage and succession number allowing you to identify something\n    and also determine the order in which something was created\n    and updated.\n    This is intended to be used to emulate identity in\n    your value objects, which is useful for tracking changes\n    and synchronizing state across different parts of your application.\n    You may also use version changes to do reactive programming\n    for your value based view models, similar as you would do with\n    `Event`s in traditional place oriented view models."},"sprouts.Association_Spec":{"executedFeatures":["A larger `Association` will have a trimmed string representation.","An `Association` has an intuitive string representation.","An association is invariant to a map.","An empty association is created by supplying the type of the key and value","Association maintains full invariance with Map across all operations.","Associations with same entries in different order are equal","The `Association` class is an `Iterable` which allows you to iterate over its entries.","The `clear` method creates an empty association with the same key and value types.","The `entrySet` is immutable and contains correct pairs","The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.","The `putIfAbsent` does not overwrite an existing value already stored in an association.","The `replace` method replaces the value of a key with a new value, if and only if the key is present.","The `retainAll` method keeps only specified keys","The classTyped method returns the correct class and handles null parameters","The of factory method throws NPE for null parameters","Two associations the the same operations applied to them are always equal.","Use `Association.between(Number.class, Number.class)` to create an association between all kinds of numbers.","Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.","Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Pair...)` to populate an association at once from multiple pairs.","Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.","Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.","You can iterate over the `entrySet` of all pairs in an `Association`.","You can merge a large association and a map into a single association using the `putAll` method.","You can merge two associations into one using the `putAll` method.","You can merge two large associations into one using the `putAll` method.","You can remove the entries of a large association from another, using the `removeAll` method.","You remove the entries of one association from another, using the `removeAll(Set)` method.","You remove the entries of one association from another, using the `removeAll(ValueSet)` method.","clear on empty association returns an empty instance","replaceAll ignores non-existing keys in replacement stream","replaceAll with Map only updates existing keys","values() contains all values including duplicates"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":58,"totalFeatures":33,"passed":58,"successRate":1.0,"time":3353},"title":"Associations","narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming. \n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it."},"sprouts.Composite_Properties_Spec":{"executedFeatures":["A composite property view created using the `Viewable.of(..)` does not update when receiving `null` items","A composite property view created using the `Viewable.ofNullable(..)` allows `null`.","A composite property view is a live view of 2 other properties.","A non nullable composite property view may be created from two nullable properties.","Some non-nullable composite properties created using the `Viewable.of(..)` method cannot deal with `null`.","The change listeners of the parents of composite properties are garbage collected when the composite is no longer referenced strongly.","The second property of a composite view created using the `Viewable.of(..)` and `Viewable.ofNullable(..)` methods can be of any type.","You can combine different types into a composite property view.","You can combine different types into a nullable composite property view."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":662},"title":"Composite Property Views","narrative":"A composite property view is an immutable property that is a live view of two other properties.\n    It is especially useful when you want to observe 2 properties merged into one maybe with some\n    sort of transformation applied to them."},"sprouts.Event_Spec":{"executedFeatures":["A `WeakObserver` is removed and garbage collected together with its owner.","A listener can be unsubscribed from an Event.","The \"Event.of\" factory method is a shortcut for creating an event with an initial listener.","The `Observable` of an `Event` can be garbage collected alongside its `Observer`s.","We can create an event using the \"Event.create\" factory method.","We can create an event using the \"Event.using\" factory method with a custom executor.","We can unsubscribe all Listeners from an Event!"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":140},"title":"Events","narrative":"Sprouts models events using 2 simple interfaces, \n    the `sprouts.Observable` interface\n    and the trigger-able `Event` interface where `Event` is a sub type of `Observable`.\n    The `Event` interface is used to fire events, and because it extends the `Observable` interface\n    it allows you to listen to an event through the registration of `Observer` instances.\n    \n    `Event`s can be created using various factory methods (like for example `Event.create()`),\n    one of which even allows the specification of a custom `Event.Executor`\n    which can be used to control on which thread(s) the event is fired."},"sprouts.Immutable_Property_Spec":{"executedFeatures":["The `Val.equals(..)` method compares two objects by value.","The `Val.hashCode(..)` method returns the hash code of the value.","The `or(Supplier)` method allows you to provide a fallback property if the property is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided properties.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":32,"totalFeatures":9,"passed":32,"successRate":1.0,"time":50},"title":"Immutable Properties","narrative":"Immutable properties are properties created by one\n    of the many factory methods on the `Val` interface.\n    The returned `Val` properties are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the property itself."},"sprouts.Lens_Spec":{"executedFeatures":["Lens.across allows bulk transformation of tuples of homogeneous data","Lens.across handles edge cases with empty and single-element tuples","Lens.across maintains element order during bulk operations","You can compose lenses to update a deeply nested part of a data structure.","You can create lenses from other lenses to dive deeper into nested data structures."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":43},"title":"Functional Lenses","narrative":"The `Lens` interface defines an access and update operation on an individual \n    part of a nested and immutable data structure. \n    A lens can also be composed with other lenses to focus \n    on more deeply nested parts.\n    This design concept is part of the functional \n    programming paradigm, and it emulates\n    mutable properties (getter and setter) in an immutable world \n    using a *getter* and more importantly a *wither* methods \n    (a function that returns a new structure with target field being updated).\n\n    In this specification we demonstrate how to implement and use\n    your own lenses through the `Lens` interface and then\n    we show how these lenses can be composed to focus on deeply nested parts.\n    \n    We use the following data structures to demonstrate the concept:\n    ```\n    enum Genre { FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY }\n\n    enum MembershipLevel { BASIC, SILVER, GOLD, PLATINUM }\n\n    static record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n        public Author withFirstName(String firstName) {\n            return new Author(firstName, this.lastName, this.birthDate, this.books);\n        }\n\n        public Author withLastName(String lastName) {\n            return new Author(this.firstName, lastName, this.birthDate, this.books);\n        }\n\n        public Author withBirthDate(LocalDate birthDate) {\n            return new Author(this.firstName, this.lastName, birthDate, this.books);\n        }\n\n        public Author withBooks(List<String> books) {\n            return new Author(this.firstName, this.lastName, this.birthDate, books);\n        }\n    }\n\n    public static record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n        public Book withTitle(String title) {\n            return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withAuthor(Author author) {\n            return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withGenre(Genre genre) {\n            return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n        }\n\n        public Book withPublicationDate(LocalDate publicationDate) {\n            return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n        }\n\n        public Book withPageCount(int pageCount) {\n            return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n        }\n    }\n\n    public static record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n        public Member withMemberId(String memberId) {\n            return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withFirstName(String firstName) {\n            return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withLastName(String lastName) {\n            return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withMembershipLevel(MembershipLevel membershipLevel) {\n            return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n        }\n\n        public Member withJoinDate(LocalDate joinDate) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n        }\n\n        public Member withEmail(String email) {\n            return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n        }\n    }\n\n    public static record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n        public Loan withLoanId(String loanId) {\n            return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withBook(Book book) {\n            return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withMember(Member member) {\n            return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withLoanDate(LocalDate loanDate) {\n            return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n        }\n\n        public Loan withReturnDate(LocalDate returnDate) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n        }\n\n        public Loan withReturned(boolean returned) {\n            return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n        }\n    }\n    ```"},"sprouts.MVVM_Usage_Spec":{"executedFeatures":["The register button does nothing if the inputs are not all valid.","The registration view model will display feedback about invalid inputs."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":2,"totalFeatures":2,"passed":2,"successRate":1.0,"time":18},"title":"Writing Unit Tests for View Models","narrative":"Not only is Sprouts a framework for building UIs, it is also a framework for\n    building view models based on its built in property types. \n    This specification demonstrates how to write unit tests\n    for the example view models in the test suite."},"sprouts.Maybe_Spec":{"executedFeatures":["The `or(Supplier)` method allows you to provide a fallback monad if the maybe is empty.","The `orElse(T)` method throws an exception when passing null to it.","Use `ifPresentOrElse(..)` to execute a consumer if the property is not empty, otherwise execute a runnable.","Use `isOneOf(..)` to check if a property item is equal to one of the provided items.","Use `isOneOf(..)` to check if property item is equal to an item in an array of provided `Maybe` instances.","Use `orElseGet(..)` to provide a fallback value if the property is empty.","Use `orElseNullable(T)` to provide a fallback value if the property is empty."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":18},"title":"Maybe","narrative":"`Maybe` is a monadic type interface which can\n    be created by one of the many factory methods on its interface.\n    The returned `Maybe`s are immutable and\n    cannot be changed once they are created.\n    Their equality is based on the value they hold,\n    not the identity of the maybe itself.\n    \n    The `Maybe` interface is also a general super\n    type for Sprouts properties as well as the `Result` monad.\n    Its API ensures that you can safely work with\n    nullable values in a functional way."},"sprouts.Memory_Unsafe_Property_Binding_Spec":{"executedFeatures":["Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":21},"title":"","narrative":""},"sprouts.Observable_Properties_and_Events_Spec":{"executedFeatures":["Calling `fireChange(From.VIEW_MODEL)` method will also lead to `Observer` instances being notified.","Mutating a property using `set(From.VIEW,..)` will not trigger `onChange(From.VIEW_MODEL,..)` observer to be called.","Property list objects (`Vals` and `Vars`) can also be treated as `Observable`.","You can treat a property as an observable, and register `Observer` on it."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":4,"totalFeatures":4,"passed":4,"successRate":1.0,"time":26},"title":"Observable Events and Properties","narrative":"The `sprouts.Observable` interface defines something that may be observed\n    through the registration of `Observer` implementations \n    which will be invoked by the `Observable` in case specific situations.\n    \n    It is the super type of various sprout types, like for example the generic `Event`,\n    defining something that can be triggered so that the `Observer`s may be informed,\n    or the `Val` and `Var` properties, as well as the `Vals` and `Vars`\n    property list types, which also allow for the observation of state changes.\n    \n    You can listen to all of these types\n    through the common `Observable` interface, hiding the implementation details\n    of what the exact source of the change was."},"sprouts.Problem_Spec":{"executedFeatures":["A Problem can be created from an exception.","A Problem may have a reporter.","We can create a problem from a title."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":3,"totalFeatures":3,"passed":3,"successRate":1.0,"time":12},"title":"Nothing but Problems","narrative":"`Problem` instances are part of `Result` instances \n    which are used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    \n    `Problem` instances tell us what went wrong and why\n    in various situations where we need to know.\n    They are immutable and thread safe and\n    are intended to be used in functional designs.\n    \n    You might wonder, \"Why are exceptions not enough?\".\n    Exceptions are great for us developers, because they halt\n    the current execution and give us a stack trace we can debug,\n    but they do not always fail as gracefully as a user might expect.\n    In a complex system where lots of things can go wrong\n    you want to catch your exceptions and then collect \n    them in a list of problems like so: \n    \n    `thingsThatWentWrong.add(Problem.of(myException));`\n    \n    This way you can continue to execute your program\n    and collect all the problems that occurred so that\n    they can either be logged or presented to the user."},"sprouts.Property_Binding_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Properties can be bound by subscribing to them using the `onChange(..)` method.","Subscribing to the `From.ALL` channel will notify you of all changes.","The `withID(..)` method produces a new property with all bindings inherited.","Use `set(From.VIEW, T)` on our properties to change the property state from the frontend."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":7,"totalFeatures":7,"passed":7,"successRate":1.0,"time":132},"title":"Property Binding","narrative":"The core motivation behind the creation of the Sprouts library\n    is to provide a simple and powerful way to model the state \n    as well as business logic of your UI without actually depending on it.\n    \n    To make the decoupling between your UI and the UIs state and logic \n    possible you need to bind Sprouts properties to UI components.\n    This is done through the use of change listeners and event listeners\n    and so called `Channel`s, which are used to distinguish between\n    different types of events."},"sprouts.Property_Event_Delegates_Spec":{"executedFeatures":["The delegate of a property change action exposes a property that is an immutable clone.","The delegate of a property exposes you to the current and previous value of the property.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action exposes a list that is an immutable clone.","The delegate of a property list change action has a descriptive string representation.","The delegate of a property tells you how the property has changed.","The delegate of a property user action exposes a property that is an immutable clone.","The delegate of a property view exposes you to the current and previous value of the property.","The delegate of a property view tells you how the property has changed."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":27},"title":"Property Event Delegates","narrative":"The properties and property lists in Sprouts allow you to listen for changes\n    by registering action listener instances to the property or property list.\n    These listener types receive so called delegate instances which are used\n    to access the property or property list that was changed in the action\n    in an immutable way."},"sprouts.Property_Lenses_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A chain of lenses may be garbage collected, even when the source property stays in memory.","A chain of lenses may not be garbage collected.","A lens created from the `zoomTo` method throws an exception when receiving null values.","A lens on a nested null value models null without throwing an exception.","A lens on a property an effect on a view on this same property, even if it is de-referenced.","A lens stays in memory when there is a view on it.","A lens with a default value handles updates gracefully when switching from null parent to non-null parent.","A lens with a default value throws an exception when the null object is null.","A property knows if it is mutable or not or nullable or not.","A property lens knows that it is a property lens.","A property lens with a default value focuses on specific field with a non-null parent value.","A property lens with a default value updates the parent value correctly when setting it through the lens.","A property lens with a default value uses its default value when the parent property value is null initially.","Events processed by an `Observer` registered through the `subscribe` method will be invoked on all channels.","Many lens properties can be created from a regular property and instances of the `Lens` interface.","Many lens properties can be created from a regular property.","The channel of a property change event will propagate to its lenses.","The lenses of a property are garbage collected when no longer referenced strongly.","We can create nullable lenses from nullable property even if there is no initial value.","You can access the item of a lens, even if an exception occurs in its getter.","You can create lens properties from other lens properties to dive deeper into nested data structures.","You can create nullable lens properties from a regular property.","You can recognize a property lens from its String representation.","You can subscribe and unsubscribe observer lambdas on property lenses.()","You can try to change the item of a lens, even if an exception occurs in its wither.","You cannot create a lens from the `zoomTo` method if the target value is null."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":28,"totalFeatures":28,"passed":28,"successRate":1.0,"time":2153},"title":"Property Lenses","narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n    \n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n    \n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n    \n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n    \n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n    \n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n    \n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n        \n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n        \n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n        \n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n        \n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n        \n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n        \n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n        \n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n        \n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n        \n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n        \n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n        \n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n        \n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n        \n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n        \n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n        \n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        \n        static record TrainStation(String name, String description, LocalDate foundingDate, List<String> trains) {\n            public TrainStation withName(String name) {\n                return new TrainStation(name, this.description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withDescription(String description) {\n                return new TrainStation(this.name, description, this.foundingDate, this.trains);\n            }\n    \n            public TrainStation withBirthDate(LocalDate birthDate) {\n                return new TrainStation(this.name, this.description, birthDate, this.trains);\n            }\n    \n            public TrainStation withBooks(List<String> books) {\n                return new TrainStation(this.name, this.description, this.foundingDate, books);\n            }\n        }\n        ```"},"sprouts.Property_List_Spec":{"executedFeatures":["A list of properties can be turned into an immutable \"Vals\" list using the \"toVals\" method.","A list of properties can be turned into lists, sets or maps using various convenience methods.","A non-null property list can accept a nullable list through \"addAll(Vals)\" as long as there are no nulls in the list.","A non-nullable property list does not accept nullable properties.","A nullable property list does not accept non-nullable properties.","Both the \"Vars\" and immutable \"Vals\" types can be used for functional programming.","Calling `.removeOrThrow(Var.of(..))` will always throw an exception.","Change listeners registered on a property list will be called when the list is sorted.","Checkout these cool one liners!","Create a copy of the current state of the \"Vars\" list.","How not to use a property list.","Immutable property lists are considered equal if their values are equal.","Items can be popped off a property list using a predicate.","Items can be removed from a property list using a predicate.","Just like a regular \"Var\" property you can register change listeners on \"Vars\".","Leading and trailing items can be popped off a property list.","Lists of properties can be sorted based on their natural order through the `sort` method.","Lists of properties can be sorted using a custom comparator through the `sort` method.","Map a \"Vals\" instance from one type of properties to another.","Map a \"Vars\" instance from one type of properties to another.","Multiple properties can be modelled through the \"Vars\" and \"Vals\" classes.","Properties can be popped off a property list using a predicate.","Properties can be removed from a property list using a predicate.","Properties created by adding values to a property list can be set to `null` if the list allows null properties.","Properties created by adding values to a property list cannot be set to `null` if the list does not allow null properties.","The \"Vals\" and \"Vars\" instances have descriptive String representations.","The \"Vars\" is a list of properties which can grow and shrink.","The \"makeDistinct\" method on a mutable list of properties modifies the list in-place.","The \"popAt\" method return the removed property.","The \"retainAll\" method does not trigger an \"onChange\" event if the list is not changed.","The `indexOf` method returns the index of the first occurrence of the given property.","The `is(Vals)` method checks if the items of the current property list are equal to the other property list.","The `remove(..)` methods remove all matching occurrences of a property from the list.","The `removeOrThrow(Val)` method removes the given property from the list or throws an exception if the property is not in the list.","The change delegate contains information about changes made to a \"Vars\" list by adding a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by adding properties.","The change delegate contains information about changes made to a \"Vars\" list by clearing the list.","The change delegate contains information about changes made to a \"Vars\" list by removing a list of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a sequence of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a \"Vars\" list by removing properties.","The change delegate contains information about changes made to a `Vars` list by setting a range properties.","The change delegate contains information about changes made to a `Vars` list by setting a sequence properties.","The change delegate contains information about changes made to a nullable \"Vars\" list by removing a set of properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a range properties.","The change delegate contains information about changes made to a nullable `Vars` list by setting a sequence properties.","The display action of a property or list of properties will not be afterit was removed","The listeners registered in property lists will be informed what type of modification occurred.","The properties of one property list can be added to another property list.","The various `setAllAt(int,..)` methods can throw index out of bounds exceptions.","Use \"anyEmpty\" to check if any of the properties are empty.","Use \"none\" to check if none of the properties match the given predicate.","Use \"removeOrThrow\" to to guarantee the removal of a property.","Use `addAll(Vals)` to add the items as a new properties and use `addAll(Vars)` to add them unchanged.","Use `addAllAt(int, Vals)` to add the items as a new properties and use `addAllAt(int, Vars)` to add them unchanged.","Use `addAt(int,Val)` to set the item as a new property and use `addAt(int,Var)` to set the supplied property.","Use `all(Predicate)` to check if all properties in the list satisfy a given predicate.","Use `indicesOf(T)` to get the indices of all occurrences of a property in a list.","Use `setAllAt(int, Vals)` to set items as new properties and use `setAllAt(int, Vars)` to set them unchanged.","Use `setAt(int,Val)` to set the item as a new property and use `setAt(int,Var)` to set the supplied property.","Using \"addAll\" to add multiple things to a property list will only trigger the change listeners once!","Using `addAt(int,Val)`, you can add a nullable property to a non-nullable list if the item is present.","Using `setAt(int,Val)`, you can place the item of a nullable property into a non-nullable list if the item is present.","Various kinds of methods that mutate a property list will only trigger an \"onChange\" event once, even if multiple items are affected.","You can add a `Stream` of items all at once at a particular index in a property list.","You can add a `Stream` of items all at once to a property list.","You can add properties to a nullable \"Vars\" list that from an immutable property list.","You can create a \"Vars\" list from a regular List of properties.","You can create a mapped version of a property list.","You can create a nullable immutable property list from nullable properties only.","You can create the \"Vars\"/\"Vals\" property lists from property instances.","You can easily add properties to a nullable \"Vars\" list that contains null properties.","You can easily create an empty \"Vals\" list.","You can easily remove `null` properties from a nullable \"Vars\" list.","You can easily remove properties from a nullable \"Vars\" list that contains null properties.","You can pop a range of entries from a property list.","You can pop a sequence of `n` entries from a property list.","You can remove a range of entries from a property list.","You can remove a sequence of `n` entries from a property list.","You can remove n leading or trailing entries from a property list.","You can set a range of properties to a given value or property with the `setRange` method.","You can set a sequence of properties to a given value or property with the `setAt` method.","You cannot construct a non-nullable property list from nullable properties.","You cannot construct a nullable property list from non-nullable properties."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":108,"totalFeatures":84,"passed":108,"successRate":1.0,"time":499},"title":"Lists of Properties","narrative":"Just like properties you can create lists of properties\n    and then bind them to UI components.\n    They are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic.\n    This specification shows how to use the various\n    methods exposed by the property lists classes, \n    namely \"Vals\" (immutable) and \"Vars\" (mutable)."},"sprouts.Property_List_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views does not remain in memory, when the last view is not referenced.","A chain of views remains in memory, as long as the last view is still referenced.","A property list may be garbage collected, even if there are still views on it.","A property list view is garbage collected when no longer referenced","The views of individual properties of a property list view can be garbage collected."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":323},"title":"Property List View Memory Safety","narrative":"`Vals` (read-only) and `Vars` (mutable) are designed to be used in MVVM or MVI architectures.\n    This is why they need to be observable, which is achieved by registering change listeners on their \"views\".\n    These views are weakly referenced and automatically updated when the original property changes.\n    You can subscribe to these views to get notified of changes.\n\n    This is useful for observing a property list of one type as another type or with transformations applied.\n\n    This specification demonstrates creating views from nullable and non-nullable property lists,\n    and shows how they may be garbage collected when no longer referenced."},"sprouts.Property_List_View_Spec":{"executedFeatures":["A property list view created using `view()` will receive change events from its source.","A property list view created using `view(U,U,Function<T,U>)` will receive change events from its source.","A property list view has a `toString()` method that returns a insightful string representation of the view.","Calling `revert()` on a property list will also revert its views.","The `view(U,U,Function<T,U>)` method creates a dynamically updated live view of its source list.","The `viewSize()` method returns a property that is equal to the size of the original property.","The properties of a list view can themselves be observed for changes in the source properties.","We can \"view the emptiness\" of a property list.","We can \"view the presence of items\" of a property list."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":9,"totalFeatures":9,"passed":9,"successRate":1.0,"time":33},"title":"Property List Views","narrative":"A property list is more than just a wrapper around values.\n    This interface has a rich API that exposes a plethora of methods,\n    many of which are designed to inform you about\n    their contents without actually exposing them to you.\n\n    For these facts about any property list, we can create views.\n    These views are observable live properties that are updated\n    whenever the source property list changes."},"sprouts.Property_Safety_Spec":{"executedFeatures":["\"Vals\", a list of properties, is immutable.","A \"Val\" instance is immutable.","A \"Var\" may only wrap null if it is created as nullable.","A property can only wrap null if we specify a type class.","An empty property can throw a cached exception if you try to access its value.","An empty property can throw an un-exception if you try to access its value.","The \"get\" method of a property throws an exception if the property is null.","The \"orElseNull\" method should be used instead of \"orElseThrow\" if you are fine with null items.","The \"orElseNull\" method should be used instead of \"orElseThrowUnchecked\" if you are fine with null items."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":14,"totalFeatures":9,"passed":14,"successRate":1.0,"time":17},"title":"Property Null and Mutability Safety","narrative":"Properties are a core concept in Sprouts. They are in essence\n    just wrapper classes used to represent the state of your views.\n    Because of this, it is important that properties are\n    are nullable only when they need to be, and that they are\n    mutable only when they need to be."},"sprouts.Property_Spec":{"executedFeatures":["A property can be converted to an `Optional`.","A property constructed using the `of` factory method, does not allow null items.","A property will find the correct type of an item, even if it is an anonymous class based enum constant.","Conveniently compare properties with other properties using \"is\", \"isOneOf\" or \"isNot\"","Conveniently compare the item of a property with another item using \"is\", \"isOneOf\" or \"isNot\"","Exceptions inside the function of the `update(Function)` method reach the caller.","Exceptions inside the function of the `updateNullable(Function)` method reach the caller.","Properties are similar to the `Optional` class, you can map them and see if they are empty or not.","Properties are simple wrappers around an item","Properties not only have an item but also a type and id!","The `get()` method will throw an exception if there is no element present.","The `ifPresent` method allows us to see if a property has an item or not.","The equality and hash code of a mutable property is based on its identity!","The equality and hash code of an immutable property are based on its value, type and id!","The string representation of a property will give you all the information you need.","There are 2 types of properties, an immutable property, and its mutable sub-type.","Use `typeAsString()` to get the type of a property as a string.","Use `withId(String id)` to create a new property with a new String based id.","You can map null items of a property through the `updateNullable(Function)` method.","You can see if a property is a `Var` or `Val` by looking at their String representations.","You can update a nullable property item based on the current item through the `updateNullable(Function)` method.","You can update a property item based on the current item through the `update(Function)` method.","You cannot map `null` items of a property through the `update(Function)` method.","You may not pass a `null` reference to the `update(Function)` method.","You may not pass a null function to the `updateNullable(Function)` method."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":25,"totalFeatures":25,"passed":25,"successRate":1.0,"time":62},"title":"Properties","narrative":"Properties are a powerful tool to model the state \n    as well as business logic of your UI without actually depending on it.\n    This is especially useful for testing your UIs logic (in a view model for example).\n    This is the core motivation behind the creation of the Sprouts library.\n    \n    In Sprouts, properties are represented by the `Var` and `Val` classes.\n    \n    You might be wondering, what is a `Var` or `Val` and what does \n    it have to do with the common concept of a property?\n    \n    The answer is quite simply that the sprouts API uses the \n    names `Var` and `Val` to refer to 2 common types of properties.\n    The name `Var` translates to \"variable\" and `Val` to \"value\"\n    which are also words that convey the meaning of a property\n    yet they allow us to distinguish between mutable and immutable properties\n    without having to resort to unnecessary prefixes like \"mutable\" or \"immutable\".\n    \n    So when the sprouts documentation refers to properties, it is\n    referring to the `Var` and `Val` classes.\n\n    This specification introduces you to their API and shows you how to use them."},"sprouts.Property_View_Memory_Safety_Spec":{"executedFeatures":["A chain of views may not be garbage collected.","A composite view of 2 properties will not break if the first observed property is garbage collected.","A composite view of 2 properties will not break if the second observed property is garbage collected.","Even if property views have change listeners, they will be garbage collected if you do not reference them.","Properties can be garbage collected, even if they are observed by a composite view.","Properties can be garbage collected, even if they are observed by a nullable composite view.","The change listener of property view parents are garbage collected when the view is no longer referenced strongly.","You can subscribe and unsubscribe action lambdas on property views.()","You can subscribe and unsubscribe observer lambdas on property views.()"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":68,"totalFeatures":9,"passed":68,"successRate":1.0,"time":5504},"title":"Property View Memory Safety","narrative":"Both the read only `Val` and the mutable `Var` are designed to be\n    used as part of a view model in a Model-View-ViewModel (MVVM) architecture\n    or Model-View-Intent (MVI) architecture.\n    As a consequence, they need to be observable in some way.\n    This is done by registering change listeners on \n    the \"views\" of properties, which are weakly referenced\n    live views of the original property which gets updated\n    automatically when the original property changes.\n    You can then subscribe to these views to get notified\n    of changes to the original property.\n    \n    This is especially useful when you want to observe a property\n    of one type as a property of another type, or when you want to\n    observe a property with some transformation applied to it.\n    \n    This specification shows how to create views from both nullable and non-nullable properties,\n    and it demonstrates how they may be garbage collected when they are no longer referenced."},"sprouts.Property_View_Spec":{"executedFeatures":["A `WeakAction` is removed and garbage collected together with its owner.","A `WeakObserver` is removed and garbage collected together with its owner.","A `viewIsEmpty()` property from a non nullable property is always false.","A `viewIsPresent()` property from a non nullable property is always true.","A composite view has an id that is the concatenation of the ids of its source properties.","A primitive or string type view will map nulls to the types null object.","A view can handle viewing different sub-types of the given source type.","A view can use specific items to indicate mapping to `null` or exceptions during mapping.","A view is updated only once for every change, or not updated at all if no change occurred.","Changing the value of a property through the `.set(From.VIEW, T)` method will also affect its views","Map null to custom values when viewing them as primitive types.","The `onChange` event delegate tells you the type of change the property experienced.","The `viewAsDouble()` method can be used to create a null safe view of a property of any type as a double.","The `viewAsInt()` method can be used to create a null safe view of a property of any type as an int.","The `viewAsString()` method can be used to create a null safe view of a property of any type as a String.","The `viewIsEmpty()` method returns a property that is true when the original property is empty, and false otherwise.","The `viewIsPresent()` method returns a property that is true when the original property is not empty, and false otherwise.","The channel of a property change event will propagate to its views.","There are various kinds of convenience methods for creating live views of properties.","This is how not to use views.","Use `viewAsDouble(double,Function)` to view a nullable property as a non null double.","Use `viewAsInt(int,Function)` to view a nullable property as a non null integer.","Use `viewAsTuple` to create a view of a property as a tuple.","Use the `view(Function)` method to create a view of a property of the same type.","Use the `viewAsString(String,Function)` method to view a nullable property as a non null String.","Use the `viewAs` method to create a dynamically updated view of a property.","You can recognize a property view from its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":27,"totalFeatures":27,"passed":27,"successRate":1.0,"time":210},"title":"Property Views","narrative":"Properties are designed to be observable, which means that you can \"react\"\n    to their items being replaced by new items. This sort of \"reaction\"\n    to changes is typically done through the \"observer pattern\", where you\n    register change listeners on a property that are invoked whenever the\n    property item changes...\n    \n    Contrary to what you might might expect, you cannot register change listeners\n    on properties directly!\n    This is to prevent you from creating memory leaks, which happen very often \n    due to change listeners not being unregistered when they are no longer needed.\n    To fix this, Sprouts provides the concept of a \"property view\" in\n    the form of instances of the `Viewable` type, \n    which is a weakly referenced live property onto which you can safely register \n    your change listeners. \n    And when you no longer use the view (by holding a reference to it), \n    it will be garbage collected along with all of the change listeners \n    that were registered on it.\n    \n    But if you keep a reference to the view and a change occurs on the source property,\n    then the view will be updated and all of the change listeners will be notified\n    of the change."},"sprouts.Result_Spec":{"executedFeatures":["A `Result` is not mutable.","A result can be created from multiple problems.","A result will find the correct type of an item, even if it is an anonymous class based enum constant.","An empty `Result` can be mapped to any property type without an exception being thrown.","An exception occurring when peeking at each problem of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with even more problems.","An exception occurring when peeking at the problems of a \u00b4Result\u00b4 will produce a \u00b4Result\u00b4 with yet another problem.","Create a Result from a list with some problems.","Create a result from a supplier which may or may not throw an exception using the `ofTry` method.","Exceptions inside of a mapping function are caught and turned into problems.","If mapping to another type goes wrong, the exception is caught and turned into a problem.","Just like many other Sprouts types, a `Result` has a type.","Results can be turned into an Optional.","The equality of two `Result` instances is based on the type and the item of the result.","The items of a `Result` can be mapped using mapping functions.","We can create a result from any kind of value.","You can create a `Result` from a list.","You can peek into a `Result` to look at all of its \u00b4Problem\u00b4s.","You can peek into a `Result` to look at each \u00b4Problem\u00b4 individually.","You can recognize a `Result` by its String representation."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":19,"totalFeatures":19,"passed":19,"successRate":1.0,"time":39},"title":"Results","narrative":"The `Result` interface is used to represent the optional result of an operation\n    as well as a list of problems that occurred during the operation.\n    The problems of a `Result` are represented by the `Problem` interface,\n    which may be created from an exception or a simple message.\n    \n    A `Result` is a fully thread safe immutable value type with useful mapping\n    functions that allow you to transform the value of the result into another\n    effectively making it a monadic value similar to the `Optional` type in Java 8."},"sprouts.Sequence_Invariance_Spec":{"executedFeatures":["A property list and its changes are always invariant to its list view.","Various operations between `Tuple` and `Vars` are invariant."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":69,"totalFeatures":2,"passed":69,"successRate":1.0,"time":126},"title":"Sequence Invariance","narrative":"This specification tests the functional invariance between\n    operations on the mutable `Vars` type and the immutable `Tuple` type."},"sprouts.Tuple_Spec":{"executedFeatures":["A `Tuple` can be converted to a `ValueSet`.","A non-nullable tuple will not throw an exception if you do not try to add nulls to it.","A non-nullable tuple will throw an exception if you try to add a null element.","A nullable tuple is never equal to a non-nullable tuple.","A tuple has various operations for functional transformation.","Any kind of tuple can be sorted.","Collecting a stream of items with nulls into a non-nullable tuple throws an exception.","Internally, a tuple has a sort of signature to determine the line of succession.","It is possible to create and use a tuple of nullable ints.","The `Tuple` class support all kinds of nullable types.","The `Tuple` maintains invariance with Java ArrayList across operations","The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.","The `indicesOf` method returns all indices of an element in the tuple.","The `makeDistinct()` method is like turning a tuple into a linked hash set.","The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.","The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.","The `remove(T)` method removes every occurrence of the element from the tuple.","The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.","The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.","The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.","The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.","The `retainAll(Iterable<T>)` method retains only the elements from the tuple.","The `retainAll(T...)` method retains only the given elements in the tuple.","The `retainAll(Tuple<T>)` method retains only the elements from the tuple.","The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.","The `setAllAt( int index, T... items )` method will set the items at the given index.","The tuple predicates behave as expected.","Tuple implementations know about their last operation.","Two non-nullable tuples of the same type are equal, if their contents are equal.","Two nullable tuples of the same type are equal, if their contents are equal.","Two tuples are equal, even if they were produced by different operations.","Updating a non-nullable tuple with an empty `Maybe` is a no-op.","Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.","Use `firstIndexStartingFrom` to only look for an element after a certain index.","Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.","Use `lastIndexBefore` to only look for an element before a certain index.","Use `setAt( int index, int size, T item )` to spread a single item across a range.","Use the `removeFirstFound(T)` method to remove the first occurrence of an element.","Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.","When mapping a tuple with `null` values, the result will be a nullable tuple.","You can collect a Java stream of items to a Sprouts tuple natively!","You can collect a stream of items into a tuple with a custom collector.","You can tell two tuples with different nullability apart from their String representations.","You can updating a non-nullable tuple with a non-empty `Maybe`."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":260,"totalFeatures":44,"passed":260,"successRate":1.0,"time":979},"title":"Tuples for Functional Programming","narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way."},"sprouts.ValueSet_Spec":{"executedFeatures":["An empty ValueSet is created by specifying the element type","Bulk operations handle large datasets efficiently","Duplicate additions have no effect","Edge cases are handled gracefully","Empty set special cases","Equality and hash code follow set semantics","Immutable characteristics are preserved","Iterator behavior conforms to set semantics","Set operations maintain mathematical set properties","Set operations with Java collections","Stream integration works properly","String representation reflects contents","The `ValueSet` maintains invariance with Java Set across operations","The `clear` operation works on a non-empty value set","Use `ValueSet.classTyped(Class)` to created a typed class pointer to `ValueSet`.","addAll supports various collection types","bulk operations ignore duplicate elements in input","collector works with different stream sources","containsAll accurately checks membership across collection types","interoperates with Tuple collections","no-op operations return the same instance","operations with empty collections have no effect or clear as expected","removeAll handles different input collection types","retainAll works with diverse collection sources"],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":26,"totalFeatures":24,"passed":26,"successRate":1.0,"time":138},"title":"Value Sets","narrative":"ValueSet is a fundamental building block in sprouts' data-oriented programming model.\n    It represents an immutable collection of unique elements, providing an API focused on\n    deriving new sets from existing ones rather than mutating state. Unlike traditional\n    Java sets, all operations return new `ValueSet` instances, making it ideal for\n    functional-style programming and safe concurrent usage."},"sprouts.Version_Spec":{"executedFeatures":["A lineage of successions can be ordered.","Two newly created versions have different lineage numbers but the same succession.","Two versions created from the same lineage have different succession numbers.","Use `isDirectPredecessorOf` to check if a version is the direct predecessor of another.","Use `isDirectSuccessorOf` to check if a version is the direct successor of another."],"ignoredFeatures":[],"stats":{"failures":0,"errors":0,"skipped":0,"totalRuns":5,"totalFeatures":5,"passed":5,"successRate":1.0,"time":8},"title":"Value based Identity","narrative":"When doing functional or data oriented programming then you are\n    working with value objects. These are objects that are immutable\n    and define their identity in terms of their values.\n    Which means that two objects are considered equal if they have\n    the same values, even if they are different instances.\n    \n    To model identity in value objects Sprouts provides the `Version` class.\n    It is a value object representing a unique ID. This ID consisting\n    of two numbers, a lineage and succession number allowing you to identify something\n    and also determine the order in which something was created\n    and updated.\n    This is intended to be used to emulate identity in\n    your value objects, which is useful for tracking changes\n    and synchronizing state across different parts of your application.\n    You may also use version changes to do reactive programming\n    for your value based view models, similar as you would do with\n    `Event`s in traditional place oriented view models."}}