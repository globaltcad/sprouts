{
  "className":"sprouts.Noticeable_Spec",
  "title":"Events",
  "narrative":"The `Noticeable` interface is a thing that can be listened to\n    Not only is it the super type of `Event`, it is also the super type of \n    sprouts `Val` and `Var` property wrappers as well as the `Vals` and `Vars`\n    property list types.\n\n    This means that you can listen to all of these types for changes\n    through the `Noticeable` interface, hiding the implementation details\n    of what the exact source of the change was.",
  "subjects":["sprouts.Val","sprouts.Var","sprouts.Vals","sprouts.Vars","sprouts.Listener","sprouts.Noticeable"],
  "statistics":{
    "runs":"4",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"You can treat a property as a noticeable, and register `Listeners`s on it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Note that the `Listener` will only be notified that something happen,\n            it will not be told what happened.\n            So no state is passed to the listener.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple String property.","code":["var property = Var.of(\"Hello\")"]},

        {"kind":"and","text":"We also view the property as a noticeable.","code":["Noticeable noticeable = property"]},

        {"kind":"and","text":"Finally we make sure that we can track changes to the property.","code":["var listener = Mock(Listener)","noticeable.subscribe(listener)"]},

        {"kind":"when","text":"We change the property.","code":["property.set(\"World\")"]},

        {"kind":"then","text":"The listener is notified.","code":["1 * listener.notice()"]},

        {"kind":"when","text":"We unsubscribe the mocked listener from the property...","code":["noticeable.unsubscribe(listener)"]},

        {"kind":"and","text":"...and change the property again.","code":["property.set(\"!\")"]},

        {"kind":"then","text":"The listener is not notified.","code":["0 * listener.notice()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `fireSet` method will also lead to registered `Listener` instances to be notified.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Using the `fireSet` you not only trigger the regular change listeners,\n            but also the `Listener` instances registered through the `Noticeable` API.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple String property.","code":["var property = Var.of(\"Hello\")"]},

        {"kind":"and","text":"We also view the property as a noticeable.","code":["Noticeable noticeable = property"]},

        {"kind":"and","text":"Finally we make sure that we can track changes to the property.","code":["var listener = Mock(Listener)","noticeable.subscribe(listener)"]},

        {"kind":"when","text":"We change the property.","code":["property.fireSet()"]},

        {"kind":"then","text":"The listener is notified.","code":["1 * listener.notice()"]},

        {"kind":"when","text":"We unsubscribe the mocked listener from the property...","code":["noticeable.unsubscribe(listener)"]},

        {"kind":"and","text":"...and change the property again.","code":["property.fireSet()"]},

        {"kind":"then","text":"The listener is not notified.","code":["0 * listener.notice()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Changing a property through the `act` method will not trigger `Listener` instances to be called.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `act` method of a property is in essence a simple setter, just like the `set` method,\n            with the only distinction that it triggers the `onAct(..)` registered action listeners, \n            instead of the regular change listeners registered through `onSet(..)`.\n            This distinction exists to allow for a clear separation between events dispatched\n            from the UI and events dispatched from the model. \n            `Listener` implementations are considered to be part of the model,\n            and as such should not be triggered by UI events.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple String property.","code":["var property = Var.of(\"Hello\")"]},

        {"kind":"and","text":"We also view the property as a noticeable.","code":["Noticeable noticeable = property"]},

        {"kind":"and","text":"Finally we make sure that we can track changes to the property.","code":["var listener = Mock(Listener)","noticeable.subscribe(listener)"]},

        {"kind":"when","text":"We change the property.","code":["property.act(\"World\")"]},

        {"kind":"then","text":"The listener is not notified.","code":["0 * listener.notice()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Property list objects (`Vals` and `Vars`) can also be treated as `Noticeable`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Vals` and `Vars` property list types are also `Noticeable` types.\n            This means that you can listen to changes in the list through the `Noticeable` interface.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a simple String property list.","code":["var list = Vars.of(\"Hello\", \"World\")"]},

        {"kind":"and","text":"We also view the list as a noticeable.","code":["Noticeable noticeable = list"]},

        {"kind":"and","text":"Finally we make sure that we can track changes to the list.","code":["var listener = Mock(Listener)","noticeable.subscribe(listener)"]},

        {"kind":"when","text":"We change the list.","code":["list.add(\"!\")"]},

        {"kind":"then","text":"The listener is notified.","code":["1 * listener.notice()"]},

        {"kind":"when","text":"We unsubscribe the mocked listener from the list...","code":["noticeable.unsubscribe(listener)"]},

        {"kind":"and","text":"...and change the list again.","code":["list.add(\"!!\")"]},

        {"kind":"then","text":"The listener is not notified.","code":["0 * listener.notice()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
