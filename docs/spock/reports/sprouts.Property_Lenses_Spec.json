{
  "className":"sprouts.Property_Lenses_Spec",
  "title":"Property Lenses",
  "narrative":"The Sprouts Property Lens is based on the Lens design pattern.\n    The Lens design pattern is a functional programming \n    technique used to simplify the process of accessing and updating parts of \n    a nested (immutable) data structures into a new instance of the data structure.\n\n    A Lens is essentially a pair of functions: \n    one to get a value from a specific part of a data structure (like a record), \n    and another to set or update that value while producing a new \n    instance of the data structure. This pattern is particularly useful with Java records, \n    which are immutable by design, as it allows for clean and concise manipulation \n    of deeply nested fields without breaking immutability.\n\n    Now what does this have to do with Sprouts properties?\n    After all, the MVVM properties of this library are mutable \n    wrapper types with regular getter and setter methods.\n    Although properties are mutable, their items are expected to\n    be immutable data carriers, such as ints, doubles, strings or records.\n    In case of records (or other custom value oriented data types),\n    there is really no limit to how deeply nested the data structure can be.\n    You may even want to model your entire application state as a single record\n    composed of other records, lists, maps and primitives.\n    This is where the Property Lens comes in:\n\n    You can create a lens property from any regular property\n    holding an immutable data structure, and then use the lens property\n    like a regular property.\n\n    Under the hood the lens property will use the lens pattern to access\n    and update the nested data structure of the original property.\n\n    In this specification we will demonstrate how to create and use\n    lens properties and also explore edge cases and limitations.\n\n    In this Specification we are using the following \n    data structure classes:\n    ````java\n        import java.time.LocalDate;\n        import java.util.List;\n\n        // Enums\n        enum Genre {\n            FICTION, NON_FICTION, SCIENCE, FANTASY, BIOGRAPHY, HISTORY\n        }\n\n        enum MembershipLevel {\n            BASIC, SILVER, GOLD, PLATINUM\n        }\n\n        // Records\n        public record Author(String firstName, String lastName, LocalDate birthDate, List<String> books) {\n            public Author withFirstName(String firstName) {\n                return new Author(firstName, this.lastName, this.birthDate, this.books);\n            }\n\n            public Author withLastName(String lastName) {\n                return new Author(this.firstName, lastName, this.birthDate, this.books);\n            }\n\n            public Author withBirthDate(LocalDate birthDate) {\n                return new Author(this.firstName, this.lastName, birthDate, this.books);\n            }\n\n            public Author withBooks(List<String> books) {\n                return new Author(this.firstName, this.lastName, this.birthDate, books);\n            }\n        }\n\n        public record Book(String title, Author author, Genre genre, LocalDate publicationDate, int pageCount) {\n            public Book withTitle(String title) {\n                return new Book(title, this.author, this.genre, this.publicationDate, this.pageCount);\n            }\n\n            public Book withAuthor(Author author) {\n                return new Book(this.title, author, this.genre, this.publicationDate, this.pageCount);\n            }\n\n            public Book withGenre(Genre genre) {\n                return new Book(this.title, this.author, genre, this.publicationDate, this.pageCount);\n            }\n\n            public Book withPublicationDate(LocalDate publicationDate) {\n                return new Book(this.title, this.author, this.genre, publicationDate, this.pageCount);\n            }\n\n            public Book withPageCount(int pageCount) {\n                return new Book(this.title, this.author, this.genre, this.publicationDate, pageCount);\n            }\n        }\n\n        public record Member(String memberId, String firstName, String lastName, MembershipLevel membershipLevel, LocalDate joinDate, String email) {\n            public Member withMemberId(String memberId) {\n                return new Member(memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n\n            public Member withFirstName(String firstName) {\n                return new Member(this.memberId, firstName, this.lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n\n            public Member withLastName(String lastName) {\n                return new Member(this.memberId, this.firstName, lastName, this.membershipLevel, this.joinDate, this.email);\n            }\n\n            public Member withMembershipLevel(MembershipLevel membershipLevel) {\n                return new Member(this.memberId, this.firstName, this.lastName, membershipLevel, this.joinDate, this.email);\n            }\n\n            public Member withJoinDate(LocalDate joinDate) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, joinDate, this.email);\n            }\n\n            public Member withEmail(String email) {\n                return new Member(this.memberId, this.firstName, this.lastName, this.membershipLevel, this.joinDate, email);\n            }\n        }\n\n        public record Loan(String loanId, Book book, Member member, LocalDate loanDate, LocalDate returnDate, boolean returned) {\n            public Loan withLoanId(String loanId) {\n                return new Loan(loanId, this.book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n\n            public Loan withBook(Book book) {\n                return new Loan(this.loanId, book, this.member, this.loanDate, this.returnDate, this.returned);\n            }\n\n            public Loan withMember(Member member) {\n                return new Loan(this.loanId, this.book, member, this.loanDate, this.returnDate, this.returned);\n            }\n\n            public Loan withLoanDate(LocalDate loanDate) {\n                return new Loan(this.loanId, this.book, this.member, loanDate, this.returnDate, this.returned);\n            }\n\n            public Loan withReturnDate(LocalDate returnDate) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, returnDate, this.returned);\n            }\n\n            public Loan withReturned(boolean returned) {\n                return new Loan(this.loanId, this.book, this.member, this.loanDate, this.returnDate, returned);\n            }\n        }\n        ```",
  "subjects":["sprouts.impl.PropertyLens","sprouts.Var"],
  "statistics":{
    "runs":"21",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Many lens properties can be created from a regular property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Note that a lens only focuses on a single field of the targeted data structure.\n            So if the original property changes its state to a completely new instance of the data structure,\n            then the lens will only receive an update event if the focused field of the new instance is different\n            from the focused field of the old instance.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            For this example we will merely use the Author record\n            to demonstrate how each property of the record can be\n            accessed and updated using a lens property.\n\n            We also assert that the lenses receive updates when the\n            the record property they focus on is updated.\n        ","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"We create lenses for each property of the Author record:","code":["var firstNameLens    = authorProperty.zoomTo(Author::firstName, Author::withFirstName)","var lastNameLens     = authorProperty.zoomTo(Author::lastName,  Author::withLastName)","var birthDateLens = authorProperty.zoomTo(Author::birthDate, Author::withBirthDate)","var booksLens      = authorProperty.zoomTo(Author::books,     Author::withBooks)"]},

        {"kind":"and","text":"We also create lists and listeners for recording all change events:","code":["var firstNameTrace = []","var lastNameTrace = []","var birthDateTrace = []","var booksTrace = []","var authorTrace = []","firstNameLens.onChange(From.ALL,it -> firstNameTrace << it.get() )","lastNameLens.onChange(From.ALL,it -> lastNameTrace << it.get() )","birthDateLens.onChange(From.ALL,it -> birthDateTrace << it.get() )","booksLens.onChange(From.ALL,it -> booksTrace << it.get() )","authorProperty.onChange(From.ALL,it -> authorTrace << it.get() )"]},

        {"kind":"expect","text":"Initial values are correct:","code":["firstNameLens.get() == author.firstName()","lastNameLens.get() == author.lastName()","birthDateLens.get() == author.birthDate()","booksLens.get() == author.books()","authorProperty.get() == author"]},

        {"kind":"when","text":"We create a completely new and completely different Author record:","code":["var newAuthor = new Author(\"Jane\", \"Smith\", LocalDate.of(1997, 9, 3), [\"Book3\", \"Book4\"])","authorProperty.set(newAuthor)"]},

        {"kind":"then","text":"The lenses have updated values:","code":["firstNameLens.get() == newAuthor.firstName()","lastNameLens.get() == newAuthor.lastName()","birthDateLens.get() == newAuthor.birthDate()","booksLens.get() == newAuthor.books()","authorProperty.get() == newAuthor"]},

        {"kind":"and","text":"All change events were recorded:","code":["firstNameTrace == [\"Jane\"]","lastNameTrace == [\"Smith\"]","birthDateTrace == [LocalDate.of(1997, 9, 3)]","booksTrace == [[\"Book3\", \"Book4\"]]","authorTrace == [newAuthor]"]},

        {"kind":"when","text":"We update the Author in a way where effectively nothing changes:","code":["authorProperty.set(newAuthor)"]},

        {"kind":"then","text":"The lenses have the same values as before:","code":["firstNameLens.get() == newAuthor.firstName()","lastNameLens.get() == newAuthor.lastName()","birthDateLens.get() == newAuthor.birthDate()","booksLens.get() == newAuthor.books()","authorProperty.get() == newAuthor"]},

        {"kind":"and","text":"No additional change events were recorded:","code":["firstNameTrace == [\"Jane\"]","lastNameTrace == [\"Smith\"]","birthDateTrace == [LocalDate.of(1997, 9, 3)]","booksTrace == [[\"Book3\", \"Book4\"]]","authorTrace == [newAuthor]"]},

        {"kind":"when","text":"We update the Author in a way where only 2 properties change:","code":["var newAuthor2 = newAuthor.withFirstName(\"Martha\").withBirthDate(LocalDate.of(2002, 5, 17))","authorProperty.set(newAuthor2)"]},

        {"kind":"then","text":"The lenses have updated values:","code":["firstNameLens.get() == newAuthor2.firstName()","lastNameLens.get() == newAuthor2.lastName()","birthDateLens.get() == newAuthor2.birthDate()","booksLens.get() == newAuthor2.books()","authorProperty.get() == newAuthor2"]},

        {"kind":"and","text":"Only the relevant change events were recorded:","code":["firstNameTrace == [\"Jane\", \"Martha\"]","lastNameTrace == [\"Smith\"]","birthDateTrace == [LocalDate.of(1997, 9, 3), LocalDate.of(2002, 5, 17)]","booksTrace == [[\"Book3\", \"Book4\"]]","authorTrace == [newAuthor, newAuthor2]"]},

        {"kind":"when","text":"\n            We modify one of the lenses, then this will automatically\n            update the full value of the original property.\n            The other lenses on the other hand will not receive any updates\n            because the focused field of the original property have not changed:\n        ","code":["firstNameLens.set(\"Raffaela\")"]},

        {"kind":"then","text":"The original property has updated values:","code":["authorProperty.get() == newAuthor2.withFirstName(\"Raffaela\")"]},

        {"kind":"and","text":"Only the relevant change events were recorded:","code":["firstNameTrace == [\"Jane\", \"Martha\", \"Raffaela\"]","lastNameTrace == [\"Smith\"]","birthDateTrace == [LocalDate.of(1997, 9, 3), LocalDate.of(2002, 5, 17)]","booksTrace == [[\"Book3\", \"Book4\"]]","authorTrace == [newAuthor, newAuthor2, newAuthor2.withFirstName(\"Raffaela\")]"]},

        {"kind":"when","text":"We pass a value to a lens which is equal to the current value of the lens:","code":["lastNameLens.set(\"Smith\")"]},

        {"kind":"then","text":"No change events are recorded:","code":["firstNameTrace == [\"Jane\", \"Martha\", \"Raffaela\"]","lastNameTrace == [\"Smith\"]","birthDateTrace == [LocalDate.of(1997, 9, 3), LocalDate.of(2002, 5, 17)]","booksTrace == [[\"Book3\", \"Book4\"]]","authorTrace == [newAuthor, newAuthor2, newAuthor2.withFirstName(\"Raffaela\")]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can create lenses from other lenses to dive deeper into nested data structures.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            As previously mentioned, a property lens effectively behaves like a regular property,\n            which includes the ability to create yet another lens from an existing lens\n            for which the same rules apply.\n\n            This allows you to create a chain of lenses to access deeply nested fields\n            of a data structure.\n\n            In this example we will create a property for the `Loan` record\n            and then create lenses its nested `Book` and `Member` records\n            and then create lenses for the nested `Author` record of the `Book` record.\n            Changing the original property will trigger updates for all lenses in the chain.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first create full data structure composed of many nested records.\n        ","code":["var author = new Author(\"Raffaela\", \"Raab\", LocalDate.of(1996, 3, 21), [\"Book1\", \"Book2\"])","var book   = new Book(\"The Book\", author, Genre.HISTORY, LocalDate.of(2019, 5, 12), 304)","var member = new Member(\"1234\", \"Marc\", \"Mayer\", MembershipLevel.GOLD, LocalDate.of(2015, 2, 3), null)","var loan   = new Loan(\"5678\", book, member, LocalDate.of(2021, 8, 12), LocalDate.of(2021, 9, 12), false)","var loanProperty = Var.of(loan)"]},

        {"kind":"and","text":"\n            Create lenses for nested records and also trace lists for recording\n            state changes of the original property and all of its lenses.\n        ","code":["var bookLens = loanProperty.zoomTo(Loan::book, Loan::withBook)","var memberLens = loanProperty.zoomTo(Loan::member, Loan::withMember)","var authorLens = bookLens.zoomTo(Book::author, Book::withAuthor)","var loanTrace = []","var bookTrace = []","var memberTrace = []","var authorTrace = []","loanProperty.onChange(From.ALL, it -> loanTrace << it.get())","bookLens.onChange(From.ALL, it -> bookTrace << it.get())","memberLens.onChange(From.ALL, it -> memberTrace << it.get())","authorLens.onChange(From.ALL, it -> authorTrace << it.get())"]},

        {"kind":"expect","text":"\n            The initial values are correct.\n            This is a bit of a sanity check to ensure that the lenses\n            are correctly set up and that they can access the nested records.\n        ","code":["loanProperty.get() == loan","bookLens.get() == loan.book()","memberLens.get() == loan.member()","authorLens.get() == loan.book().author()"]},

        {"kind":"when","text":"\n            We update various levels of nested structures.\n        ","code":["var newAuthor = new Author(\"John\", \"Doe\", LocalDate.of(1980, 2, 15), [\"New Book\"])","var newBook = loan.book().withAuthor(newAuthor)","var newLoan = loan.withBook(newBook)","loanProperty.set(newLoan)"]},

        {"kind":"then","text":"\n            Values are updated correctly and change events are recorded.\n            Note that the member lens trace is empty because the member record\n            was not updated from the original loan record.\n        ","code":["loanProperty.get() == newLoan","bookLens.get() == newLoan.book()","memberLens.get() == newLoan.member()","authorLens.get() == newLoan.book().author()","loanTrace == [newLoan]","bookTrace == [newLoan.book()]","memberTrace == []","authorTrace == [newLoan.book().author()]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can create nullable lens properties from a regular property.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test ensures that the `zoomToNullable` method works correctly\n            with a property that contains a nullable field.\n\n            We will use the Member record which has an optional email field\n            to demonstrate how the lens property behaves with nullable fields.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            Initialize a Member record instance with an optional email field.\n        ","code":["var member = new Member(\"1234\", \"John\", \"Doe\", MembershipLevel.GOLD, LocalDate.of(2010, 1, 1), null)","var memberProperty = Var.of(member)"]},

        {"kind":"and","text":"\n            Create a lens for the nullable email field of the Member record.\n            Also set up a trace list to record state changes of the lens and the original property.\n        ","code":["var emailLens = memberProperty.zoomToNullable(String.class, Member::email, Member::withEmail)","var memberTrace = []","var emailTrace = []","memberProperty.onChange(From.ALL, it -> memberTrace << it.get())","emailLens.onChange(From.ALL, it -> emailTrace << it.get())"]},

        {"kind":"expect","text":"\n            Initial values are correct:\n            - The lens should correctly retrieve the initial nullable email field value.\n            - The original property should contain the initial Member record.\n        ","code":["emailLens.orElseNull() == null","memberProperty.get() == member"]},

        {"kind":"when","text":"\n            Update the nullable email field using the lens.\n        ","code":["emailLens.set(\"john.doe@example.com\")"]},

        {"kind":"then","text":"\n            The lens should update the nullable email field value.\n            Both the lens and the original property should reflect the changes.\n        ","code":["emailLens.get() == \"john.doe@example.com\"","memberProperty.get().email() == \"john.doe@example.com\""]},

        {"kind":"and","text":"\n            Change the nullable email field back to null using the lens.\n        ","code":["emailLens.set(null)"]},

        {"kind":"then","text":"\n            The lens should update the nullable email field value to null.\n            Both the lens and the original property should reflect the changes.\n        ","code":["emailLens.orElseNull() == null","memberProperty.get().email() == null"]},

        {"kind":"when","text":"\n            Update the original property with a new Member instance where the email field is null.\n        ","code":["var newMember = member.withEmail(null)","memberProperty.set(newMember)"]},

        {"kind":"then","text":"\n            The lens should correctly reflect the updated nullable email field value as null.\n            Both the lens and the original property should reflect the changes.\n        ","code":["emailLens.orElseNull() == null","memberProperty.get() == newMember"]},

        {"kind":"and","text":"\n            Update the original property with a new Member instance where the email field is set.\n        ","code":["var updatedMember = member.withEmail(\"jane.doe@example.com\")","memberProperty.set(updatedMember)"]},

        {"kind":"then","text":"\n            The lens should correctly reflect the updated nullable email field value.\n            Both the lens and the original property should reflect the changes.\n        ","code":["emailLens.get() == \"jane.doe@example.com\"","memberProperty.get() == updatedMember"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A lens created from the `zoomTo` method throws an exception when receiving null values.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An Author record and its property","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"A lens focusing on the first name of the Author","code":["var firstNameLens = authorProperty.zoomTo(Author::firstName, Author::withFirstName)"]},

        {"kind":"when","text":"Setting a null value via the lens","code":["firstNameLens.set(null)"]},

        {"kind":"then","text":"An exception is thrown","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You cannot create a lens from the `zoomTo` method if the target value is null.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An Author record with a null first name and its property","code":["var author = new Author(null, \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"when","text":"Creating a lens focusing on the first name of the Author","code":["authorProperty.zoomTo(Author::firstName, Author::withFirstName)"]},

        {"kind":"then","text":"An exception is thrown","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A lens on a nested null value models null without throwing an exception.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A Member record with a null book","code":["var member = new Member(\"1234\", \"John\", \"Doe\", MembershipLevel.GOLD, LocalDate.of(2010, 1, 1), null)","var memberProperty = Var.of(member)"]},

        {"kind":"when","text":"Creating a lens focusing on a nested nullable field","code":["var emailLens = memberProperty.zoomToNullable(String.class, Member::email, Member::withEmail)"]},

        {"kind":"then","text":"The lens handles the null value correctly","code":["emailLens.orElseNull() == null"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can create nullable lenses from nullable property even if there is no initial value.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            It should be possible to create a nullable lens from a nullable property\n            even if the initial value of the first lens is null.\n            In that case the second lens should also have a null value.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"\n            We create a nullable `Book` based property which is \n            initially set to null.\n            And then we create a nullable lens for the `Author` record\n            of the `Book` record.\n        ","code":["var bookProperty = Var.ofNull(Book.class)","var authorLens = bookProperty.zoomToNullable(Author.class, Book::author, Book::withAuthor)"]},

        {"kind":"expect","text":"\n            Both the lens and the original property should have a null value.\n        ","code":["authorLens.orElseNull() == null","bookProperty.orElseNull() == null"]},

        {"kind":"when","text":"We set a new Book instance without an author.","code":["var book = new Book(\"The Book\", null, Genre.HISTORY, LocalDate.of(2019, 5, 12), 304)","bookProperty.set(book)"]},

        {"kind":"then","text":"The book property has the new value and the lens has a null value.","code":["bookProperty.get() == book","authorLens.orElseNull() == null"]},

        {"kind":"when","text":"We set a new Book instance with an author.","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1980, 2, 15), [\"New Book\"])","var newBook = book.withAuthor(author)","bookProperty.set(newBook)"]},

        {"kind":"then","text":"The book property has the new value and the lens has the author value.","code":["bookProperty.get() == newBook","authorLens.get() == author"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property lens with a default value focuses on specific field with a non-null parent value.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An Author record and its property","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"A lens focusing on the first name of the Author with a default value","code":["var defaultFirstName = \"Unknown\"","var firstNameLens = authorProperty.zoomTo(defaultFirstName, Author::firstName, Author::withFirstName)"]},

        {"kind":"expect","text":"The lens retrieves the correct initial value","code":["firstNameLens.get() == author.firstName()"]},

        {"kind":"when","text":"The first name is updated through the lens","code":["firstNameLens.set(\"Jane\")"]},

        {"kind":"then","text":"The original property is updated correctly","code":["authorProperty.get().firstName() == \"Jane\"","firstNameLens.get() == \"Jane\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property lens with a default value uses its default value when the parent property value is null initially.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A nullable Author property initialized to null","code":["var authorProperty = Var.ofNull(Author.class)"]},

        {"kind":"and","text":"A lens focusing on the first name of the Author with a default value","code":["var defaultFirstName = \"Unknown\"","var firstNameLens = authorProperty.zoomTo(defaultFirstName, Author::firstName, Author::withFirstName)"]},

        {"kind":"expect","text":"The lens retrieves the default value when the parent is null","code":["firstNameLens.get() == defaultFirstName"]},

        {"kind":"when","text":"A new Author record is set with a specific first name","code":["var newAuthor = new Author(\"Jane\", \"Smith\", LocalDate.of(1997, 9, 3), [\"Book3\", \"Book4\"])","authorProperty.set(newAuthor)"]},

        {"kind":"then","text":"The lens retrieves the new value from the parent","code":["firstNameLens.get() == newAuthor.firstName()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property lens with a default value updates the parent value correctly when setting it through the lens.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An Author record and its property","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"A lens focusing on the first name of the Author with a default value","code":["var defaultFirstName = \"Unknown\"","var firstNameLens = authorProperty.zoomTo(defaultFirstName, Author::firstName, Author::withFirstName)"]},

        {"kind":"when","text":"The first name is updated through the lens","code":["firstNameLens.set(\"Jane\")"]},

        {"kind":"then","text":"The original property is updated correctly","code":["authorProperty.get().firstName() == \"Jane\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A lens with a default value throws an exception when the null object is null.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An Author record and its property","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"when","text":"Creating a lens with a null default value","code":["authorProperty.zoomTo(null, Author::firstName, Author::withFirstName)"]},

        {"kind":"then","text":"An exception is thrown","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A lens with a default value handles updates gracefully when switching from null parent to non-null parent.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A nullable Author property initialized to null","code":["var authorProperty = Var.ofNull(Author.class)"]},

        {"kind":"and","text":"A lens focusing on the first name of the Author with a default value","code":["var defaultFirstName = \"Unknown\"","var firstNameLens = authorProperty.zoomTo(defaultFirstName, Author::firstName, Author::withFirstName)"]},

        {"kind":"expect","text":"The lens retrieves the default value when the parent is null","code":["firstNameLens.get() == defaultFirstName"]},

        {"kind":"when","text":"A new Author record is set with a specific first name","code":["var newAuthor = new Author(\"Jane\", \"Smith\", LocalDate.of(1997, 9, 3), [\"Book3\", \"Book4\"])","authorProperty.set(newAuthor)"]},

        {"kind":"then","text":"The lens retrieves the new value from the parent","code":["firstNameLens.get() == newAuthor.firstName()"]},

        {"kind":"when","text":"The parent is set back to null","code":["authorProperty.set(null)"]},

        {"kind":"then","text":"The lens retrieves the default value again","code":["firstNameLens.get() == defaultFirstName"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The lenses of a property are garbage collected when no longer referenced strongly.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A property lens registers a weak action listener on the original property.\n            These weak listeners are stored in a weak hash map where the property lens\n            itself is the weakly referenced key.\n            So when the property lens is no longer referenced strongly, it should be\n            garbage collected and the weak listener should be removed\n            from the original property.\n\n            We can verify this by checking the reported number of change listeners.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We have an `Author` record and a property holding it.","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"expect","text":"Initially there are no change listeners registered:","code":["authorProperty.numberOfChangeListeners() == 0"]},

        {"kind":"when","text":"We create two lenses which we reference strongly.","code":["var firstName = authorProperty.zoomTo(Author::firstName, Author::withFirstName)","var lastName = authorProperty.zoomTo(Author::lastName,  Author::withLastName)"]},

        {"kind":"then","text":"The author property has 2 change listeners registered.","code":["authorProperty.numberOfChangeListeners() == 2"]},

        {"kind":"when","text":"We create two lenses which we do not reference strongly.","code":["authorProperty.zoomTo(Author::birthDate, Author::withBirthDate)","authorProperty.zoomTo(Author::books,     Author::withBooks)"]},

        {"kind":"and","text":"We wait for the garbage collector to run.","code":["waitForGarbageCollection()","Thread.sleep(500)"]},

        {"kind":"then","text":"The author property should still have 2 change listeners registered.","code":["authorProperty.numberOfChangeListeners() == 2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can access the item of a lens, even if an exception occurs in its getter.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The item of a property lens is always retrieved from a getter function.\n            If an exception occurs in the getter function, then the lens will\n            return the last known item.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create an `Author` and store it in a regular property.","code":["var author = new Author(\"Joe\", \"Average\", LocalDate.of(1990, 1, 1), [])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"We create a lens for the last name of the author with a faulty getter function.","code":["var getterFails = false","var lastName = authorProperty.zoomTo(","                                    {","                                        if (getterFails) throw new RuntimeException()","                                        else return it.lastName()","                                    },","                                    Author::withLastName","                                )"]},

        {"kind":"expect","text":"The lens should have the correct initial value.","code":["lastName.get() == \"Average\""]},

        {"kind":"when","text":"We set the getter to fail and then try to access the item of the lens.","code":["getterFails = true"]},

        {"kind":"then","text":"No exception is thrown...","code":["noExceptionThrown()"]},

        {"kind":"and","text":"...and the lens returns the last known item.","code":["lastName.get() == \"Average\""]},

        {"kind":"when","text":"We completely change the original property.","code":["authorProperty.set(new Author(\"Jane\", \"Doe\", LocalDate.of(1995, 5, 5), [\"Book1\", \"Book2\"]))"]},

        {"kind":"then","text":"\n            The lens should still return the last known item due to the exception\n            preventing the lens from updating its item correctly\n            through the getter function.\n        ","code":["lastName.get() == \"Average\""]},

        {"kind":"when","text":"We set the getter to work again and then try to access the item of the lens.","code":["getterFails = false"]},

        {"kind":"then","text":"The lens should return the correct item.","code":["lastName.get() == \"Doe\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can try to change the item of a lens, even if an exception occurs in its wither.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When modifying the item of a lens, a wither function is used.\n            This wither function takes the item of the parent property\n            and the new item of the lens as arguments and then returns\n            an updated item for the parent property.\n\n            If an exception occurs in this wither function, then the lens\n            will fail to update the parent property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create an `Author` and store it in a regular property.","code":["var author = new Author(\"Filia\", \"Fischer\", LocalDate.of(2010, 3, 6), [])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"We create a lens for the last name of the author with a faulty wither function.","code":["var witherFails = false","var lastName = authorProperty.zoomTo(","                                Author::lastName,","                                (oldAuthor, newName)->{","                                    if (witherFails) throw new RuntimeException()","                                    else return oldAuthor.withLastName(newName)","                                }","                            )"]},

        {"kind":"expect","text":"The lens should have the correct initial value.","code":["lastName.get() == \"Fischer\""]},

        {"kind":"when","text":"We modify the property lens to \"Mayer\"...","code":["lastName.set(\"Mayer\")"]},

        {"kind":"then","text":"The parent property is updated correctly.","code":["authorProperty.get().lastName() == \"Mayer\""]},

        {"kind":"when","text":"\n            We set the wither to fail and then try to modify the item of the lens again.\n            Let's say we want to set the last name to \"Smith\".\n        ","code":["witherFails = true","lastName.set(\"Smith\")"]},

        {"kind":"then","text":"No exception is thrown...","code":["noExceptionThrown()"]},

        {"kind":"and","text":"\n            Due to the exception in the wither function, the parent property\n            is not updated correctly.\n            And because the lens represents the last known item of the parent property,\n            it still returns the last name \"Mayer\", the name \"Smith\" is never applied.\n        ","code":["authorProperty.get().lastName() == \"Mayer\"","lastName.get() == \"Mayer\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property lens knows that it is a property lens.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a regular property, a property lens and a view of a property.","code":["var regularProperty = Var.of(new Author(\"Forename\", \"Surname\", LocalDate.of(2008, 8, 12), []))","var lens = regularProperty.zoomTo(Author::birthDate, Author::withBirthDate)","var view = lens.viewAsString( date -> \"Year: \" + date.getDayOfYear() )"]},

        {"kind":"expect","text":"","code":["!regularProperty.isLens() && !regularProperty.isView()","lens.isLens() && !lens.isView()","!view.isLens() && view.isView()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A property knows if it is mutable or not or nullable or not.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create a regular property, a property lens and a view of a property.","code":["var regularProperty = Var.of(new Author(\"Forename\", \"Surname\", LocalDate.of(2008, 8, 12), []))","var lens = regularProperty.zoomTo(Author::birthDate, Author::withBirthDate)","var view = lens.viewAsString( date -> \"Year: \" + date.getDayOfYear() )","var regularNullProperty = Var.ofNullable(Author.class, new Author(\"Forename\", \"Surname\", LocalDate.of(2008, 8, 12), []))","var nullLens = regularProperty.zoomToNullable(Author.class, Author::birthDate, Author::withBirthDate)","var nullView = lens.viewAsNullable(String.class, date -> \"Year: \" + date.getDayOfYear() )","var immutableProperty = Val.of(\"I never change!\")","var immutableNullProperty = Val.ofNullable(String, \"I also never change!\")"]},

        {"kind":"expect","text":"","code":["regularProperty.isMutable() && !regularProperty.allowsNull()","lens.isMutable() && !lens.allowsNull()","view.isMutable() && !view.allowsNull()","regularNullProperty.isMutable() && regularNullProperty.allowsNull()","nullLens.isMutable() && nullLens.allowsNull()","nullView.isMutable() && nullView.allowsNull()","!immutableProperty.isMutable() && !immutableProperty.allowsNull()","!immutableNullProperty.isMutable() && immutableNullProperty.allowsNull()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can recognize a property lens from its String representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A property lens has a specific string representation that can be used to recognize it.\n            The string representation of a property lens starts with \"Lens\" followed by the item\n            type and square brackets containing the current item of the lens.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A source property and a lens focusing on a specific field.","code":["var author = new Author(\"Forename\", \"Surname\", LocalDate.of(2008, 8, 12), [])","var authorProperty = Var.of(author)","var lens = authorProperty.zoomTo(Author::birthDate, Author::withBirthDate)"]},

        {"kind":"expect","text":"The string representation of the lens should be recognizable.","code":["lens.toString() == \"Lens<LocalDate>[2008-08-12]\""]},

        {"kind":"when","text":"We update the lens to have a custom id String.","code":["lens = lens.withId(\"patient_birth\")"]},

        {"kind":"then","text":"The string representation of the view is as expected.","code":["lens.toString() == \"Lens<LocalDate>[patient_birth=2008-08-12]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can subscribe and unsubscribe observer lambdas on property lenses.()",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A property lens may act like a publisher that can have multiple observers.\n            In this test we create a property lens and a change observer that listens to changes to the lens\n            and is then unsubscribed, which should prevent further notifications.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A property based on the Author record.","code":["var author = new Author(\"John\", \"Doe\", LocalDate.of(1829, 8, 12), [\"Book1\", \"Book2\"])","var authorProperty = Var.of(author)"]},

        {"kind":"and","text":"A lens of the surname of the author.","code":["Val<String> lens = authorProperty.zoomTo(Author::lastName, Author::withLastName)"]},

        {"kind":"and","text":"A trace list and a change listener that listens to changes on the lens.","code":["var trace = []","Observer observer = { trace << lens.get() }"]},

        {"kind":"expect","text":"The trace list is empty and there are no change listeners.","code":["trace.isEmpty()","lens.numberOfChangeListeners() == 0"]},

        {"kind":"when","text":"We subscribe the listener to the lens.","code":["lens.subscribe(observer)"]},

        {"kind":"then","text":"The listener is not immediately notified, but the lens has one change listener.","code":["trace.isEmpty()","lens.numberOfChangeListeners() == 1"]},

        {"kind":"when","text":"We change the value of the source property as well as the lens directly.","code":["authorProperty.set(author.withLastName(\"Smith\"))","authorProperty.set(authorProperty.get().withFirstName(\"Jane\"))","lens.set(\"Mayer\")"]},

        {"kind":"then","text":"The listener is notified of the new value of the lens.","code":["trace == [\"Smith\", \"Mayer\"]"]},

        {"kind":"when","text":"We unsubscribe the listener from the lens.","code":["lens.unsubscribe(observer)"]},

        {"kind":"and","text":"We change the value of the source property as well as the lens directly.","code":["authorProperty.set(author.withLastName(\"Johnson\"))","authorProperty.set(authorProperty.get().withFirstName(\"Raffaela\"))","lens.set(\"Brown\")"]},

        {"kind":"then","text":"The listener is not notified of the new value of the lens.","code":["trace == [\"Smith\", \"Mayer\"]"]},

        {"kind":"and","text":"The lens has no change listeners.","code":["lens.numberOfChangeListeners() == 0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A chain of lenses may not be garbage collected.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Every lens holds a reference to the source property whose field it focuses on.\n            So if a chain of lenses is created, the source property will ultimately be referenced,\n            either directly or indirectly, by all lenses in the chain.\n            These references may be weak references if the parent property is not a lens itself.\n            This is also true for views, which are also always strongly referenced by a lens.\n            A plain property on the other hand is weakly referenced by the lenses.\n            So the chain of lenses may not be garbage collected if the source property \n            is not garbage collected.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A property based on the `Loan` record.","code":["var loanProperty = Var.of(new Loan(","                                        \"l0an-1d\",","                                        new Book(\"Very Interesting Book\",","                                            new Author(","                                                \"Margarete\", \"Wick\",","                                                LocalDate.of(1932, 2, 15),","                                                [\"Very Interesting Book\", \"Not so...\"]","                                            ),","                                            Genre.SCIENCE,","                                            LocalDate.of(1963, 9, 23), 932","                                        ),","                                        new Member(","                                            \"m1d\", \"Lia\", \"Lua\",","                                            MembershipLevel.PLATINUM,","                                            LocalDate.of(2015, 6, 13),","                                            null","                                        ),","                                        LocalDate.of(2023, 8, 12),","                                        LocalDate.of(2023, 9, 12),","                                        false","                                    ))"]},

        {"kind":"and","text":"A chain of lenses going deeper into the nested records.","code":["Val<Book>   view1 = loanProperty.zoomTo(Loan::book, Loan::withBook)","Val<Author> view2 = view1.zoomTo(Book::author, Book::withAuthor)","Val<String> view3 = view2.zoomTo(Author::firstName, Author::withFirstName)"]},

        {"kind":"and","text":"\n            Now we store all of these references in a list of WeakReference objects.\n            This way we can check which of the references are still present\n            after awaiting garbage collection.\n        ","code":["var refs = [","        new WeakReference(loanProperty), new WeakReference(view1),","        new WeakReference(view2), new WeakReference(view3)","    ]"]},

        {"kind":"expect","text":"All references are still present after awaiting garbage collection.","code":["refs.every( it -> it.get() != null )"]},

        {"kind":"and","text":"Each property has the expected number of change listeners for their respective child.","code":["loanProperty.numberOfChangeListeners() == 1","view1.numberOfChangeListeners() == 1","view2.numberOfChangeListeners() == 1","view3.numberOfChangeListeners() == 0"]},

        {"kind":"when","text":"We now remove the intermediate lenses from the chain.","code":["view1 = null","view2 = null"]},

        {"kind":"and","text":"We await garbage collection.","code":["waitForGarbageCollection()","Thread.sleep(500)"]},

        {"kind":"then","text":"Every reference is still present.","code":["refs.every( it -> it.get() != null )"]},

        {"kind":"when","text":"We remove the last lens from the chain.","code":["view3 = null"]},

        {"kind":"and","text":"We await garbage collection.","code":["waitForGarbageCollection()","Thread.sleep(500)"]},

        {"kind":"then","text":"All lenses were garbage collected.","code":["refs[0].get() != null","refs[1].get() == null","refs[2].get() == null","refs[3].get() == null"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The channel of a property change event will propagate to its lenses.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Every mutation to a property can have a channel associated with it.\n            You can call the `Var.set(Channel,T)` method to mutate the property with a custom channel,\n            and then in your change listeners you can check the channel on the property delegate!\n\n            This exact same principle is also true for the lenses of a property\n            whose change event listeners will also receive the channel of the origin property.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We have a book property and 3 lenses focusing on different fields of the book.","code":["var book = new Book(\"The Book\", new Author(\"John\", \"Doe\", LocalDate.of(1980, 2, 15), [\"New Book\"]), Genre.HISTORY, LocalDate.of(2010, 7, 24), 374)","var bookProperty = Var.of(book)","var titleLens = bookProperty.zoomTo(Book::title, Book::withTitle)","var authorLens = bookProperty.zoomTo(Book::author, Book::withAuthor)","var genreLens = bookProperty.zoomTo(Book::genre, Book::withGenre)"]},

        {"kind":"and","text":"We create trace lists for each lens to observe different channels of the change events.","code":["var titleTrace = []","var authorTrace = []","var genreTrace = []","titleLens.onChange(From.ALL, it -> titleTrace << it.channel() )","authorLens.onChange(From.VIEW, it -> authorTrace << it.channel() )","genreLens.onChange(From.VIEW_MODEL, it -> genreTrace << it.channel() )"]},

        {"kind":"expect","text":"Initially, the traces are all empty.","code":["titleTrace.isEmpty()","authorTrace.isEmpty()","genreTrace.isEmpty()"]},

        {"kind":"when","text":"\n            We first change something unrelated to the lenses by \n            updating the page count field on different channels.\n        ","code":["bookProperty.set(From.ALL, book.withPageCount(1))","bookProperty.set(From.VIEW, book.withPageCount(2))","bookProperty.set(From.VIEW_MODEL, book.withPageCount(3))","book = bookProperty.get()"]},

        {"kind":"then","text":"The traces should all still be empty, because the do not focus on page counts.","code":["titleTrace.isEmpty() && authorTrace.isEmpty() && genreTrace.isEmpty()"]},

        {"kind":"when","text":"We now update the title of the book on 3 different channels...","code":["bookProperty.set(From.ALL, book.withTitle(\"New Title 1\"))","bookProperty.set(From.VIEW, book.withTitle(\"New Title 2\"))","bookProperty.set(From.VIEW_MODEL, book.withTitle(\"New Title 3\"))","book = bookProperty.get()"]},

        {"kind":"then","text":"\n            ...only the title trace should have recorded the channel of the change events.\n            Note that it received all change events. This is because the \"ALL\" channel\n            is unique in that is always receives all change events, \n            regardless of the channel they were sent with.\n        ","code":["titleTrace == [From.ALL, From.VIEW, From.VIEW_MODEL]","authorTrace.isEmpty()","genreTrace.isEmpty()"]},

        {"kind":"when","text":"We update the author of the book on 3 different channels...","code":["bookProperty.set(From.ALL, book.withAuthor(book.author().withFirstName(\"Megan\")))","bookProperty.set(From.VIEW, book.withAuthor(book.author().withFirstName(\"Maggie\")))","bookProperty.set(From.VIEW_MODEL, book.withAuthor(book.author().withFirstName(\"Kyle\")))","book = bookProperty.get()"]},

        {"kind":"then","text":"\n            ...only the author trace should have recorded the channel of the change events.\n            But contrary to the title trace, the author trace only recorded the VIEW \n            and the VIEW_MODEL channel, because the author lens is not listening to the ALL channel.\n        ","code":["titleTrace == [From.ALL, From.VIEW, From.VIEW_MODEL]","authorTrace == [From.ALL, From.VIEW]","genreTrace.isEmpty()"]},

        {"kind":"when","text":"We lastly update the genre of the book on 3 different channels...","code":["bookProperty.set(From.ALL, book.withGenre(Genre.FANTASY))","bookProperty.set(From.VIEW, book.withGenre(Genre.SCIENCE))","bookProperty.set(From.VIEW_MODEL, book.withGenre(Genre.HISTORY))","book = bookProperty.get()"]},

        {"kind":"then","text":"\n            ...only the genre trace should have recorded the channel of the change events.\n            But contrary to the title trace, the genre\n            trace only recorded the VIEW_MODEL channel, because the genre lens is not \n            listening to the ALL and VIEW channels.\n        ","code":["titleTrace == [From.ALL, From.VIEW, From.VIEW_MODEL]","authorTrace == [From.ALL, From.VIEW]","genreTrace == [From.ALL, From.VIEW_MODEL]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
