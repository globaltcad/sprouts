{
  "className":"sprouts.Tuple_Spec",
  "title":"Tuple - a Data Oriented Array",
  "narrative":"Data Oriented programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements with proper value semantics.\n    It can also be transformed and filtered in a functional way.\n\n    When modelling value objects, like for example, by declaring\n    records, then we recommend to use the `Tuple` type\n    over of a Java array or a JDK List, because our tuple\n    has better value semantics, immutability guarantees,\n    and it is way more efficient than a Java List.",
  "subjects":["sprouts.Tuple"],
  "statistics":{
    "runs":"315",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"The `Tuple` maintains invariance with Java ArrayList across operations [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var random = new Random(1997)","var tuple = Tuple.of(String)","var referenceList = new ArrayList<>()","var operationsApplier = { currentTuple ->","    operations.each { op, element ->","        int randomIndex = random.nextInt(currentTuple.size() + 1)","        int spread = random.nextInt(5) ** 2","        switch (op) {","            case Operation.ADD:","                if ( spread < 2 ) {","                    var currentTuple1 = currentTuple.addAt(randomIndex, element)","                    referenceList.add(randomIndex, element)","                    currentTuple = currentTuple1","                } else {","                    var toAdd = (0..spread).collect { element + it }","                    currentTuple = currentTuple.addAllAt(randomIndex, toAdd)","                    referenceList.addAll(randomIndex, toAdd)","                }","                break","            case Operation.SLICE_AND_ADD: // Here the value is not used","                if ( !referenceList.isEmpty() ) {","                    int sliceIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int trimmedSpread = spread + Math.min(0, currentTuple.size() - sliceIndex - spread)","                    if (trimmedSpread > 0) {","                        var slice = currentTuple.slice(sliceIndex, sliceIndex+trimmedSpread)","                        currentTuple = currentTuple.addAll(slice) // Append","                        currentTuple = currentTuple.addAllAt(0, slice) // Prepend","                        var subList = new ArrayList<>(referenceList.subList(sliceIndex, sliceIndex + trimmedSpread))","                        referenceList.addAll(subList) // Append","                        referenceList.addAll(0, subList) // Prepend","                    }","                }","                break","            case Operation.REMOVE:","                if ( !referenceList.isEmpty() ) {","                    int removeIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int numberToRemove = (spread-1) * 3","                    if (numberToRemove < 2 || (numberToRemove + removeIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.removeAt(removeIndex)","                        referenceList.remove(removeIndex)","                    } else {","                        currentTuple = currentTuple.removeRange(removeIndex, removeIndex + numberToRemove)","                        for (int i = 0; i < numberToRemove; i++) {","                            referenceList.remove(removeIndex)","                        }","                    }","                }","                break","            case Operation.SET:","                if ( !referenceList.isEmpty() ) {","                    int setIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    if (spread < 2 || (spread + setIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.setAt(setIndex, element)","                        referenceList.set(setIndex, element)","                    } else {","                        currentTuple = currentTuple.setAllAt(setIndex, (0..<spread).collect { element })","                        for (int i = 0; i < spread; i++) {","                            referenceList.set(setIndex + i, element)","                        }","                    }","                }","                break","        }","        if ( !referenceList.equals(currentTuple.toList()) ) {","            println \"Divergence: $referenceList\"","        }","    }","    return currentTuple","}"]},

        {"kind":"when","text":"Apply operations first time","code":["tuple = operationsApplier(tuple)"]},

        {"kind":"then","text":"Immediate invariance","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { tuple = operationsApplier(tuple) }"]},

        {"kind":"then","text":"It is still invariant!","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"We use the stream API to map both the tuple and the reference list.","code":["var mappedTuple = tuple.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedList = referenceList.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTuple.toList() == mappedList"]},

        {"kind":"when","text":"We use the parallel stream API to map both the tuple and the reference list.","code":["var mappedTupleParallel = tuple.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedListParallel = referenceList.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTupleParallel.toList() == mappedListParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n            new Tuple2(Operation.ADD, \"banana\"),\n            new Tuple2(Operation.ADD, \"cherry\"),\n            new Tuple2(Operation.REMOVE, \"apple\"),\n            new Tuple2(Operation.REMOVE, \"banana\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.SET, \"kiwi\"),\n            new Tuple2(Operation.SET, \"pear\"),\n            new Tuple2(Operation.ADD, \"grape\"),\n            new Tuple2(Operation.ADD, \"orange\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.REMOVE, \"berry\"),\n        ]","(-100..100).collect {\n            new Tuple2(\n                Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..300).collect {\n            new Tuple2(\n                    Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` maintains invariance with Java ArrayList across operations [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var random = new Random(1997)","var tuple = Tuple.of(String)","var referenceList = new ArrayList<>()","var operationsApplier = { currentTuple ->","    operations.each { op, element ->","        int randomIndex = random.nextInt(currentTuple.size() + 1)","        int spread = random.nextInt(5) ** 2","        switch (op) {","            case Operation.ADD:","                if ( spread < 2 ) {","                    var currentTuple1 = currentTuple.addAt(randomIndex, element)","                    referenceList.add(randomIndex, element)","                    currentTuple = currentTuple1","                } else {","                    var toAdd = (0..spread).collect { element + it }","                    currentTuple = currentTuple.addAllAt(randomIndex, toAdd)","                    referenceList.addAll(randomIndex, toAdd)","                }","                break","            case Operation.SLICE_AND_ADD: // Here the value is not used","                if ( !referenceList.isEmpty() ) {","                    int sliceIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int trimmedSpread = spread + Math.min(0, currentTuple.size() - sliceIndex - spread)","                    if (trimmedSpread > 0) {","                        var slice = currentTuple.slice(sliceIndex, sliceIndex+trimmedSpread)","                        currentTuple = currentTuple.addAll(slice) // Append","                        currentTuple = currentTuple.addAllAt(0, slice) // Prepend","                        var subList = new ArrayList<>(referenceList.subList(sliceIndex, sliceIndex + trimmedSpread))","                        referenceList.addAll(subList) // Append","                        referenceList.addAll(0, subList) // Prepend","                    }","                }","                break","            case Operation.REMOVE:","                if ( !referenceList.isEmpty() ) {","                    int removeIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int numberToRemove = (spread-1) * 3","                    if (numberToRemove < 2 || (numberToRemove + removeIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.removeAt(removeIndex)","                        referenceList.remove(removeIndex)","                    } else {","                        currentTuple = currentTuple.removeRange(removeIndex, removeIndex + numberToRemove)","                        for (int i = 0; i < numberToRemove; i++) {","                            referenceList.remove(removeIndex)","                        }","                    }","                }","                break","            case Operation.SET:","                if ( !referenceList.isEmpty() ) {","                    int setIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    if (spread < 2 || (spread + setIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.setAt(setIndex, element)","                        referenceList.set(setIndex, element)","                    } else {","                        currentTuple = currentTuple.setAllAt(setIndex, (0..<spread).collect { element })","                        for (int i = 0; i < spread; i++) {","                            referenceList.set(setIndex + i, element)","                        }","                    }","                }","                break","        }","        if ( !referenceList.equals(currentTuple.toList()) ) {","            println \"Divergence: $referenceList\"","        }","    }","    return currentTuple","}"]},

        {"kind":"when","text":"Apply operations first time","code":["tuple = operationsApplier(tuple)"]},

        {"kind":"then","text":"Immediate invariance","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { tuple = operationsApplier(tuple) }"]},

        {"kind":"then","text":"It is still invariant!","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"We use the stream API to map both the tuple and the reference list.","code":["var mappedTuple = tuple.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedList = referenceList.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTuple.toList() == mappedList"]},

        {"kind":"when","text":"We use the parallel stream API to map both the tuple and the reference list.","code":["var mappedTupleParallel = tuple.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedListParallel = referenceList.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTupleParallel.toList() == mappedListParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n            new Tuple2(Operation.ADD, \"banana\"),\n            new Tuple2(Operation.ADD, \"cherry\"),\n            new Tuple2(Operation.REMOVE, \"apple\"),\n            new Tuple2(Operation.REMOVE, \"banana\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.SET, \"kiwi\"),\n            new Tuple2(Operation.SET, \"pear\"),\n            new Tuple2(Operation.ADD, \"grape\"),\n            new Tuple2(Operation.ADD, \"orange\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.REMOVE, \"berry\"),\n        ]","(-100..100).collect {\n            new Tuple2(\n                Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..300).collect {\n            new Tuple2(\n                    Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` maintains invariance with Java ArrayList across operations [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var random = new Random(1997)","var tuple = Tuple.of(String)","var referenceList = new ArrayList<>()","var operationsApplier = { currentTuple ->","    operations.each { op, element ->","        int randomIndex = random.nextInt(currentTuple.size() + 1)","        int spread = random.nextInt(5) ** 2","        switch (op) {","            case Operation.ADD:","                if ( spread < 2 ) {","                    var currentTuple1 = currentTuple.addAt(randomIndex, element)","                    referenceList.add(randomIndex, element)","                    currentTuple = currentTuple1","                } else {","                    var toAdd = (0..spread).collect { element + it }","                    currentTuple = currentTuple.addAllAt(randomIndex, toAdd)","                    referenceList.addAll(randomIndex, toAdd)","                }","                break","            case Operation.SLICE_AND_ADD: // Here the value is not used","                if ( !referenceList.isEmpty() ) {","                    int sliceIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int trimmedSpread = spread + Math.min(0, currentTuple.size() - sliceIndex - spread)","                    if (trimmedSpread > 0) {","                        var slice = currentTuple.slice(sliceIndex, sliceIndex+trimmedSpread)","                        currentTuple = currentTuple.addAll(slice) // Append","                        currentTuple = currentTuple.addAllAt(0, slice) // Prepend","                        var subList = new ArrayList<>(referenceList.subList(sliceIndex, sliceIndex + trimmedSpread))","                        referenceList.addAll(subList) // Append","                        referenceList.addAll(0, subList) // Prepend","                    }","                }","                break","            case Operation.REMOVE:","                if ( !referenceList.isEmpty() ) {","                    int removeIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int numberToRemove = (spread-1) * 3","                    if (numberToRemove < 2 || (numberToRemove + removeIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.removeAt(removeIndex)","                        referenceList.remove(removeIndex)","                    } else {","                        currentTuple = currentTuple.removeRange(removeIndex, removeIndex + numberToRemove)","                        for (int i = 0; i < numberToRemove; i++) {","                            referenceList.remove(removeIndex)","                        }","                    }","                }","                break","            case Operation.SET:","                if ( !referenceList.isEmpty() ) {","                    int setIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    if (spread < 2 || (spread + setIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.setAt(setIndex, element)","                        referenceList.set(setIndex, element)","                    } else {","                        currentTuple = currentTuple.setAllAt(setIndex, (0..<spread).collect { element })","                        for (int i = 0; i < spread; i++) {","                            referenceList.set(setIndex + i, element)","                        }","                    }","                }","                break","        }","        if ( !referenceList.equals(currentTuple.toList()) ) {","            println \"Divergence: $referenceList\"","        }","    }","    return currentTuple","}"]},

        {"kind":"when","text":"Apply operations first time","code":["tuple = operationsApplier(tuple)"]},

        {"kind":"then","text":"Immediate invariance","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { tuple = operationsApplier(tuple) }"]},

        {"kind":"then","text":"It is still invariant!","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"We use the stream API to map both the tuple and the reference list.","code":["var mappedTuple = tuple.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedList = referenceList.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTuple.toList() == mappedList"]},

        {"kind":"when","text":"We use the parallel stream API to map both the tuple and the reference list.","code":["var mappedTupleParallel = tuple.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedListParallel = referenceList.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTupleParallel.toList() == mappedListParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n            new Tuple2(Operation.ADD, \"banana\"),\n            new Tuple2(Operation.ADD, \"cherry\"),\n            new Tuple2(Operation.REMOVE, \"apple\"),\n            new Tuple2(Operation.REMOVE, \"banana\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.SET, \"kiwi\"),\n            new Tuple2(Operation.SET, \"pear\"),\n            new Tuple2(Operation.ADD, \"grape\"),\n            new Tuple2(Operation.ADD, \"orange\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.REMOVE, \"berry\"),\n        ]","(-100..100).collect {\n            new Tuple2(\n                Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..300).collect {\n            new Tuple2(\n                    Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` maintains invariance with Java ArrayList across operations [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var random = new Random(1997)","var tuple = Tuple.of(String)","var referenceList = new ArrayList<>()","var operationsApplier = { currentTuple ->","    operations.each { op, element ->","        int randomIndex = random.nextInt(currentTuple.size() + 1)","        int spread = random.nextInt(5) ** 2","        switch (op) {","            case Operation.ADD:","                if ( spread < 2 ) {","                    var currentTuple1 = currentTuple.addAt(randomIndex, element)","                    referenceList.add(randomIndex, element)","                    currentTuple = currentTuple1","                } else {","                    var toAdd = (0..spread).collect { element + it }","                    currentTuple = currentTuple.addAllAt(randomIndex, toAdd)","                    referenceList.addAll(randomIndex, toAdd)","                }","                break","            case Operation.SLICE_AND_ADD: // Here the value is not used","                if ( !referenceList.isEmpty() ) {","                    int sliceIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int trimmedSpread = spread + Math.min(0, currentTuple.size() - sliceIndex - spread)","                    if (trimmedSpread > 0) {","                        var slice = currentTuple.slice(sliceIndex, sliceIndex+trimmedSpread)","                        currentTuple = currentTuple.addAll(slice) // Append","                        currentTuple = currentTuple.addAllAt(0, slice) // Prepend","                        var subList = new ArrayList<>(referenceList.subList(sliceIndex, sliceIndex + trimmedSpread))","                        referenceList.addAll(subList) // Append","                        referenceList.addAll(0, subList) // Prepend","                    }","                }","                break","            case Operation.REMOVE:","                if ( !referenceList.isEmpty() ) {","                    int removeIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int numberToRemove = (spread-1) * 3","                    if (numberToRemove < 2 || (numberToRemove + removeIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.removeAt(removeIndex)","                        referenceList.remove(removeIndex)","                    } else {","                        currentTuple = currentTuple.removeRange(removeIndex, removeIndex + numberToRemove)","                        for (int i = 0; i < numberToRemove; i++) {","                            referenceList.remove(removeIndex)","                        }","                    }","                }","                break","            case Operation.SET:","                if ( !referenceList.isEmpty() ) {","                    int setIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    if (spread < 2 || (spread + setIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.setAt(setIndex, element)","                        referenceList.set(setIndex, element)","                    } else {","                        currentTuple = currentTuple.setAllAt(setIndex, (0..<spread).collect { element })","                        for (int i = 0; i < spread; i++) {","                            referenceList.set(setIndex + i, element)","                        }","                    }","                }","                break","        }","        if ( !referenceList.equals(currentTuple.toList()) ) {","            println \"Divergence: $referenceList\"","        }","    }","    return currentTuple","}"]},

        {"kind":"when","text":"Apply operations first time","code":["tuple = operationsApplier(tuple)"]},

        {"kind":"then","text":"Immediate invariance","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { tuple = operationsApplier(tuple) }"]},

        {"kind":"then","text":"It is still invariant!","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"We use the stream API to map both the tuple and the reference list.","code":["var mappedTuple = tuple.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedList = referenceList.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTuple.toList() == mappedList"]},

        {"kind":"when","text":"We use the parallel stream API to map both the tuple and the reference list.","code":["var mappedTupleParallel = tuple.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedListParallel = referenceList.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTupleParallel.toList() == mappedListParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n            new Tuple2(Operation.ADD, \"banana\"),\n            new Tuple2(Operation.ADD, \"cherry\"),\n            new Tuple2(Operation.REMOVE, \"apple\"),\n            new Tuple2(Operation.REMOVE, \"banana\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.SET, \"kiwi\"),\n            new Tuple2(Operation.SET, \"pear\"),\n            new Tuple2(Operation.ADD, \"grape\"),\n            new Tuple2(Operation.ADD, \"orange\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.REMOVE, \"berry\"),\n        ]","(-100..100).collect {\n            new Tuple2(\n                Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..300).collect {\n            new Tuple2(\n                    Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` maintains invariance with Java ArrayList across operations [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var random = new Random(1997)","var tuple = Tuple.of(String)","var referenceList = new ArrayList<>()","var operationsApplier = { currentTuple ->","    operations.each { op, element ->","        int randomIndex = random.nextInt(currentTuple.size() + 1)","        int spread = random.nextInt(5) ** 2","        switch (op) {","            case Operation.ADD:","                if ( spread < 2 ) {","                    var currentTuple1 = currentTuple.addAt(randomIndex, element)","                    referenceList.add(randomIndex, element)","                    currentTuple = currentTuple1","                } else {","                    var toAdd = (0..spread).collect { element + it }","                    currentTuple = currentTuple.addAllAt(randomIndex, toAdd)","                    referenceList.addAll(randomIndex, toAdd)","                }","                break","            case Operation.SLICE_AND_ADD: // Here the value is not used","                if ( !referenceList.isEmpty() ) {","                    int sliceIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int trimmedSpread = spread + Math.min(0, currentTuple.size() - sliceIndex - spread)","                    if (trimmedSpread > 0) {","                        var slice = currentTuple.slice(sliceIndex, sliceIndex+trimmedSpread)","                        currentTuple = currentTuple.addAll(slice) // Append","                        currentTuple = currentTuple.addAllAt(0, slice) // Prepend","                        var subList = new ArrayList<>(referenceList.subList(sliceIndex, sliceIndex + trimmedSpread))","                        referenceList.addAll(subList) // Append","                        referenceList.addAll(0, subList) // Prepend","                    }","                }","                break","            case Operation.REMOVE:","                if ( !referenceList.isEmpty() ) {","                    int removeIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    int numberToRemove = (spread-1) * 3","                    if (numberToRemove < 2 || (numberToRemove + removeIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.removeAt(removeIndex)","                        referenceList.remove(removeIndex)","                    } else {","                        currentTuple = currentTuple.removeRange(removeIndex, removeIndex + numberToRemove)","                        for (int i = 0; i < numberToRemove; i++) {","                            referenceList.remove(removeIndex)","                        }","                    }","                }","                break","            case Operation.SET:","                if ( !referenceList.isEmpty() ) {","                    int setIndex = Math.max(0, Math.min(randomIndex, currentTuple.size() - 1))","                    if (spread < 2 || (spread + setIndex) >= currentTuple.size()) {","                        currentTuple = currentTuple.setAt(setIndex, element)","                        referenceList.set(setIndex, element)","                    } else {","                        currentTuple = currentTuple.setAllAt(setIndex, (0..<spread).collect { element })","                        for (int i = 0; i < spread; i++) {","                            referenceList.set(setIndex + i, element)","                        }","                    }","                }","                break","        }","        if ( !referenceList.equals(currentTuple.toList()) ) {","            println \"Divergence: $referenceList\"","        }","    }","    return currentTuple","}"]},

        {"kind":"when","text":"Apply operations first time","code":["tuple = operationsApplier(tuple)"]},

        {"kind":"then","text":"Immediate invariance","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { tuple = operationsApplier(tuple) }"]},

        {"kind":"then","text":"It is still invariant!","code":["tuple.size() == referenceList.size()","tuple.toList() == referenceList"]},

        {"kind":"when","text":"We use the stream API to map both the tuple and the reference list.","code":["var mappedTuple = tuple.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedList = referenceList.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTuple.toList() == mappedList"]},

        {"kind":"when","text":"We use the parallel stream API to map both the tuple and the reference list.","code":["var mappedTupleParallel = tuple.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Tuple.collectorOf(String.class))","var mappedListParallel = referenceList.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toList())"]},

        {"kind":"then","text":"The mapped tuple and list are equal.","code":["mappedTupleParallel.toList() == mappedListParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n            new Tuple2(Operation.ADD, \"banana\"),\n            new Tuple2(Operation.ADD, \"cherry\"),\n            new Tuple2(Operation.REMOVE, \"apple\"),\n            new Tuple2(Operation.REMOVE, \"banana\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.SET, \"kiwi\"),\n            new Tuple2(Operation.SET, \"pear\"),\n            new Tuple2(Operation.ADD, \"grape\"),\n            new Tuple2(Operation.ADD, \"orange\"),\n            new Tuple2(Operation.SLICE_AND_ADD, \"\"),\n            new Tuple2(Operation.REMOVE, \"berry\"),\n        ]","(-100..100).collect {\n            new Tuple2(\n                Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..300).collect {\n            new Tuple2(\n                    Operation.values()Math.abs(new Random(it).nextInt() % Operation.values().length)],\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500)\n            )\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [44]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [45]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [46]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [47]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [48]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [49]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [50]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [51]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [52]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [53]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [54]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [55]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [56]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Integer,-800..800)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(Integer, 0..900)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(3, 6)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..900)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(\"\",\"\",\"!\",\"\")","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf {it in 2..300||it==500 }}","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(60, 301) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceFirst(301) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceLast(301) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.sliceAt(60, 301) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(60, 301) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.setAt(60, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.addAt(60, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(60) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.removeAt(100, 600) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.addAll(-100..100) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(100, -100..99) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf {it in 2..300||it==500 }}","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(Integer, (-800..800).reverse())","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(Integer, 1..900)","Tuple.of(Integer, 0..899)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(Integer, (0..900).collect(it->{ it*2 }))","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(String, (0..900).collect(it->{ it+\" cents\" }))","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(Integer, (0..900).findAll(it->{ it in 2..300||it==500 }))","Tuple.of(2, 3)","Tuple.of(Integer, (60..300))","Tuple.of(1, 2, 3)","Tuple.of(Integer, (0..300))","Tuple.of(3, 4, 5)","Tuple.of(Integer, (600..900))","Tuple.of(2, 3, 4)","Tuple.of(Integer, (60..360))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..59).plus((301..900)))","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((61..900)))","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(Integer, (0..59).plus(10).plus((60..900)))","Tuple.of(1, 3, 4, 5)","Tuple.of(Integer, (0..59).plus((61..900)))","Tuple.of(1, 4, 5)","Tuple.of(Integer, (0..99).plus((700..900)))","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(Integer, (0..900).plus(10))","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer, (0..900).plus((-100..100)))","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(Integer, (0..99).plus((-100..100)).plus((101..900)))","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(Integer, (0..900).findAll(it->{ !(it in 2..300||it==500) }))","Tuple.of(1, 2, 3)","Tuple.of(\"\", \"!\")","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `makeDistinct()` method is like turning a tuple into a linked hash set. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We call the `makeDistinct()` method on the input.","code":["var result = input.makeDistinct()"]},

        {"kind":"and","text":"We also fill a linked hash set with the input.","code":["var set = new LinkedHashSet<>(input.toList())"]},

        {"kind":"then","text":"The result has the expected contents.","code":["result == Tuple.of(result.type(), set)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3, 1, 2, 2, 3, 6, 6, 3, 2, 1, 1)","Tuple.of(\"a\", \"b\", \"c\", \"a\", \"b\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\")","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY,\n            DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY,\n            DayOfWeek.SUNDAY, DayOfWeek.MONDAY, DayOfWeek.TUESDAY,\n            DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY,\n            DayOfWeek.SATURDAY, DayOfWeek.SUNDAY)","Tuple.of(Integer,(0..100).collect(it->{ (31*it) % 10 }))"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `makeDistinct()` method is like turning a tuple into a linked hash set. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We call the `makeDistinct()` method on the input.","code":["var result = input.makeDistinct()"]},

        {"kind":"and","text":"We also fill a linked hash set with the input.","code":["var set = new LinkedHashSet<>(input.toList())"]},

        {"kind":"then","text":"The result has the expected contents.","code":["result == Tuple.of(result.type(), set)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3, 1, 2, 2, 3, 6, 6, 3, 2, 1, 1)","Tuple.of(\"a\", \"b\", \"c\", \"a\", \"b\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\")","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY,\n            DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY,\n            DayOfWeek.SUNDAY, DayOfWeek.MONDAY, DayOfWeek.TUESDAY,\n            DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY,\n            DayOfWeek.SATURDAY, DayOfWeek.SUNDAY)","Tuple.of(Integer,(0..100).collect(it->{ (31*it) % 10 }))"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `makeDistinct()` method is like turning a tuple into a linked hash set. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We call the `makeDistinct()` method on the input.","code":["var result = input.makeDistinct()"]},

        {"kind":"and","text":"We also fill a linked hash set with the input.","code":["var set = new LinkedHashSet<>(input.toList())"]},

        {"kind":"then","text":"The result has the expected contents.","code":["result == Tuple.of(result.type(), set)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3, 1, 2, 2, 3, 6, 6, 3, 2, 1, 1)","Tuple.of(\"a\", \"b\", \"c\", \"a\", \"b\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\")","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY,\n            DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY,\n            DayOfWeek.SUNDAY, DayOfWeek.MONDAY, DayOfWeek.TUESDAY,\n            DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY,\n            DayOfWeek.SATURDAY, DayOfWeek.SUNDAY)","Tuple.of(Integer,(0..100).collect(it->{ (31*it) % 10 }))"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `makeDistinct()` method is like turning a tuple into a linked hash set. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We call the `makeDistinct()` method on the input.","code":["var result = input.makeDistinct()"]},

        {"kind":"and","text":"We also fill a linked hash set with the input.","code":["var set = new LinkedHashSet<>(input.toList())"]},

        {"kind":"then","text":"The result has the expected contents.","code":["result == Tuple.of(result.type(), set)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3, 1, 2, 2, 3, 6, 6, 3, 2, 1, 1)","Tuple.of(\"a\", \"b\", \"c\", \"a\", \"b\", \"x\", \"y\", \"z\", \"a\", \"b\", \"c\")","Tuple.of(DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY,\n            DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY,\n            DayOfWeek.SUNDAY, DayOfWeek.MONDAY, DayOfWeek.TUESDAY,\n            DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY,\n            DayOfWeek.SATURDAY, DayOfWeek.SUNDAY)","Tuple.of(Integer,(0..100).collect(it->{ (31*it) % 10 }))"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [44]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [45]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [46]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [47]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [48]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [49]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [50]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [51]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(Integer, 0..9)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..6)","Tuple.of(1, 2, 3)","Tuple.of(Integer, 0..6)","Tuple.of(Integer, 0..7)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(Integer, 0..10)","Tuple.of(Integer, 0..10)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf {it in 2..3||it == 5} }","{ tuple -> tuple.retainIf {it in [2, 5]} }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.retainIf { true } }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 0..9)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer)) }","{ tuple -> tuple.retainAll(Tuple.of(Integer, 1..8)) }","{ tuple -> tuple.retainAll(Tuple.of(2, 3, 4, 7, 2)) }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.slice(3, 3) }","{ tuple -> tuple.slice(0, 5) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.removeRange(0, 5) }","{ tuple -> tuple.removeRange(3, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.addAllAt(1, []) }","{ tuple -> tuple.removeAll([]) }","{ tuple -> tuple.removeAll([-2, -4]) }","{ tuple -> tuple.removeAll([2, 0, 4]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf {it in 2..3||it == 5} }","{ tuple -> tuple.removeIf {it in [2, 5]} }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.removeIf { false } }","{ tuple -> tuple.setAt(2, 2) }","{ tuple -> tuple.setAllAt(2, Tuple.of(2, 3, 4)) }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.NONE","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.NONE","SequenceChange.NONE","SequenceChange.NONE"],"index":["-1","-1","0","3","0","0","0","1","-1","-1","0","2","-1","-1","-1","-1","1","-1","1","-1","-1","0","2","1","1","0","-1","1","1","1","1","5","3","3","3","0","1","1","1","-1","-1","-1","-1","1","-1","-1","0","2","-1","-1","-1","-1"],"count":["4","3","1","1","3","3","2","2","3","2","1","2","2","0","0","0","8","4","2","0","0","3","3","3","2","5","0","1","1","1","2","1","2","2","2","3","2","2","2","0","0","0","3","2","3","2","1","2","2","0","0","0"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `classTyped` method returns the correct class and handles null parameters.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple.classTyped(Class)` may seem strange at first,\n            but it is really important when you want to use the tuple\n            as a generic parameter type inferred from the class pointer.\n\n            Like for example:\n            ```java\n                Var<Tuple<String>> strings = Var.of(Tuple.classTyped(String.class));\n            ```\n        "]
      },
      "blocks":[
        {"kind":"when","text":"","code":["var associationClass = Tuple.classTyped(String)"]},

        {"kind":"then","text":"","code":["associationClass == Tuple.class"]},

        {"kind":"when","text":"","code":["Tuple.classTyped(null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can tell two tuples with different nullability apart from their String representations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A nullable tuple and a non-nullable tuple:","code":["var words1 = Tuple.ofNullable(String).addAll(\"soy milk\", \"豆乳\", \"sojamilch\")","var words2 = Tuple.of(String).addAll(\"soy milk\", \"豆乳\", \"sojamilch\")"]},

        {"kind":"expect","text":"The tuples have different string representations.","code":["words1.toString() != words2.toString()"]},

        {"kind":"and","text":"These look as follows:","code":["words1.toString() == \"Tuple<String?>[soy milk, 豆乳, sojamilch]\"","words2.toString() == \"Tuple<String>[soy milk, 豆乳, sojamilch]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two tuples are equal, even if they were produced by different operations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An initial tuple:","code":["var tuple = Tuple.of(\"a\", \"b\", \"c\")"]},

        {"kind":"and","text":"Two tuples with the same contents, but produced by different operations:","code":["var tuple1 = tuple.reversed().removeFirst().removeLast()","var tuple2 = tuple.removeIf({ it == \"a\" }).removeIf({ it == \"c\" })"]},

        {"kind":"expect","text":"The tuples are equal.","code":["tuple1 == tuple2"]},

        {"kind":"when","text":"Peeking inside, we get the diff objects.","code":["var diff1 = (tuple1 as SequenceDiffOwner).differenceFromPrevious().get()","var diff2 = (tuple2 as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"The diff objects are different.","code":["diff1 != diff2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A nullable tuple is never equal to a non-nullable tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A nullable tuple and a non-nullable tuple:","code":["var tuple1 = Tuple.ofNullable(String)","var tuple2 = Tuple.of(String)"]},

        {"kind":"expect","text":"The tuples are not equal because they have different nullability.","code":["tuple1 != tuple2","tuple1.allowsNull()","!tuple2.allowsNull()"]},

        {"kind":"when","text":"We update both tuples to new ones with the same contents.","code":["tuple1 = tuple1.addAll(\"a\", \"b\", \"c\")","tuple2 = tuple2.addAll(\"a\", \"b\", \"c\")"]},

        {"kind":"then","text":"The tuples are still not equal because one of them allows nulls and the other does not.","code":["tuple1 != tuple2","tuple1.allowsNull()","!tuple2.allowsNull()"]},

        {"kind":"when","text":"We turn the tuples into lists.","code":["var list1 = tuple1.toList()","var list2 = tuple2.toList()"]},

        {"kind":"then","text":"The lists are equal.","code":["list1 == list2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two nullable tuples of the same type are equal, if their contents are equal.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two nullable tuples of the same type:","code":["var words1 = Tuple.ofNullable(String).addAll(\"soy milk\", \"豆乳\", \"Sojamilch\")","var words2 = Tuple.ofNullable(String).addAll(\"soy milk\", \"豆乳\", \"Sojamilch\")"]},

        {"kind":"expect","text":"The tuples are equal and they also have the same hash code.","code":["words1 == words2","words1.hashCode() == words2.hashCode()"]},

        {"kind":"when","text":"We update both tuples to new ones with the same contents.","code":["words1 = words1.addAll(\"두유\", \"sojové mlieko\", \"सोय दूध\", \"waiu soya\")","words2 = words2.addAll(\"두유\", \"sojové mlieko\", \"सोय दूध\", \"waiu soya\")"]},

        {"kind":"then","text":"The tuples are still equal.","code":["words1 == words2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two non-nullable tuples of the same type are equal, if their contents are equal.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two non-nullable tuples of the same type:","code":["var tuple1 = Tuple.of(String).addAll(\"oat milk\", \"귀리 우유\", \"Hafermilch\")","var tuple2 = Tuple.of(String).addAll(\"oat milk\", \"귀리 우유\", \"Hafermilch\")"]},

        {"kind":"expect","text":"The tuples are equal and they also have the same hash code.","code":["tuple1 == tuple2","tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We update both tuples to new ones with the same contents.","code":["tuple1 = tuple1.addAll(\"havremjölk\", \"mleko owsiane\", \"waiu oat\")","tuple2 = tuple2.addAll(\"havremjölk\", \"mleko owsiane\", \"waiu oat\")"]},

        {"kind":"then","text":"The tuples are still equal.","code":["tuple1 == tuple2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can collect a Java stream of items to a Sprouts tuple natively!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A Java stream of Numbers.","code":["var stream = Stream.of(42, 7 as byte, 3.14d, 2.71f, 999L)"]},

        {"kind":"when","text":"We collect the stream to a Sprouts tuple.","code":["var tuple = stream.collect(Tuple.collectorOf(Number))"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple == Tuple.of(Number, 42, 7 as byte, 3.14d, 2.71f, 999L)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can collect a stream of items into a tuple with a custom collector.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We collect the stream of items into a Sprouts tuple with a custom collector.","code":["var tuple1 = Stream.of(\"hello\", \"world\", \"from\", \"Sprouts\")","                            .collect(Tuple.collectorOf(String))"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple1 == Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We collect the stream of partially null items into a Sprouts tuple with a custom collector.","code":["var tuple2 = Stream.of(\"hello\", null, \"from\", null, \"Sprouts\")","                            .collect(Tuple.collectorOfNullable(String))"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple2 == Tuple.ofNullable(String, \"hello\", null, \"from\", null, \"Sprouts\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Collecting a stream of items with nulls into a non-nullable tuple throws an exception.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We try to collect a stream of items with nulls into a non-nullable tuple.","code":["Stream.of(\"hello\", null, \"from\", null, \"Sprouts\")","      .collect(Tuple.collectorOf(String))"]},

        {"kind":"then","text":"A null pointer exception is thrown.","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `removeFirstFound(T)` method to remove the first occurrence of an element.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"This\", \"day\", \"is\", \"a\" ,\"very\", \"nice\", \"day\")"]},

        {"kind":"when","text":"We remove the first occurrence of the word \"day\".","code":["words = words.removeFirstFound(\"day\")"]},

        {"kind":"then","text":"The first occurrence of the word \"day\" was removed.","code":["words == Tuple.of(\"This\", \"is\", \"a\", \"very\", \"nice\", \"day\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"hello\", \"world\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.removeFirstFoundOrThrow(\"world\")"]},

        {"kind":"then","text":"The removal was successful.","code":["words == Tuple.of(\"hello\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.removeFirstFoundOrThrow(\"mercy\")"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NoSuchElementException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `maybeRemoveFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"hello\", \"world\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.maybeRemoveFirstFoundOrThrow(Maybe.of(\"world\"))"]},

        {"kind":"then","text":"The removal was successful.","code":["words == Tuple.of(\"hello\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.maybeRemoveFirstFoundOrThrow(Maybe.of(\"mercy\"))"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NoSuchElementException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `remove(T)` method removes every occurrence of the element from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some numeric elements in it.","code":["var numbers = Tuple.of(4, 2, 2, 7, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove the number 2 from the tuple.","code":["numbers = numbers.remove(2)"]},

        {"kind":"then","text":"The number 2 was removed from the tuple.","code":["numbers == Tuple.of(4, 7, 3, 4, 7)"]},

        {"kind":"and","text":"The equality check also works for the list representation.","code":["numbers.toList() == [4, 7, 3, 4, 7]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `maybeRemove(Maybe<T>)` method removes every occurrence of the element from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some numeric elements in it.","code":["var numbers = Tuple.of(4, 2, 2, 7, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove the number 2 from the tuple.","code":["numbers = numbers.maybeRemove(Maybe.of(2))"]},

        {"kind":"then","text":"The number 2 was removed from the tuple.","code":["numbers == Tuple.of(4, 7, 3, 4, 7)"]},

        {"kind":"and","text":"The equality check also works for the list representation.","code":["numbers.toList() == [4, 7, 3, 4, 7]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple will throw `IndexOutOfBounds` if its range is exceeded. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply the erroneous operation...","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["thrown(IndexOutOfBoundsException)"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAddAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(-1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(-1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(-1, 3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeAddAllAt(4, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAllAt(3, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(3, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetAt(0, 5, Maybe.ofNull(Integer)) }","{ tuple -> tuple.maybeSetRange(0, 8, Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(-1, 42) }","{ tuple -> tuple.setAt(-1, 42) }","{ tuple -> tuple.setAllAt(-1, 4) }","{ tuple -> tuple.setAt(-1, 2, 42) }","{ tuple -> tuple.setRange(-1, 3, 42) }","{ tuple -> tuple.addAllAt(4, 42) }","{ tuple -> tuple.setAt(3, 42) }","{ tuple -> tuple.setAllAt(3, 42) }","{ tuple -> tuple.setAt(3, 2, 42) }","{ tuple -> tuple.setRange(3, 2, 42) }","{ tuple -> tuple.setAt(0, 5, 42) }","{ tuple -> tuple.setRange(0, 8, 42) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can updating a non-nullable tuple with a non-empty `Maybe`. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.maybeAdd(Maybe.of(42)) }","{ tuple -> tuple.maybeAddAll(Maybe.of(1997), Maybe.of(73)) }","{ tuple -> tuple.maybeAddAllAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAt(1, Maybe.of(42)) }","{ tuple -> tuple.maybeSetAllAt(1, Maybe.of(42), Maybe.of(73)) }","{ tuple -> tuple.maybeSetAt(1, 2, Maybe.of(42)) }","{ tuple -> tuple.maybeSetRange(0, 3, Maybe.of(42)) }"],"expected":["Tuple.of(1, 2, 3, 42)","Tuple.of(1, 2, 3, 1997, 73)","Tuple.of(1, 42, 2, 3)","Tuple.of(1, 42, 3)","Tuple.of(1, 42, 73)","Tuple.of(1, 42, 42)","Tuple.of(42, 42, 42)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"It is possible to create and use a tuple of nullable ints.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports both nullable and non-nullable tuples.\n            So it is possible to create a nullable tuple of ints.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A nullable tuple of ints.","code":["def tuple = Tuple.ofNullable(Integer, 1, null, 3, 4, null)"]},

        {"kind":"expect","text":"The tuple contains the expected values.","code":["tuple.get(0) == 1","tuple.get(1) == null","tuple.get(2) == 3","tuple.get(3) == 4","tuple.get(4) == null"]},

        {"kind":"when","text":"We turn the tuple into a list.","code":["def list = tuple.toList()"]},

        {"kind":"then","text":"The list also contains the expected values.","code":["list == [1, null, 3, 4, null]"]},

        {"kind":"when","text":"We remove a chunk in the middle of the tuple.","code":["tuple = tuple.removeRange(1, 4)"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple == Tuple.ofNullable(Integer, 1, null)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"When mapping a tuple with `null` values, the result will be a nullable tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some `null` values.","code":["var tuple = Tuple.ofNullable(Integer, 1, null, 3, null, 5)"]},

        {"kind":"when","text":"We map the tuple to a new tuple.","code":["var result = tuple.mapTo(String, { it?.toString() })"]},

        {"kind":"then","text":"The result is a nullable tuple.","code":["result == Tuple.ofNullable(String, \"1\", null, \"3\", null, \"5\")"]},

        {"kind":"when","text":"We now map the `null` entries to something else.","code":["result = result.mapTo(String, { it == null ? \"?\" : it })"]},

        {"kind":"then","text":"The result is still a nullable tuple, but with different contents.","code":["result == Tuple.ofNullable(String, \"1\", \"?\", \"3\", \"?\", \"5\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple of strings.","code":["var tuple = Tuple.of(String, \"hello\", \"world\")"]},

        {"kind":"when","text":"We try to add a `null` value at the beginning of the tuple.","code":["tuple = tuple.addIfNonNullAt(0, null)"]},

        {"kind":"then","text":"The tuple remains unchanged.","code":["tuple == Tuple.of(String, \"hello\", \"world\")"]},

        {"kind":"when","text":"We try to add a `null` value at the end of the tuple.","code":["tuple = tuple.addIfNonNullAt(2, null)"]},

        {"kind":"then","text":"The tuple remains unchanged.","code":["tuple == Tuple.of(String, \"hello\", \"world\")"]},

        {"kind":"when","text":"Finally, we try to add something which is not `null`.","code":["tuple = tuple.addIfNonNullAt(1, \"little\")"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple == Tuple.of(String, \"hello\", \"little\", \"world\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"That\", \"day\", \"is\", \"a\" ,\"very\", \"very\", \"nice\", \"day\")"]},

        {"kind":"when","text":"We remove all non-null occurrences of the word \"very\".","code":["words = words.removeIfNonNull(\"very\")"]},

        {"kind":"then","text":"All non-null occurrences of the word \"very\" were removed.","code":["words == Tuple.of(\"That\", \"day\", \"is\", \"a\", \"nice\", \"day\")"]},

        {"kind":"when","text":"We call the method with a `null` argument.","code":["words = words.removeIfNonNull(null)"]},

        {"kind":"then","text":"The tuple remains unchanged.","code":["words == Tuple.of(\"That\", \"day\", \"is\", \"a\", \"nice\", \"day\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove all occurrences of the numbers 2 and 4.","code":["numbers = numbers.removeAll(2, 4)"]},

        {"kind":"then","text":"All occurrences of the numbers 2 and 4 were removed.","code":["numbers == Tuple.of(7, 3, 7)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove all occurrences of the numbers 2 and 4.","code":["numbers = numbers.removeAll(Tuple.of(2, 4))"]},

        {"kind":"then","text":"All occurrences of the numbers 2 and 4 were removed.","code":["numbers == Tuple.of(7, 3, 7)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove all occurrences of the numbers 2 and 4.","code":["numbers = numbers.removeAll([2, 4])"]},

        {"kind":"then","text":"All occurrences of the numbers 2 and 4 were removed.","code":["numbers == Tuple.of(7, 3, 7)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll(T...)` method retains only the given elements in the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We retain only the numbers 2 and 4.","code":["numbers = numbers.retainAll(2, 4)"]},

        {"kind":"then","text":"Only all the numbers 2 and 4 are left over.","code":["numbers == Tuple.of(4, 2, 2, 4, 2, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll(Tuple<T>)` method retains only the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We retain only the numbers 2 and 4.","code":["numbers = numbers.retainAll(Tuple.of(2, 4))"]},

        {"kind":"then","text":"Only the numbers 2 and 4 are left over.","code":["numbers == Tuple.of(4, 2, 2, 4, 2, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll(Iterable<T>)` method retains only the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We retain only the numbers 2 and 4.","code":["numbers = numbers.retainAll([2, 4])"]},

        {"kind":"then","text":"Only the numbers 2 and 4 are left over.","code":["numbers == Tuple.of(4, 2, 2, 4, 2, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Internally, a tuple has a sort of signature to determine the line of succession.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var root = Tuple.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)","var left = root.slice(0, 5)","var right = root.slice(5, 10)","var left2 = left.slice(0, 3)","var right2 = left.slice(3, 5)"]},

        {"kind":"when","text":"","code":["var rootDiff = (root as SequenceDiffOwner).differenceFromPrevious().get()","var leftDiff = (left as SequenceDiffOwner).differenceFromPrevious().get()","var rightDiff = (right as SequenceDiffOwner).differenceFromPrevious().get()","var left2Diff = (left2 as SequenceDiffOwner).differenceFromPrevious().get()","var right2Diff = (right2 as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"","code":["leftDiff.isDirectSuccessorOf(rootDiff)","rightDiff.isDirectSuccessorOf(rootDiff)","left2Diff.isDirectSuccessorOf(leftDiff)","right2Diff.isDirectSuccessorOf(leftDiff)"]},

        {"kind":"and","text":"","code":["!leftDiff.isDirectSuccessorOf(rightDiff)","!rightDiff.isDirectSuccessorOf(leftDiff)","!left2Diff.isDirectSuccessorOf(right2Diff)","!right2Diff.isDirectSuccessorOf(left2Diff)"]},

        {"kind":"and","text":"","code":["!rootDiff.isDirectSuccessorOf(leftDiff)","!rootDiff.isDirectSuccessorOf(rightDiff)","!rootDiff.isDirectSuccessorOf(left2Diff)","!rootDiff.isDirectSuccessorOf(right2Diff)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Any kind of tuple can be sorted. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports sorting of its instances.\n            You can created a sorted copy of a tuple by calling the `sort()` method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We sort the tuple through its `sort` method and then also through the Java list.","code":["var sorted = aTuple.sort()","var javaSorted = new ArrayList(aTuple.toList()).sort()"]},

        {"kind":"then","text":"The sorting works exactly like for lists.","code":["sorted.toList() == javaSorted"]},

        {"kind":"where","text":"","code":{"aTuple":["Tuple.of(Byte, 3 as byte, -2 as byte, 13 as byte, -5 as byte, 0 as byte)","Tuple.of(Short, -1 as short, 4 as short, 7 as short, 1 as short, 2 as short)","Tuple.of(Integer, 3, 1, -5, 97, 6, 2, 1, 4, -6, 15, 3, 6, 12)","Tuple.of(Long, 9L, 22L, 8L, 6L, -1L, 13L, 3L, -5L, 1L, 7L)","Tuple.of(Float, -7.0f, -1.5f, 2.0f, 8.4f, -9.0f, 15.0f, -3.0f, 4.0f, -5.0f, 6.0f)","Tuple.of(Double, 8d, -3.23d, 19.9d, -2.9d, -1.2d, 0.0d, 3.0d, 1.3d, 1.5d, 4.23d)","Tuple.of(BigDecimal, 8.0, -3.23, 19.9, -2.9, -1.2, 0.0, 3.0, 1.3, 1.5, 4.23)","Tuple.of(BigInteger, 8 as BigInteger, -3 as BigInteger, 19 as BigInteger, -2 as BigInteger)","Tuple.of(Character, 'a' as char, '%' as char, 'Z' as char, '0' as char, '9' as char)","Tuple.of(Boolean, true, true, false, true, false, true, false, false, false, true, false)","Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `firstIndexOf` and `lastIndexOf` to find the first and last occurrence of an element.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"It\", \"is\", \"very\", \"very\", \"important\", \"to\", \"watch\", \"dominion\")"]},

        {"kind":"when","text":"We find the first and last occurrence of the word \"very\".","code":["var firstIndex = words.firstIndexOf(\"very\")","var lastIndex = words.lastIndexOf(\"very\")"]},

        {"kind":"then","text":"The first and last occurrence of the word \"very\" are found.","code":["firstIndex == 2","lastIndex == 3"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `firstIndexStartingFrom` to only look for an element after a certain index.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"Actually\", \"live\", \"and\", \"let\", \"live\", \"please\")"]},

        {"kind":"when","text":"We query the index starting from every index in the tuple:","code":["var indexAfter0 = words.firstIndexStartingFrom(0, \"live\")","var indexAfter1 = words.firstIndexStartingFrom(1, \"live\")","var indexAfter2 = words.firstIndexStartingFrom(2, \"live\")","var indexAfter3 = words.firstIndexStartingFrom(3, \"live\")","var indexAfter4 = words.firstIndexStartingFrom(4, \"live\")","var indexAfter5 = words.firstIndexStartingFrom(5, \"live\")"]},

        {"kind":"then","text":"The indices are found as expected.","code":["indexAfter0 == 1","indexAfter1 == 1","indexAfter2 == 4","indexAfter3 == 4","indexAfter4 == 4","indexAfter5 == -1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `lastIndexBefore` to only look for an element before a certain index.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"Actually\", \"live\", \"and\", \"let\", \"live\", \"please\")"]},

        {"kind":"when","text":"We query the index before every index in the tuple:","code":["var indexBefore0 = words.lastIndexBefore(0, \"live\")","var indexBefore1 = words.lastIndexBefore(1, \"live\")","var indexBefore2 = words.lastIndexBefore(2, \"live\")","var indexBefore3 = words.lastIndexBefore(3, \"live\")","var indexBefore4 = words.lastIndexBefore(4, \"live\")","var indexBefore5 = words.lastIndexBefore(5, \"live\")"]},

        {"kind":"then","text":"The indices are found as expected.","code":["indexBefore0 == -1","indexBefore1 == -1","indexBefore2 == 1","indexBefore3 == 1","indexBefore4 == 1","indexBefore5 == 4"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `indicesOf` method returns all indices of an element in the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"Actually\", \"live\", \"and\", \"let\", \"live\", \"please\")"]},

        {"kind":"when","text":"We query the indices of the word \"live\".","code":["var indices = words.indicesOf(\"live\")"]},

        {"kind":"then","text":"The indices are found as expected.","code":["indices == Tuple.of(1, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `indicesOf(T)` to get the indices of all occurrences of a tuple of integers.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `indicesOf` method returns a list of all the indices of a given tuple.\n            If the property is not in the list, an empty tuple is returned.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A `Vars` instance with some properties.","code":["var ints = Tuple.of(1, 2, 3, 2, 4, 2, 5)"]},

        {"kind":"when","text":"We get the indices of the property `2`.","code":["var indices = ints.indicesOf(2)"]},

        {"kind":"then","text":"The indices of the property `2` are returned.","code":["indices == Tuple.of(1, 3, 5)"]},

        {"kind":"when","text":"We get the indices of the property `6`.","code":["var indices2 = ints.indicesOf(6)"]},

        {"kind":"then","text":"An empty list is returned.","code":["indices2 == Tuple.of(Integer)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Tuple` class support all kinds of nullable types. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports null items when using\n            the `Tuple.ofNullable` factory method.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An empty tuple for the given type.","code":["var tuple = Tuple.ofNullable(itemType)"]},

        {"kind":"expect","text":"The tuple is empty and reports the correct type and nullability.","code":["tuple.isEmpty()","tuple.allowsNull()","tuple.type() == itemType"]},

        {"kind":"when","text":"We add some items to the tuple.","code":["for (var item : items) {","    tuple = tuple.add(item)","}"]},

        {"kind":"then","text":"","code":["tuple.size() == items.size()","tuple.toList() == items"]},

        {"kind":"where","text":"We use the following table to test different nullable types.","code":{"itemType":["Integer","String","Boolean","Double","Float","Long","Short","Byte","Character","BigDecimal","BigInteger"],"items":["[1, 2, 3, null, 5, 6, 7]","[\"hello\", \"world\", null, \"from\", \"Sprouts\"]","[true, false, null, true, false, true]","[1d, 2d, 3d, null, 5d, 6d, 7d]","[1.0f, 2.0f, 3.0f, null, 5.0f, 6.0f, 7.0f]","[1L, 2L, 3L, null, 5L, 6L, 7L]","[1 as short, 2 as short, 3 as short, null, 5 as short, 6 as short, 7 as short]","[1 as byte, 2 as byte, 3 as byte, null, 5 as byte, 6 as byte, 7 as byte]","['a' as char, 'b' as char, 'c' as char, null, 'e' as char, 'f' as char, 'g' as char]","[BigDecimal.ONE, BigDecimal.TEN, null, BigDecimal.ZERO, BigDecimal.ONE.negate()]","[BigInteger.ONE, BigInteger.TEN, null, BigInteger.ZERO, BigInteger.ONE.negate()]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can be converted to a `ValueSet`. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class can be converted to a `ValueSet`, which is an immutable collection\n            of unique values without any particular order.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We convert the tuple to a `ValueSet`.","code":["var valueSet = input.toValueSet()"]},

        {"kind":"then","text":"The `ValueSet` has the expected contents.","code":["valueSet == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 1, 2, 3)","Tuple.of(\"hello\", \"world\")","Tuple.of(\"a\", \"b\", \"a\")","Tuple.of(.5, .1, .3, .6, .1, .1, .2, .3, .4)"],"expected":["ValueSet.of(1, 2, 3)","ValueSet.of(1, 2, 3)","ValueSet.of(\"hello\", \"world\")","ValueSet.of(\"a\", \"b\")","ValueSet.of(.1, .2, .3, .4, .5, .6)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can be converted to a `ValueSet`. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class can be converted to a `ValueSet`, which is an immutable collection\n            of unique values without any particular order.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We convert the tuple to a `ValueSet`.","code":["var valueSet = input.toValueSet()"]},

        {"kind":"then","text":"The `ValueSet` has the expected contents.","code":["valueSet == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 1, 2, 3)","Tuple.of(\"hello\", \"world\")","Tuple.of(\"a\", \"b\", \"a\")","Tuple.of(.5, .1, .3, .6, .1, .1, .2, .3, .4)"],"expected":["ValueSet.of(1, 2, 3)","ValueSet.of(1, 2, 3)","ValueSet.of(\"hello\", \"world\")","ValueSet.of(\"a\", \"b\")","ValueSet.of(.1, .2, .3, .4, .5, .6)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can be converted to a `ValueSet`. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class can be converted to a `ValueSet`, which is an immutable collection\n            of unique values without any particular order.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We convert the tuple to a `ValueSet`.","code":["var valueSet = input.toValueSet()"]},

        {"kind":"then","text":"The `ValueSet` has the expected contents.","code":["valueSet == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 1, 2, 3)","Tuple.of(\"hello\", \"world\")","Tuple.of(\"a\", \"b\", \"a\")","Tuple.of(.5, .1, .3, .6, .1, .1, .2, .3, .4)"],"expected":["ValueSet.of(1, 2, 3)","ValueSet.of(1, 2, 3)","ValueSet.of(\"hello\", \"world\")","ValueSet.of(\"a\", \"b\")","ValueSet.of(.1, .2, .3, .4, .5, .6)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can be converted to a `ValueSet`. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class can be converted to a `ValueSet`, which is an immutable collection\n            of unique values without any particular order.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We convert the tuple to a `ValueSet`.","code":["var valueSet = input.toValueSet()"]},

        {"kind":"then","text":"The `ValueSet` has the expected contents.","code":["valueSet == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 1, 2, 3)","Tuple.of(\"hello\", \"world\")","Tuple.of(\"a\", \"b\", \"a\")","Tuple.of(.5, .1, .3, .6, .1, .1, .2, .3, .4)"],"expected":["ValueSet.of(1, 2, 3)","ValueSet.of(1, 2, 3)","ValueSet.of(\"hello\", \"world\")","ValueSet.of(\"a\", \"b\")","ValueSet.of(.1, .2, .3, .4, .5, .6)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can be converted to a `ValueSet`. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class can be converted to a `ValueSet`, which is an immutable collection\n            of unique values without any particular order.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We convert the tuple to a `ValueSet`.","code":["var valueSet = input.toValueSet()"]},

        {"kind":"then","text":"The `ValueSet` has the expected contents.","code":["valueSet == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 1, 2, 3)","Tuple.of(\"hello\", \"world\")","Tuple.of(\"a\", \"b\", \"a\")","Tuple.of(.5, .1, .3, .6, .1, .1, .2, .3, .4)"],"expected":["ValueSet.of(1, 2, 3)","ValueSet.of(1, 2, 3)","ValueSet.of(\"hello\", \"world\")","ValueSet.of(\"a\", \"b\")","ValueSet.of(.1, .2, .3, .4, .5, .6)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `setAllAt( int index, T... items )` method will set the items at the given index.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"Dominion\", \"is\", \"a\", \"very\" ,\"interesting\", \"documentary\")"]},

        {"kind":"when","text":"We set the items at index 2.","code":["words = words.setAllAt(3, \"must\", \"watch\")"]},

        {"kind":"then","text":"The items were set at the given index.","code":["words == Tuple.of(\"Dominion\", \"is\", \"a\", \"must\", \"watch\", \"documentary\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `setAllAt( int index, Iterable<T> items )` method will set the items at the given index.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"Earthlings\", \"is\", \"a\", \"very\" ,\"interesting\", \"documentary\")"]},

        {"kind":"when","text":"We set the items at index 2.","code":["words = words.setAllAt(3, [\"must\", \"watch\"])"]},

        {"kind":"then","text":"The items were set at the given index.","code":["words == Tuple.of(\"Earthlings\", \"is\", \"a\", \"must\", \"watch\", \"documentary\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `setAt( int index, int size, T item )` to spread a single item across a range.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"Education\", \"is\", \"so\", \"unbelievably\", \"important\")"]},

        {"kind":"when","text":"We set the items at index 2.","code":["words = words.setAt(2, 2, \"very\")"]},

        {"kind":"then","text":"The items were set at the given index.","code":["words == Tuple.of(\"Education\", \"is\", \"very\", \"very\", \"important\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The string representation of a tuple with more than 10 items is truncated.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with more than 10 items.","code":["var tuple = Tuple.of(Byte, (-8..8).collect { it as byte })"]},

        {"kind":"when","text":"We convert the tuple to a string.","code":["var asString = tuple.toString()"]},

        {"kind":"then","text":"The string representation is truncated to 10 items.","code":["asString == \"Tuple<Byte>[-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, ... 7 items left]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The Tuple type supports holding `null` values when using `Tuple.ofNullable`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A `Character` variable explicitly set to null:","code":["Character iAmNull = null"]},

        {"kind":"and","text":"We create a tuple from that single `null` item.","code":["var tuple = Tuple.ofNullable(Character, (Character)iAmNull)"]},

        {"kind":"expect","text":"The tuple has a single `null` item and allows nulls.","code":["tuple.size() == 1","tuple.get(0) == null","tuple.allowsNull()","tuple.type() == Character"]},

        {"kind":"when","text":"We add a non-null item to the tuple.","code":["tuple = tuple.add('A' as char)"]},

        {"kind":"then","text":"The tuple now has two items, one of which is `null`.","code":["tuple.size() == 2","tuple.get(0) == null","tuple.get(1) == 'A' as char"]},

        {"kind":"when","text":"We add another `null` item to the tuple.","code":["tuple = tuple.add(null)"]},

        {"kind":"then","text":"The tuple now has three items, two of which are `null`.","code":["tuple.size() == 3","tuple.get(0) == null","tuple.get(1) == 'A' as char","tuple.get(2) == null"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can create a tuple from an array of primitive floats, and then update it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In order to be as fast and memory efficient as possible, the `Tuple` type is \n            also designed to function as a thin wrapper around arrays of primitive types.<br>\n            This means that when you construct a tuple using `Tuple.of(float[])`,\n            then the returned tuple will be backed by a single array of primitive floats,\n            which is a simple clone of the original array.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An array of primitive floats and a clone of it.","code":["float[] original = (-500f..500f).collect({it/25f}) as float[]","float[] floats = original.clone()"]},

        {"kind":"and","text":"We create a tuple from the array.","code":["var tuple = Tuple.of(original)"]},

        {"kind":"expect","text":"The tuple has the expected size and contents.","code":["tuple.size() == original.length","tuple.toList() == original.toList()"]},

        {"kind":"when","text":"We try to violate the immutability of the tuple by modifying the original array.","code":["floats.length.times {  original[it] = Float.NaN }"]},

        {"kind":"then","text":"The tuple is not affected by the change to the original array.","code":["tuple.none { it == Float.NaN }"]},

        {"kind":"when","text":"We update the tuple by removing a range of items.","code":["tuple = tuple.removeRange(50, 150)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the removal.","code":["tuple.size() == 901","tuple.toList() == floats[0..49] + floats[150..-1] as List<Float>"]},

        {"kind":"when","text":"We update the tuple by adding a range of items.","code":["tuple = tuple.addAllAt(50, 1000f, 1001f, 1002f)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the addition.","code":["tuple.size() == 904","tuple.toList() == (floats[0..49] + [1000f, 1001f, 1002f] + floats[150..-1]) as List<Float>"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can create a tuple from an array of primitive doubles, and then update it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In order to be as fast and memory efficient as possible, the `Tuple` type is \n            also designed to function as a thin wrapper around arrays of primitive types.<br>\n            This means that when you construct a tuple using `Tuple.of(double[])`,\n            then the returned tuple will be backed by a single array of primitive doubles,\n            which is a simple clone of the original array.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An array of primitive doubles and a clone of the array.","code":["double[] original = (-500d..500d).collect({it/25d}) as double[]","double[] doubles = original.clone()"]},

        {"kind":"and","text":"We create a tuple from the array.","code":["var tuple = Tuple.of(original)"]},

        {"kind":"expect","text":"The tuple has the expected size and contents.","code":["tuple.size() == doubles.length","tuple.toList() == doubles.toList()"]},

        {"kind":"when","text":"We try to violate the immutability of the tuple by modifying the original array.","code":["doubles.length.times {  original[it] = Double.NaN }"]},

        {"kind":"then","text":"The tuple is not affected by the change to the original array.","code":["tuple.none { it == Double.NaN }"]},

        {"kind":"when","text":"We update the tuple by removing a range of items.","code":["tuple = tuple.removeRange(50, 150)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the removal.","code":["tuple.size() == 901","tuple.toList() == doubles[0..49] + doubles[150..-1] as List<Double>"]},

        {"kind":"when","text":"We update the tuple by adding a range of items.","code":["tuple = tuple.addAllAt(50, 1000d, 1001d, 1002d)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the addition.","code":["tuple.size() == 904","tuple.toList() == (doubles[0..49] + [1000d, 1001d, 1002d] + doubles[150..-1]) as List<Double>"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can create a tuple from an array of primitive ints, and then update it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In order to be as fast and memory efficient as possible, the `Tuple` type is \n            also designed to function as a thin wrapper around arrays of primitive types.<br>\n            This means that when you construct a tuple using `Tuple.of(int[])`,\n            then the returned tuple will be backed by a single array of primitive ints,\n            which is a simple clone of the original array.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An array of primitive ints and its clone.","code":["int[] original = (-500..500) as int[]","int[] ints = original.clone()"]},

        {"kind":"and","text":"We create a tuple from the array.","code":["var tuple = Tuple.of(ints)"]},

        {"kind":"expect","text":"The tuple has the expected size and contents.","code":["tuple.size() == ints.length","tuple.toList() == ints.toList()"]},

        {"kind":"when","text":"We try to violate the immutability of the tuple by modifying the original array.","code":["ints.length.times { original[it] = Integer.MIN_VALUE }"]},

        {"kind":"then","text":"The tuple is not affected by the change to the original array.","code":["tuple.none { it == Integer.MIN_VALUE }"]},

        {"kind":"when","text":"We update the tuple by removing a range of items.","code":["tuple = tuple.removeRange(50, 150)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the removal.","code":["tuple.size() == 901","tuple.toList() == ints[0..49] + ints[150..-1] as List<Integer>"]},

        {"kind":"when","text":"We update the tuple by adding a range of items.","code":["tuple = tuple.addAllAt(50, 1000, 1001, 1002)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the addition.","code":["tuple.size() == 904","tuple.toList() == (ints[0..49] + [1000, 1001, 1002] + ints[150..-1]) as List<Integer>"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can create a tuple from an array of primitive bytes, and then update it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In order to be as fast and memory efficient as possible, the `Tuple` type is \n            also designed to function as a thin wrapper around arrays of primitive types.<br>\n            This means that when you construct a tuple using `Tuple.of(byte[])`,\n            then the returned tuple will be backed by a single array of primitive bytes,\n            which is a simple clone of the original array.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An array of primitive bytes.","code":["byte[] bytes = (-500..500).collect { it as byte } as byte[]"]},

        {"kind":"and","text":"We create a tuple from the array.","code":["var tuple = Tuple.of(bytes)"]},

        {"kind":"expect","text":"The tuple has the expected size and contents.","code":["tuple.size() == bytes.length","tuple.toList() == bytes.toList()"]},

        {"kind":"when","text":"We update the tuple by removing a range of items.","code":["tuple = tuple.removeRange(50, 150)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the removal.","code":["tuple.size() == 901","tuple.toList() == bytes[0..49] + bytes[150..-1] as List<Byte>"]},

        {"kind":"when","text":"We update the tuple by adding a range of items.","code":["tuple = tuple.addAllAt(50, 1000 as byte, 1001 as byte, 1002 as byte)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the addition.","code":["tuple.size() == 904","tuple.toList() == (bytes[0..49] + [1000 as byte, 1001 as byte, 1002 as byte] + bytes[150..-1]) as List<Byte>"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"We can create a tuple from an array of primitive longs, and then update it.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            In order to be as fast and memory efficient as possible, the `Tuple` type is \n            also designed to function as a thin wrapper around arrays of primitive types.<br>\n            This means that when you construct a tuple using `Tuple.of(long[])`,\n            then the returned tuple will be backed by a single array of primitive longs,\n            which is a simple clone of the original array.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An array of primitive longs.","code":["long[] longs = (-500L..500L) as long[]"]},

        {"kind":"and","text":"We create a tuple from the array.","code":["var tuple = Tuple.of(longs)"]},

        {"kind":"expect","text":"The tuple has the expected size and contents.","code":["tuple.size() == longs.length","tuple.toList() == longs.toList()"]},

        {"kind":"when","text":"We update the tuple by removing a range of items.","code":["tuple = tuple.removeRange(50, 150)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the removal.","code":["tuple.size() == 901","tuple.toList() == longs[0..49] + longs[150..-1] as List<Long>"]},

        {"kind":"when","text":"We update the tuple by adding a range of items.","code":["tuple = tuple.addAllAt(50, 1000L, 1001L, 1002L)"]},

        {"kind":"then","text":"The tuple has the expected size and contents after the addition.","code":["tuple.size() == 904","tuple.toList() == (longs[0..49] + [1000L, 1001L, 1002L] + longs[150..-1]) as List<Long>"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two tuple instances are equal even if they were created and transformed separately.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class is designed to have robust\n            value equality semantics.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"Two tuples with the same contents.","code":["var tuple1 = Tuple.of(Integer, 1, 2, 3, 4, 5)","var tuple2 = Tuple.of(1, 2, 3, 4, 5)"]},

        {"kind":"expect","text":"The two tuples are equal.","code":["tuple1 == tuple2","tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We transform the first tuple by adding an item.","code":["tuple1 = tuple1.add(6)"]},

        {"kind":"then","text":"The two tuples are no longer equal.","code":["tuple1 != tuple2","tuple1.hashCode() != tuple2.hashCode()"]},

        {"kind":"when","text":"We transform the second tuple by adding the same item.","code":["tuple2 = tuple2.add(6)"]},

        {"kind":"then","text":"The two tuples are now equal again.","code":["tuple1 == tuple2","tuple1.hashCode() == tuple2.hashCode()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `Tuple` can handle all kinds of item types. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(type, items)","var list = items as List"]},

        {"kind":"expect","text":"","code":["tuple.type() == type"]},

        {"kind":"when","text":"","code":["var tuple2 = tuple.slice(1, 5)","var tuple3 = tuple.reversed()","var tuple4 = tuple.makeDistinct()","var tupleResult = tuple2.addAll(tuple3).addAll(tuple4)"]},

        {"kind":"and","text":"","code":["var list2 = list.subList(1, 5)","var list3 = list.reverse()","var list4 = list.stream().distinct().collect(Collectors.toList())","var listResult = list2 + list3 + list4"]},

        {"kind":"then","text":"","code":["tupleResult.toList() == listResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a Tuple work reliably for a large number of items. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create two different \"different\" `Tuple` instances from the a single list...","code":["var tuple1 = Tuple.of(type, items)","var tuple2 = Tuple.of(type, items)"]},

        {"kind":"expect","text":"The two sets are not equal!","code":["tuple1.equals(tuple2)"]},

        {"kind":"and","text":"They also have do not have the same hash codes:","code":["tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two tuples...","code":["var randomItem = items[Math.abs(items.hashCode()*1997)%items.size()]","int index1 = tuple1.firstIndexOf(randomItem)","int index2 = tuple2.firstIndexOf(randomItem)","var modifiedTuple1 = tuple1.remove(randomItem)","var modifiedTuple2 = tuple2.remove(randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedTuple1.equals(tuple1)","!modifiedTuple2.equals(tuple2)","!modifiedTuple1.equals(tuple2)","!modifiedTuple2.equals(tuple1)","modifiedTuple1.equals(modifiedTuple2)"]},

        {"kind":"when","text":"We put back in the old item to restore the previous states...","code":["var restoredTuple1 = modifiedTuple1.addAt(index1, randomItem)","var restoredTuple2 = modifiedTuple2.addAt(index2, randomItem)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredTuple1.equals(modifiedTuple1)","!restoredTuple2.equals(modifiedTuple2)","!restoredTuple1.equals(modifiedTuple2)","!restoredTuple2.equals(modifiedTuple1)","restoredTuple1.equals(restoredTuple2)","restoredTuple1.equals(tuple1)","restoredTuple2.equals(tuple2)","restoredTuple1.equals(tuple2)","restoredTuple2.equals(tuple1)"]},

        {"kind":"when","text":"We create smaller version of the two tuples by removing something...","code":["var randomElement2 = items[Math.abs(items.hashCode()*31)%items.size()]","var smallerTuple1 = tuple1.remove(randomElement2)","var smallerTuple2 = tuple2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerTuple1.equals(tuple1)","!smallerTuple2.equals(tuple2)","!smallerTuple1.equals(tuple2)","!smallerTuple2.equals(tuple1)","smallerTuple1.equals(smallerTuple2)"]},

        {"kind":"and","text":"","code":["smallerTuple1.hashCode() != tuple1.hashCode()","smallerTuple2.hashCode() != tuple2.hashCode()","smallerTuple1.hashCode() != tuple2.hashCode()","smallerTuple2.hashCode() != tuple1.hashCode()","smallerTuple1.hashCode() == smallerTuple2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"items":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
