{
  "className":"sprouts.Tuple_Spec",
  "title":"Tuples for Functional Programming",
  "narrative":"Functional programming is a core concept in Sprouts,\n    which is why we provide the `Tuple` type representing\n    an immutable array of elements which can be transformed\n    and filtered in a functional way.",
  "subjects":["sprouts.Tuple"],
  "statistics":{
    "runs":"171",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"A tuple has various operations for functional transformation. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A tuple has various operations for functional transformation. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"\n            We first start off by turning the input to the operation\n            to a new list, so that we effectively have a snapshot of the\n            initial state of the input.\n        ","code":["var initialState = new ArrayList<>(input.toList())"]},

        {"kind":"when","text":"We now apply an operation on the input to produce a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result has the expected state:","code":["result == expected"]},

        {"kind":"and","text":"\n            According to the requirements of immutability, the input should remain unchanged.\n            So we take the previously made snapshot and check if the 'toList()' method\n            still produces a list with the same items in it.\n        ","code":["input.toList() == initialState"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)","Tuple.of(1, 2)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }","{ tuple -> tuple.makeDistinct() }","{ tuple -> tuple.addIfNonNull(null) }","{ tuple -> tuple.addIfNonNull(3) }","{ tuple -> tuple.addIfNonNullAt(1,null) }","{ tuple -> tuple.addIfNonNullAt(1,3) }"],"expected":["Tuple.of(Byte)","Tuple.of(3, 2, 1)","Tuple.of(2, 1, 0)","Tuple.of(3, 2, 1)","Tuple.of(1, 2, 3)","Tuple.of(2, 4, 6)","Tuple.of(\"3 cents\", \"6 cents\")","Tuple.of(2, 3)","Tuple.of(1)","Tuple.of(3, 4)","Tuple.of(1, 5)","Tuple.of(2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 4, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 4, 5)","Tuple.of(1, 10, 3, 4, 5)","Tuple.of(1, 10, 2, 3, 4, 5)","Tuple.of(1, 3, 4, 5)","Tuple.of(1, 4, 5)","Tuple.of(1, 2, 3, 4, 5, 10)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(1, 2, 3, 10, 20)","Tuple.of(Integer)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1, 10, 20, 2, 3)","Tuple.of(1)","Tuple.of(2, 3)","Tuple.of(1, 2, 5)","Tuple.of(2, 3, 4)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 2, 3)","Tuple.of(1, 2)","Tuple.of(1, 3, 2)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The tuple predicates behave as expected. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We test the predicate on the input.","code":["var result = predicate.test(input)"]},

        {"kind":"then","text":"The result has the expected truth value.","code":["result == expected"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(Byte)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.ofNullable(Integer, 1, null, 3)"],"predicate":["Tuple::isEmpty","Tuple::isEmpty","Tuple::isNotEmpty","Tuple::isNotEmpty","{ tuple -> tuple.all { it > 0 } }","{ tuple -> tuple.all { it > 1 } }","{ tuple -> tuple.any { it > 0 } }","{ tuple -> tuple.any { it > 1 } }","{ tuple -> tuple.any { it == null } }","{ tuple -> tuple.none { it > 0 } }","{ tuple -> tuple.none { it > 1 } }","{ tuple -> tuple.anyNull() }","{ tuple -> tuple.anyNull() }"],"expected":["true","false","false","true","true","false","true","true","true","false","false","false","true"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Tuple implementations know about their last operation. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We apply an operation on the input and get a result.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result tuple implements an interface for accessing the last operation.","code":["result instanceof SequenceDiffOwner"]},

        {"kind":"and","text":"The last operation exists, because the result is a product of an operation.","code":["(result as SequenceDiffOwner).differenceFromPrevious().isPresent()"]},

        {"kind":"when","text":"We access the operation information...","code":["var diff = (result as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"...we get the expected values.","code":["diff.change() == change","diff.index().orElse(-1) == index","diff.size() == count"]},

        {"kind":"where","text":"The use the following input, operation, and expected change information.","code":{"input":["Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(3, 2, 1, 0)","Tuple.of(3, 2, 1, 0)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(3, 6)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3, 4, 5)","Tuple.of(1, 2, 3, 4, 5)"],"operation":["Tuple::reversed","Tuple::reversed","Tuple::removeFirst","Tuple::removeLast","{ tuple -> tuple.map { it } }","{ tuple -> tuple.map { it * 2 } }","{ tuple -> tuple.mapTo(String,{it+\" cents\"}) }","{ tuple -> tuple.retainIf { it > 1 } }","{ tuple -> tuple.retainIf { it < 2 } }","{ tuple -> tuple.retainIf { it > 2 && it < 5 } }","{ tuple -> tuple.retainIf { it < 2 || it > 4 } }","{ tuple -> tuple.slice(1, 3) }","{ tuple -> tuple.sliceFirst(3) }","{ tuple -> tuple.sliceLast(3) }","{ tuple -> tuple.sliceAt(1, 3) }","{ tuple -> tuple.removeRange(1, 3) }","{ tuple -> tuple.setAt(1, 10) }","{ tuple -> tuple.addAt(1, 10) }","{ tuple -> tuple.removeAt(1) }","{ tuple -> tuple.removeAt(1, 2) }","{ tuple -> tuple.add(10) }","{ tuple -> tuple.addAll(10, 20) }","{ tuple -> tuple.addAll(Tuple.of(10, 20)) }","{ tuple -> tuple.addAll([10, 20]) }","{ tuple -> tuple.clear() }","{ tuple -> tuple.addAllAt(1, 10, 20) }","{ tuple -> tuple.addAllAt(1, Tuple.of(10, 20)) }","{ tuple -> tuple.addAllAt(1, [10, 20]) }","{ tuple -> tuple.removeIf { it > 1 } }","{ tuple -> tuple.removeIf { it < 2 } }","{ tuple -> tuple.removeIf { it > 2 && it < 5 } }","{ tuple -> tuple.removeIf { it < 2 || it > 4 } }"],"change":["SequenceChange.REVERSE","SequenceChange.REVERSE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.SET","SequenceChange.SET","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.RETAIN","SequenceChange.REMOVE","SequenceChange.SET","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.CLEAR","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.ADD","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE","SequenceChange.REMOVE"],"index":["-1","-1","0","3","0","0","0","1","0","2","-1","1","0","2","1","1","1","1","1","1","5","3","3","3","0","1","1","1","1","0","2","-1"],"count":["4","3","1","1","3","3","2","2","1","2","2","2","3","3","3","2","1","1","1","2","1","2","2","2","3","2","2","2","2","1","2","2"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can tell two tuples with different nullability apart from their String representations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A nullable tuple and a non-nullable tuple:","code":["var words1 = Tuple.ofNullable(String).addAll(\"soy milk\", \"\", \"sojamilch\")","var words2 = Tuple.of(String).addAll(\"soy milk\", \"\", \"sojamilch\")"]},

        {"kind":"expect","text":"The tuples have different string representations.","code":["words1.toString() != words2.toString()"]},

        {"kind":"and","text":"These look as follows:","code":["words1.toString() == \"Tuple<String?>[soy milk, , sojamilch]\"","words2.toString() == \"Tuple<String>[soy milk, , sojamilch]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two tuples are equal, even if they were produced by different operations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An initial tuple:","code":["var tuple = Tuple.of(\"a\", \"b\", \"c\")"]},

        {"kind":"and","text":"Two tuples with the same contents, but produced by different operations:","code":["var tuple1 = tuple.reversed().removeFirst().removeLast()","var tuple2 = tuple.removeIf({ it == \"a\" }).removeIf({ it == \"c\" })"]},

        {"kind":"expect","text":"The tuples are equal.","code":["tuple1 == tuple2"]},

        {"kind":"when","text":"Peeking inside, we get the diff objects.","code":["var diff1 = (tuple1 as SequenceDiffOwner).differenceFromPrevious().get()","var diff2 = (tuple2 as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"The diff objects are different.","code":["diff1 != diff2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A nullable tuple is never equal to a non-nullable tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A nullable tuple and a non-nullable tuple:","code":["var tuple1 = Tuple.ofNullable(String)","var tuple2 = Tuple.of(String)"]},

        {"kind":"expect","text":"The tuples are not equal because they have different nullability.","code":["tuple1 != tuple2","tuple1.allowsNull()","!tuple2.allowsNull()"]},

        {"kind":"when","text":"We update both tuples to new ones with the same contents.","code":["tuple1 = tuple1.addAll(\"a\", \"b\", \"c\")","tuple2 = tuple2.addAll(\"a\", \"b\", \"c\")"]},

        {"kind":"then","text":"The tuples are still not equal because one of them allows nulls and the other does not.","code":["tuple1 != tuple2","tuple1.allowsNull()","!tuple2.allowsNull()"]},

        {"kind":"when","text":"We turn the tuples into lists.","code":["var list1 = tuple1.toList()","var list2 = tuple2.toList()"]},

        {"kind":"then","text":"The lists are equal.","code":["list1 == list2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two nullable tuples of the same type are equal, if their contents are equal.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two nullable tuples of the same type:","code":["var words1 = Tuple.ofNullable(String).addAll(\"soy milk\", \"\", \"Sojamilch\")","var words2 = Tuple.ofNullable(String).addAll(\"soy milk\", \"\", \"Sojamilch\")"]},

        {"kind":"expect","text":"The tuples are equal and they also have the same hash code.","code":["words1 == words2","words1.hashCode() == words2.hashCode()"]},

        {"kind":"when","text":"We update both tuples to new ones with the same contents.","code":["words1 = words1.addAll(\"\", \"sojov mlieko\", \" \", \"waiu soya\")","words2 = words2.addAll(\"\", \"sojov mlieko\", \" \", \"waiu soya\")"]},

        {"kind":"then","text":"The tuples are still equal.","code":["words1 == words2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two non-nullable tuples of the same type are equal, if their contents are equal.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two non-nullable tuples of the same type:","code":["var tuple1 = Tuple.of(String).addAll(\"oat milk\", \" \", \"Hafermilch\")","var tuple2 = Tuple.of(String).addAll(\"oat milk\", \" \", \"Hafermilch\")"]},

        {"kind":"expect","text":"The tuples are equal and they also have the same hash code.","code":["tuple1 == tuple2","tuple1.hashCode() == tuple2.hashCode()"]},

        {"kind":"when","text":"We update both tuples to new ones with the same contents.","code":["tuple1 = tuple1.addAll(\"havremjlk\", \"mleko owsiane\", \"waiu oat\")","tuple2 = tuple2.addAll(\"havremjlk\", \"mleko owsiane\", \"waiu oat\")"]},

        {"kind":"then","text":"The tuples are still equal.","code":["tuple1 == tuple2"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [16]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [17]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [18]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [19]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [20]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [21]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [22]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [23]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [24]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [25]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [26]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [27]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [28]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [29]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [30]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [31]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [32]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [33]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [34]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [35]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [36]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [37]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [38]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [39]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [40]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [41]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [42]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will throw an exception if you try to add a null element. [43]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NullPointerException)"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(null) }","{ it.addAll(\"humanity\", null, null) }","{ it.addAll(null, \"progress\", null) }","{ it.addAll(null, null, \"future\") }","{ it.addAll(Tuple.ofNullable(String, null)) }","{ it.addAll(Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAll(Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAll(Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAll(Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAll(null]) }","{ it.addAll(\"humanity\", null, null]) }","{ it.addAll(null, \"progress\", null]) }","{ it.addAll(null, null, \"future\"]) }","{ it.addAll(null, null, null]) }","{ it.addAllAt(0, (Iterable<String>) null) }","{ it.addAllAt(1, \"humanity\", null, null) }","{ it.addAllAt(2, null, \"progress\", null) }","{ it.addAllAt(3, null, null, \"future\") }","{ it.addAllAt(0, Tuple.ofNullable(String, null)) }","{ it.addAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.addAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.addAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.addAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.addAllAt(0, null]) }","{ it.addAllAt(1, \"humanity\", null, null]) }","{ it.addAllAt(2, null, \"progress\", null]) }","{ it.addAllAt(3, null, null, \"future\"]) }","{ it.setAllAt(0, (Iterable<String>) null) }","{ it.setAllAt(1, \"humanity\", null, null) }","{ it.setAllAt(2, null, \"progress\", null) }","{ it.setAllAt(3, null, null, \"future\") }","{ it.setAllAt(0, Tuple.ofNullable(String, null)) }","{ it.setAllAt(1, Tuple.ofNullable(String, \"humanity\", null, null)) }","{ it.setAllAt(2, Tuple.ofNullable(String, null, \"progress\", null)) }","{ it.setAllAt(3, Tuple.ofNullable(String, null, null, \"future\")) }","{ it.setAllAt(0, Tuple.ofNullable(String, \"still nullable!\")) }","{ it.setAllAt(0, null]) }","{ it.setAllAt(1, \"humanity\", null, null]) }","{ it.setAllAt(2, null, \"progress\", null]) }","{ it.setAllAt(3, null, null, \"future\"]) }","{ it.setAt(0, null) }","{ it.setAt(1, null) }","{ it.setAt(2, null) }","{ it.setAt(3, null) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A non-nullable tuple will not throw an exception if you do not try to add nulls to it. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple for the String type.","code":["var niceWords = Tuple.of(String, \"compassion\", \"empathy\", \"mercy\", \"reason\")"]},

        {"kind":"when","text":"We run the tuple through the current operation.","code":["operation.accept(niceWords)"]},

        {"kind":"then","text":"No exception is thrown because in this test we do not try to add nulls.","code":["noExceptionThrown()"]},

        {"kind":"where","text":"","code":{"operation":["{ it.add(\"success\") }","{ it.addAll(\"humanity\", \"progress\", \"future\") }","{ it.addAll(Tuple.of(String, \"humanity\", \"progress\", \"future\")) }","{ it.addAll(Tuple.of(String)) }","{ it.addAllAt(0, Tuple.of(String, \"community\")) }","{ it.setAllAt(0, Tuple.of(String, \"freedom\")) }","{ it.addAt(0, \"consider\") }","{ it.addAt(1, \"mercy\") }","{ it.addAt(2, \"smart\") }","{ it.addAt(3, \"reasoning\") }","{ it.setAt(0, \"think\") }","{ it.setAt(1, \"live\") }","{ it.setAt(2, \"enjoy\") }","{ it.setAt(3, \"kindness\") }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can collect a Java stream of items to a Sprouts tuple natively!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A Java stream of Numbers.","code":["var stream = Stream.of(42, 7 as byte, 3.14d, 2.71f, 999L)"]},

        {"kind":"when","text":"We collect the stream to a Sprouts tuple.","code":["var tuple = stream.collect(Tuple.collectorOf(Number))"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple == Tuple.of(Number, 42, 7 as byte, 3.14d, 2.71f, 999L)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can collect a stream of items into a tuple with a custom collector.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We collect the stream of items into a Sprouts tuple with a custom collector.","code":["var tuple1 = Stream.of(\"hello\", \"world\", \"from\", \"Sprouts\")","                            .collect(Tuple.collectorOf(String))"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple1 == Tuple.of(String, \"hello\", \"world\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We collect the stream of partially null items into a Sprouts tuple with a custom collector.","code":["var tuple2 = Stream.of(\"hello\", null, \"from\", null, \"Sprouts\")","                            .collect(Tuple.collectorOfNullable(String))"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple2 == Tuple.ofNullable(String, \"hello\", null, \"from\", null, \"Sprouts\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Collecting a stream of items with nulls into a non-nullable tuple throws an exception.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We try to collect a stream of items with nulls into a non-nullable tuple.","code":["Stream.of(\"hello\", null, \"from\", null, \"Sprouts\")","      .collect(Tuple.collectorOf(String))"]},

        {"kind":"then","text":"A null pointer exception is thrown.","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `removeFirstFound(T)` method to remove the first occurrence of an element.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"This\", \"day\", \"is\", \"a\" ,\"very\", \"nice\", \"day\")"]},

        {"kind":"when","text":"We remove the first occurrence of the word \"day\".","code":["words = words.removeFirstFound(\"day\")"]},

        {"kind":"then","text":"The first occurrence of the word \"day\" was removed.","code":["words == Tuple.of(\"This\", \"is\", \"a\", \"very\", \"nice\", \"day\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeFirstFoundOrThrow(T)` method will throw an exception if the element is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"hello\", \"world\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.removeFirstFoundOrThrow(\"world\")"]},

        {"kind":"then","text":"The removal was successful.","code":["words == Tuple.of(\"hello\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.removeFirstFoundOrThrow(\"mercy\")"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NoSuchElementException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeFirstFoundOrThrow(Maybe<T>)` method will throw an exception if the element is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"hello\", \"world\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.removeFirstFoundOrThrow(Maybe.of(\"world\"))"]},

        {"kind":"then","text":"The removal was successful.","code":["words == Tuple.of(\"hello\", \"from\", \"Sprouts\")"]},

        {"kind":"when","text":"We try to remove an element that is not present.","code":["words = words.removeFirstFoundOrThrow(Maybe.of(\"mercy\"))"]},

        {"kind":"then","text":"An exception is thrown.","code":["thrown(NoSuchElementException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `remove(T)` method removes every occurrence of the element from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some numeric elements in it.","code":["var numbers = Tuple.of(4, 2, 2, 7, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove the number 2 from the tuple.","code":["numbers = numbers.remove(2)"]},

        {"kind":"then","text":"The number 2 was removed from the tuple.","code":["numbers == Tuple.of(4, 7, 3, 4, 7)"]},

        {"kind":"and","text":"The equality check also works for the list representation.","code":["numbers.toList() == [4, 7, 3, 4, 7]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `remove(Maybe<T>)` method removes every occurrence of the element from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some numeric elements in it.","code":["var numbers = Tuple.of(4, 2, 2, 7, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove the number 2 from the tuple.","code":["numbers = numbers.remove(Maybe.of(2))"]},

        {"kind":"then","text":"The number 2 was removed from the tuple.","code":["numbers == Tuple.of(4, 7, 3, 4, 7)"]},

        {"kind":"and","text":"The equality check also works for the list representation.","code":["numbers.toList() == [4, 7, 3, 4, 7]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Updating a non-nullable tuple with an empty `Maybe` is a no-op. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"We update the tuple with an empty `Maybe`.","code":["var result = operation(input)"]},

        {"kind":"then","text":"The result is the same as the input.","code":["result == input"]},

        {"kind":"where","text":"","code":{"input":["Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)","Tuple.of(1, 2, 3)"],"operation":["{ tuple -> tuple.add(Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAll(Maybe.ofNull(Integer), Maybe.ofNull(Integer)) }","{ tuple -> tuple.addAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAllAt(1, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setAt(1, 2, Maybe.ofNull(Integer)) }","{ tuple -> tuple.setRange(0, 3, Maybe.ofNull(Integer)) }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"It is possible to create and use a tuple of nullable ints.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `Tuple` class supports both nullable and non-nullable tuples.\n            So it is possible to create a nullable tuple of ints.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A nullable tuple of ints.","code":["def tuple = Tuple.ofNullable(Integer, 1, null, 3, 4, null)"]},

        {"kind":"expect","text":"The tuple contains the expected values.","code":["tuple.get(0) == 1","tuple.get(1) == null","tuple.get(2) == 3","tuple.get(3) == 4","tuple.get(4) == null"]},

        {"kind":"when","text":"We turn the tuple into a list.","code":["def list = tuple.toList()"]},

        {"kind":"then","text":"The list also contains the expected values.","code":["list == [1, null, 3, 4, null]"]},

        {"kind":"when","text":"We remove a chunk in the middle of the tuple.","code":["tuple = tuple.removeRange(1, 4)"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple == Tuple.ofNullable(Integer, 1, null)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"When mapping a tuple with `null` values, the result will be a nullable tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some `null` values.","code":["var tuple = Tuple.ofNullable(Integer, 1, null, 3, null, 5)"]},

        {"kind":"when","text":"We map the tuple to a new tuple.","code":["var result = tuple.mapTo(String, { it?.toString() })"]},

        {"kind":"then","text":"The result is a nullable tuple.","code":["result == Tuple.ofNullable(String, \"1\", null, \"3\", null, \"5\")"]},

        {"kind":"when","text":"We now map the `null` entries to something else.","code":["result = result.mapTo(String, { it == null ? \"?\" : it })"]},

        {"kind":"then","text":"The result is still a nullable tuple, but with different contents.","code":["result == Tuple.ofNullable(String, \"1\", \"?\", \"3\", \"?\", \"5\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `addIfNonNullAt` method will not add `null` values to a non-nullable tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A non-nullable tuple of strings.","code":["var tuple = Tuple.of(String, \"hello\", \"world\")"]},

        {"kind":"when","text":"We try to add a `null` value at the beginning of the tuple.","code":["tuple = tuple.addIfNonNullAt(0, null)"]},

        {"kind":"then","text":"The tuple remains unchanged.","code":["tuple == Tuple.of(String, \"hello\", \"world\")"]},

        {"kind":"when","text":"We try to add a `null` value at the end of the tuple.","code":["tuple = tuple.addIfNonNullAt(2, null)"]},

        {"kind":"then","text":"The tuple remains unchanged.","code":["tuple == Tuple.of(String, \"hello\", \"world\")"]},

        {"kind":"when","text":"Finally, we try to add something which is not `null`.","code":["tuple = tuple.addIfNonNullAt(1, \"little\")"]},

        {"kind":"then","text":"The tuple has the expected contents.","code":["tuple == Tuple.of(String, \"hello\", \"little\", \"world\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `removeIfNonNull(@Nullable T)` method to remove all non-null occurrences of an element.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some elements.","code":["var words = Tuple.of(\"That\", \"day\", \"is\", \"a\" ,\"very\", \"very\", \"nice\", \"day\")"]},

        {"kind":"when","text":"We remove all non-null occurrences of the word \"very\".","code":["words = words.removeIfNonNull(\"very\")"]},

        {"kind":"then","text":"All non-null occurrences of the word \"very\" were removed.","code":["words == Tuple.of(\"That\", \"day\", \"is\", \"a\", \"nice\", \"day\")"]},

        {"kind":"when","text":"We call the method with a `null` argument.","code":["words = words.removeIfNonNull(null)"]},

        {"kind":"then","text":"The tuple remains unchanged.","code":["words == Tuple.of(\"That\", \"day\", \"is\", \"a\", \"nice\", \"day\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeAll(T...)` method removes all occurrences of the given elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove all occurrences of the numbers 2 and 4.","code":["numbers = numbers.removeAll(2, 4)"]},

        {"kind":"then","text":"All occurrences of the numbers 2 and 4 were removed.","code":["numbers == Tuple.of(7, 3, 7)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeAll(Tuple<T>)` method removes all occurrences of the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove all occurrences of the numbers 2 and 4.","code":["numbers = numbers.removeAll(Tuple.of(2, 4))"]},

        {"kind":"then","text":"All occurrences of the numbers 2 and 4 were removed.","code":["numbers == Tuple.of(7, 3, 7)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeAll(Iterable<T>)` method removes all occurrences of the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We remove all occurrences of the numbers 2 and 4.","code":["numbers = numbers.removeAll([2, 4])"]},

        {"kind":"then","text":"All occurrences of the numbers 2 and 4 were removed.","code":["numbers == Tuple.of(7, 3, 7)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll(T...)` method retains only the given elements in the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We retain only the numbers 2 and 4.","code":["numbers = numbers.retainAll(2, 4)"]},

        {"kind":"then","text":"Only all the numbers 2 and 4 are left over.","code":["numbers == Tuple.of(4, 2, 2, 4, 2, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll(Tuple<T>)` method retains only the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We retain only the numbers 2 and 4.","code":["numbers = numbers.retainAll(Tuple.of(2, 4))"]},

        {"kind":"then","text":"Only the numbers 2 and 4 are left over.","code":["numbers == Tuple.of(4, 2, 2, 4, 2, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll(Iterable<T>)` method retains only the elements from the tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A tuple with some duplicate elements.","code":["var numbers = Tuple.of(4, 2, 2, 7, 4, 2, 3, 4, 7)"]},

        {"kind":"when","text":"We retain only the numbers 2 and 4.","code":["numbers = numbers.retainAll([2, 4])"]},

        {"kind":"then","text":"Only the numbers 2 and 4 are left over.","code":["numbers == Tuple.of(4, 2, 2, 4, 2, 4)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Internally, a tuple has a sort of signature to determine the line of succession.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var root = Tuple.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)","var left = root.slice(0, 5)","var right = root.slice(5, 10)","var left2 = left.slice(0, 3)","var right2 = left.slice(3, 5)"]},

        {"kind":"when","text":"","code":["var rootDiff = (root as SequenceDiffOwner).differenceFromPrevious().get()","var leftDiff = (left as SequenceDiffOwner).differenceFromPrevious().get()","var rightDiff = (right as SequenceDiffOwner).differenceFromPrevious().get()","var left2Diff = (left2 as SequenceDiffOwner).differenceFromPrevious().get()","var right2Diff = (right2 as SequenceDiffOwner).differenceFromPrevious().get()"]},

        {"kind":"then","text":"","code":["leftDiff.isDirectSuccessorOf(rootDiff)","rightDiff.isDirectSuccessorOf(rootDiff)","left2Diff.isDirectSuccessorOf(leftDiff)","right2Diff.isDirectSuccessorOf(leftDiff)"]},

        {"kind":"and","text":"","code":["!leftDiff.isDirectSuccessorOf(rightDiff)","!rightDiff.isDirectSuccessorOf(leftDiff)","!left2Diff.isDirectSuccessorOf(right2Diff)","!right2Diff.isDirectSuccessorOf(left2Diff)"]},

        {"kind":"and","text":"","code":["!rootDiff.isDirectSuccessorOf(leftDiff)","!rootDiff.isDirectSuccessorOf(rightDiff)","!rootDiff.isDirectSuccessorOf(left2Diff)","!rootDiff.isDirectSuccessorOf(right2Diff)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
