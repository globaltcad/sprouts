{
  "className":"sprouts.Sorted_Association_Spec",
  "title":"Sorted Association - a Data Oriented Mapping",
  "narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming.\n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it.\n\n    A regular `Association` is unordered, meaning that the order of the\n    key-value pairs is not guaranteed. But if you use special\n    factory methods, you can create a `SortedAssociation` that\n    guarantees the order of the key-value pairs.\n    Under the hood, this key-value store is based on a binary tree\n    with a node size growing with the depth of the tree.",
  "subjects":["sprouts.Association"],
  "statistics":{
    "runs":"63",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"An empty association is created by supplying the type of the key and value",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"expect","text":"","code":["associations.isSorted()","associations.isEmpty()","associations.keyType() == String","associations.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()","associations.collect({it.first()}) == map.collect({it.key})","associations.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = associations.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = associations.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` flag:","code":["associations.isSorted()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["associations.size() == new HashSet<>(associations.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Association maintains full invariance with Map across all operations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Fresh association and reference map","code":["var assoc = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = new TreeMap<String,String>((k1, k2) -> k1 <=> k2)","var valueGenerator = { key -> \"[value-of:$key]\".toString() }","var replacementValueGenerator = { key -> \"[replaced-value-of:$key]\".toString() }","var operationsApplier = { currentAssoc ->","    operations.each { op, key ->","        switch (op) {","            case Operation.ADD:","                currentAssoc = currentAssoc.put(key, valueGenerator(key))","                map.put(key, valueGenerator(key))","                break","            case Operation.REMOVE:","                currentAssoc = currentAssoc.remove(key)","                map.remove(key)","                break","            case Operation.REPLACE:","                currentAssoc = currentAssoc.replace(key, replacementValueGenerator(key))","                if (map.containsKey(key)) {","                    map.put(key, replacementValueGenerator(key))","                }","                break","            case Operation.PUT_IF_ABSENT:","                currentAssoc = currentAssoc.putIfAbsent(key, valueGenerator(key))","                map.putIfAbsent(key, valueGenerator(key))","                break","            case Operation.CLEAR:","                currentAssoc = currentAssoc.clear()","                map.clear()","                break","        }","    }","    return currentAssoc","}"]},

        {"kind":"when","text":"Apply operations 3 times","code":["3.times { assoc = operationsApplier(assoc) }"]},

        {"kind":"then","text":"Immediate invariance","code":["assoc.size() == map.size()","assoc.keySet().toSet() == map.keySet()","assoc.values().sort().toList() == map.values().sort()","assoc.toMap() == map","assoc.collect({it.first()}) == map.collect({it.key})","assoc.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"","code":["map.every { k, v ->","    assoc.get(k).orElse(null) == v","}","assoc.every { pair ->","    pair.second() == map[pair.first()]","}"]},

        {"kind":"when","text":"We verify the `Iterable` implementation of the association by iterating over it.","code":["var pairSet = new HashSet()","for ( pair in assoc ) {","    pairSet.add(pair)","}"]},

        {"kind":"then","text":"The pair set is equal to the map and all sizes match.","code":["pairSet.size() == assoc.size()","pairSet.size() == map.size()","pairSet == map.collect({ k, v -> Pair.of(k, v) }).toSet()"]},

        {"kind":"where","text":"","code":{"operations":["(0..2000).collect {\n        var random = new Random(it*1997).nextInt()\n        var randKey = \"key-\"+Integer.toHexString(random)\n        var op = Operation.values()Math.abs(random % 5)]\n        return new Tuple2(op, randKey)\n    }",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two associations into one using the `putAll` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"d\", 4).put(\"e\", 5).put(\"f\", 6)"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == 6","mergedAssociations.get(\"a\").orElseThrow(MissingItemException::new) == 1","mergedAssociations.get(\"b\").orElseThrow(MissingItemException::new) == 2","mergedAssociations.get(\"c\").orElseThrow(MissingItemException::new) == 3","mergedAssociations.get(\"d\").orElseThrow(MissingItemException::new) == 4","mergedAssociations.get(\"e\").orElseThrow(MissingItemException::new) == 5","mergedAssociations.get(\"f\").orElseThrow(MissingItemException::new) == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You remove the entries of one association from another, using the `removeAll(ValueSet)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"x\", 1).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"y\", 2).put(\"z\", 3).put(\"o\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"x\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You remove the entries of one association from another, using the `removeAll(Set)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"b\", 2).put(\"c\", 3).put(\"d\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet().toSet())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"a\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `clear` method creates an empty association with the same key and value types.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"expect","text":"The association is not empty.","code":["!associations.isEmpty()"]},

        {"kind":"when","text":"We clear the association.","code":["associations = associations.clear()"]},

        {"kind":"then","text":"The association is empty.","code":["associations.isEmpty()"]},

        {"kind":"and","text":"The key and value types are the same.","code":["associations.keyType() == String","associations.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An `Association` has an intuitive string representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"then","text":"The string representation of the association is as expected.","code":["associations.toString() == 'SortedAssociation<String,Integer>[\"a\" ↦ 1, \"b\" ↦ 2, \"c\" ↦ 3]'"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A larger `Association` will have a trimmed string representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(Character, Byte, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["30.times { index ->","    var key = Math.abs(65+(index)) as char","    var value = Math.abs(1997*index) as byte","    associations = associations.put(key, value)","}"]},

        {"kind":"then","text":"The string representation of the association is as expected.","code":["associations.toString() == \"SortedAssociation<Character,Byte>['A' ↦ 0, 'B' ↦ -51, 'C' ↦ -102, 'D' ↦ 103, 'E' ↦ 52, 'F' ↦ 1, 'G' ↦ -50, 'H' ↦ -101, ... 22 items left]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `replace` method replaces the value of a key with a new value, if and only if the key is present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We replace the value of a key that is present.","code":["associations = associations.replace(\"b\", 4)"]},

        {"kind":"then","text":"The value of the key is replaced.","code":["associations.get(\"b\").orElseThrow(MissingItemException::new) == 4"]},

        {"kind":"and","text":"The size of the association remains the same.","code":["associations.size() == 3"]},

        {"kind":"when","text":"We call the `replace` method with a key that is not present.","code":["associations = associations.replace(\"d\", 5)"]},

        {"kind":"then","text":"The size of the association remains the same.","code":["associations.size() == 3"]},

        {"kind":"and","text":"The value of the key is not replaced.","code":["!associations.get(\"d\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Pair...)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll(","    Pair.of(\"I\", 1),","    Pair.of(\"was\", 2),","    Pair.of(\"added\", 3),","    Pair.of(\"to\", 4),","    Pair.of(\"the\", 5),","    Pair.of(\"association\", 6)",")"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(\"I\").orElseThrow(MissingItemException::new) == 1","associations.get(\"was\").orElseThrow(MissingItemException::new) == 2","associations.get(\"added\").orElseThrow(MissingItemException::new) == 3","associations.get(\"to\").orElseThrow(MissingItemException::new) == 4","associations.get(\"the\").orElseThrow(MissingItemException::new) == 5","associations.get(\"association\").orElseThrow(MissingItemException::new) == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(Integer, String, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll(","    Tuple.of(","        Pair.of(1, \"I\"),","        Pair.of(2, \"was\"),","        Pair.of(3, \"added\"),","        Pair.of(4, \"to\"),","        Pair.of(5, \"the\"),","        Pair.of(6, \"association\")","    )",")"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(1).orElseThrow(MissingItemException::new) == \"I\"","associations.get(2).orElseThrow(MissingItemException::new) == \"was\"","associations.get(3).orElseThrow(MissingItemException::new) == \"added\"","associations.get(4).orElseThrow(MissingItemException::new) == \"to\"","associations.get(5).orElseThrow(MissingItemException::new) == \"the\"","associations.get(6).orElseThrow(MissingItemException::new) == \"association\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Collection` interface, which\n            is especially useful when you have a list of pairs that you want to\n            populate the association with.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(Integer, String, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll([","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")","])"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(1).orElseThrow(MissingItemException::new) == \"I\"","associations.get(2).orElseThrow(MissingItemException::new) == \"was\"","associations.get(3).orElseThrow(MissingItemException::new) == \"added\"","associations.get(4).orElseThrow(MissingItemException::new) == \"to\"","associations.get(5).orElseThrow(MissingItemException::new) == \"the\"","associations.get(6).orElseThrow(MissingItemException::new) == \"association\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Set` interface, which\n            is especially useful when you have a set of pairs that you want to\n            populate the association with.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(Character, String, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll([","    Pair.of('I' as char, \"I\"),","    Pair.of('w' as char, \"was\"),","    Pair.of('a' as char, \"added\"),","    Pair.of('t' as char, \"to\"),","    Pair.of('t' as char, \"the\"), // overwrites the previous value","    Pair.of('a' as char, \"association\") // overwrites the previous value","])"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 4","associations.get('I' as char).orElseThrow(MissingItemException::new) == \"I\"","associations.get('w' as char).orElseThrow(MissingItemException::new) == \"was\"","associations.get('a' as char).orElseThrow(MissingItemException::new) == \"association\"","associations.get('t' as char).orElseThrow(MissingItemException::new) == \"the\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association between shorts and chars and add a bunch of entries to the association.","code":["var associations = Association.betweenSorted(Short, Character, (k1, k2) -> k1 <=> k2 ).putAll([","    Pair.of(11 as short, 'a' as char),","    Pair.of(22 as short, 'b' as char),","    Pair.of(33 as short, 'c' as char),","    Pair.of(44 as short, 'x' as char),","    Pair.of(55 as short, 'y' as char),","    Pair.of(66 as short, 'z' as char)","])"]},

        {"kind":"when","text":"We add a new entry to the association.","code":["associations = associations.putIfAbsent(77 as short, 'w' as char)"]},

        {"kind":"then","text":"The new entry is added to the association.","code":["associations.size() == 7","associations.get(77 as short).orElseThrow(MissingItemException::new) == 'w' as char"]},

        {"kind":"when","text":"We try to add an entry with a key that is already present.","code":["associations = associations.putIfAbsent(44 as short, 'v' as char)"]},

        {"kind":"then","text":"The association remains the same.","code":["associations.size() == 7","associations.get(44 as short).orElseThrow(MissingItemException::new) == 'x' as char"]},

        {"kind":"when","text":"We now ry this for every key in the association.","code":["associations.keySet().forEach { key ->","    associations = associations.putIfAbsent(key, '!' as char)","}"]},

        {"kind":"then","text":"The association still remains the same.","code":["associations.size() == 7","associations.get(44 as short).orElseThrow(MissingItemException::new) == 'x' as char"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `Association.betweenSorted(Number.class, Number.class)` to create an association between all kinds of numbers.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(Number.class, Number.class, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"expect","text":"","code":["associations.isEmpty()","associations.keyType() == Number.class","associations.valueType() == Number.class"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.put(1, 1).put(2L, 2L).put(3.0f, 3.0f).put(4.0, 4.0)"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 4","associations.get(1).orElseThrow(MissingItemException::new) == 1","associations.get(2L).orElseThrow(MissingItemException::new) == 2L","associations.get(3.0f).orElseThrow(MissingItemException::new) == 3.0f","associations.get(4.0).orElseThrow(MissingItemException::new) == 4.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The classTyped method returns the correct class and handles null parameters",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["var associationClass = Association.classTyped(String, Integer)"]},

        {"kind":"then","text":"","code":["associationClass == Association.class"]},

        {"kind":"when","text":"","code":["Association.classTyped(null, Integer)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["Association.classTyped(String, null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The of factory method throws NPE for null parameters",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["Association.ofSorted(null, \"value\", (k1, k2) -> k1 <=> k2)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["Association.ofSorted(\"key\", null, (k1, k2) -> k1 <=> k2)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `entrySet` is immutable and contains correct pairs",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2)"]},

        {"kind":"when","text":"","code":["var entryValueSet = assoc.entrySet()","var entrySet = entryValueSet.toSet()"]},

        {"kind":"then","text":"","code":["entrySet.size() == 2","entrySet.contains(Pair.of(\"a\", 1))","entrySet.contains(Pair.of(\"b\", 2))"]},

        {"kind":"and","text":"","code":["entryValueSet.size() == 2","entryValueSet.contains(Pair.of(\"a\", 1))","entryValueSet.contains(Pair.of(\"b\", 2))"]},

        {"kind":"when","text":"","code":["entrySet.add(Pair.of(\"c\", 3))"]},

        {"kind":"then","text":"","code":["thrown(UnsupportedOperationException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can iterate over the `entrySet` of all pairs in an `Association`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.betweenSorted(Integer, String, (k1, k2)-> k1 <=> k2 ).putAll(","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")",")"]},

        {"kind":"when","text":"","code":["var entries = []","for (var entry : assoc.entrySet().toSet()) {","    entries << entry","}"]},

        {"kind":"then","text":"","code":["entries.size() == 6","entries.contains(Pair.of(1, \"I\"))","entries.contains(Pair.of(2, \"was\"))","entries.contains(Pair.of(3, \"added\"))","entries.contains(Pair.of(4, \"to\"))","entries.contains(Pair.of(5, \"the\"))","entries.contains(Pair.of(6, \"association\"))"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"replaceAll with Map only updates existing keys",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)","var replacementMap = [a:10, d:40, c:30] as Map"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(replacementMap)"]},

        {"kind":"then","text":"","code":["updated.size() == 3","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2  // Should remain unchanged","updated.get(\"c\").get() == 30","!updated.containsKey(\"d\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll` method keeps only specified keys",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"","code":["var retained = assoc.retainAll([\"a\", \"c\"] as Set)"]},

        {"kind":"then","text":"","code":["retained.size() == 2","retained.containsKey(\"a\")","retained.containsKey(\"c\")","!retained.containsKey(\"b\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent` does not overwrite an existing value already stored in an association.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).putIfAbsent(\"a\", 2)"]},

        {"kind":"expect","text":"","code":["assoc.get(\"a\").get() == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Associations with same entries in different order are equal",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var comparator = { k1, k2 -> k1 <=> k2 }","var assoc1 = Association.ofSorted(\"a\", 1, comparator).put(\"b\", 2).put(\"c\", 3)","var assoc2 = Association.ofSorted(\"c\", 3, comparator).put(\"b\", 2).put(\"a\", 1)"]},

        {"kind":"expect","text":"","code":["assoc1 == assoc2","assoc1.hashCode() == assoc2.hashCode()"]},

        {"kind":"and","text":"","code":["assoc1.toList() == assoc2.toList()","assoc1.toList() == [","    Pair.of(\"a\", 1),","    Pair.of(\"b\", 2),","    Pair.of(\"c\", 3)","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"values() contains all values including duplicates",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"c\", 10, (k1, k2) -> k1 <=> k2)","    .put(\"b\", 20)","    .put(\"a\", 10) // Duplicate value"]},

        {"kind":"when","text":"","code":["var values = assoc.values()"]},

        {"kind":"then","text":"","code":["values.size() == 3","values.sort().toList() == [10, 10, 20]"]},

        {"kind":"and","text":"The values are in the expected order.","code":["assoc.toList() == [","    Pair.of(\"a\", 10),","    Pair.of(\"b\", 20),","    Pair.of(\"c\", 10)","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"replaceAll ignores non-existing keys in replacement stream",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2)","var replacements = [Pair.of(\"k\", -40), Pair.of(\"a\", 10), Pair.of(\"v\", 30)]"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(replacements.stream())"]},

        {"kind":"then","text":"","code":["updated.size() == 2","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2 // Unchanged","!updated.containsKey(\"k\")","!updated.containsKey(\"v\")"]},

        {"kind":"and","text":"The updated association has the expected order.","code":["updated.toList() == [","    Pair.of(\"a\", 10),","    Pair.of(\"b\", 2)","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"clear on empty association returns an empty instance",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var emptyAssoc = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 ).clear()"]},

        {"kind":"expect","text":"","code":["emptyAssoc.isEmpty()","emptyAssoc.keyType() == String","emptyAssoc.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Association` class is an `Iterable` which allows you to iterate over its entries.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.ofSorted(\"x\", 1, (k1, k2) -> k1 <=> k2).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"when","text":"","code":["var entries = []","for (var entry : associations) {","    entries << entry","}"]},

        {"kind":"then","text":"","code":["entries == [Pair.of(\"x\", 1), Pair.of(\"y\", 2), Pair.of(\"z\", 3)]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var sentence = Stream.of(","    Pair.of(0, \"I\"),","    Pair.of(1, \"watch\"),","    Pair.of(2, \"dominion\"),","    Pair.of(3, \"documentary\"),","    Pair.of(4, \"on\"),","    Pair.of(5, \"www.dominionmovement.com\")",")"]},

        {"kind":"when","text":"","code":["var associations = sentence.collect(Association.collectorOfSorted(Integer, String, (k1, k2) -> k1 <=> k2))"]},

        {"kind":"then","text":"","code":["associations.size() == 6","associations.get(0).get() == \"I\"","associations.get(1).get() == \"watch\"","associations.get(2).get() == \"dominion\"","associations.get(3).get() == \"documentary\"","associations.get(4).get() == \"on\"","associations.get(5).get() == \"www.dominionmovement.com\""]},

        {"kind":"and","text":"The entry has the correct order.","code":["associations.toList() == [","    Pair.of(0, \"I\"),","    Pair.of(1, \"watch\"),","    Pair.of(2, \"dominion\"),","    Pair.of(3, \"documentary\"),","    Pair.of(4, \"on\"),","    Pair.of(5, \"www.dominionmovement.com\")","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A no-op operations returns the same instance!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test ensures that no-op operations like `putAll`, `retainAll`, `removeAll`... \n            do not create a new instance of the `Association` class, but rather return the same instance\n            when passed an empty collection or set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"and","text":"We add some initial values to the association.","code":["associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"We call the `putAll` method with an empty collection.","code":["var result = associations.putAll([])"]},

        {"kind":"then","text":"The result is the same instance as the original association.","code":["result.is(associations)"]},

        {"kind":"when","text":"We call the `retainAll` method with an empty set.","code":["result = associations.retainAll([] as Set)"]},

        {"kind":"then","text":"The result is the same instance as the original association.","code":["result.is(associations)"]},

        {"kind":"when","text":"We call the `removeAll` method with an empty set.","code":["result = associations.removeAll([] as Set)"]},

        {"kind":"then","text":"The result is the same instance as the original association.","code":["result.is(associations)"]},

        {"kind":"when","text":"We now do the same thing with cases where the entries already exist in the association.","code":["result = associations.putAll([","    Pair.of(\"a\", 1),","    Pair.of(\"b\", 2),","    Pair.of(\"c\", 3)","])"]},

        {"kind":"then","text":"The result is still the same instance as the original association.","code":["result.is(associations)"]},

        {"kind":"when","text":"We call the `retainAll` method with a set that contains all keys of the association.","code":["result = associations.retainAll(associations.keySet())"]},

        {"kind":"then","text":"The result is still the same instance as the original association.","code":["result.is(associations)"]},

        {"kind":"when","text":"We call the `removeAll` method with a set that contains irrelevant keys.","code":["result = associations.removeAll([\"x\", \"y\", \"z\"] as Set)"]},

        {"kind":"then","text":"The result is still the same instance as the original association.","code":["result.is(associations)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `toMap()` method to convert a sorted `Association` to an unmodifiable `Map`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.betweenSorted(Byte, String)","    .put((byte) 1, \"one\")","    .put((byte) 2, \"two\")","    .put((byte) 3, \"three\")"]},

        {"kind":"when","text":"","code":["var map = associations.toMap()"]},

        {"kind":"then","text":"","code":["map instanceof Map","map.size() == 3","map.get((byte) 1) == \"one\"","map.get((byte) 2) == \"two\"","map.get((byte) 3) == \"three\""]},

        {"kind":"when","text":"We try to modify the map.","code":["map.put((byte) 4, \"four\")"]},

        {"kind":"then","text":"An UnsupportedOperationException is thrown.","code":["thrown(UnsupportedOperationException)"]},

        {"kind":"when","text":"We try to remove an entry from the map.","code":["map.remove((byte) 1)"]},

        {"kind":"then","text":"An UnsupportedOperationException is thrown.","code":["thrown(UnsupportedOperationException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
