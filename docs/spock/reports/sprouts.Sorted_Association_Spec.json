{
  "className":"sprouts.Sorted_Association_Spec",
  "title":"Sorted Association - a Data Oriented Mapping",
  "narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming.\n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it.\n\n    A regular `Association` is unordered, meaning that the order of the\n    key-value pairs is not guaranteed. But if you use special\n    factory methods, you can create a `SortedAssociation` that\n    guarantees the order of the key-value pairs.\n    Under the hood, this key-value store is based on a binary tree\n    with a node size growing with the depth of the tree.",
  "subjects":["sprouts.Association"],
  "statistics":{
    "runs":"137",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"An empty association is created by supplying the type of the key and value",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"expect","text":"","code":["association.isSorted()","association.isEmpty()","!association.isNotEmpty()","association.keyType() == String","association.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = [:] as TreeMap","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                if ( !currentAssociations.containsKey(key) ) {","                    throw new IllegalStateException(","                        \"Entry with key '$key' not found in the association \" +","                        \"right after it was added with operation..\"","                    )","                }","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","        if ( map.size() != currentAssociations.size() ) {","            throw new IllegalStateException(","                \"The size of the map and the association are not equal after key '$key' was introduced \"+","                \"with operation '$operation'. Map size: ${map.size()}, Association size: ${currentAssociations.size()}\"","            )","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["association = operationsApplier(association) as Association<String, String>"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times {","    association = operationsApplier(association) as Association<String, String>","}"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["association.size() == map.size()","association.keySet().toSet() == map.keySet()","association.values().sort().toList() == map.values().sort()","association.collect({it.first()}) == map.collect({it.key})","association.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> association.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = association.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"when","text":"We use the stream API to map both the association and the reference map.","code":["var mappedAssociation = association.entrySet().stream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMap = map.entrySet().stream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal.","code":["mappedAssociation.toMap() == mappedMap"]},

        {"kind":"when","text":"We use the parallel stream API to map both the association and the reference map.","code":["var mappedAssociationParallel = association.entrySet().parallelStream().map({ it.withFirst(it.first().toUpperCase() + \"!\") }).filter({ it.hashCode() % 2 == 0 }).collect(Association.collectorOf(String, String))","var mappedMapParallel = map.entrySet().parallelStream().map({ Pair.of(it.key.toUpperCase() + \"!\", it.value) }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toMap({it.first()}, {it.second()}))"]},

        {"kind":"then","text":"The mapped association and map are equal in terms of their contents.","code":["mappedAssociationParallel.toMap() == mappedMapParallel"]},

        {"kind":"and","text":"Finally, we also check the `isSorted()` and `isLinked()` flag:","code":["association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"We also check if the key set is distinct!","code":["association.size() == new HashSet<>(association.toMap().keySet()).size()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..10_000).collect({\n            var hash1 = Math.abs((1997 * 139 * (500 + it.hashCode())) % 7_000)\n            var operation = hash1 > 3_000 ? Operation.ADD : Operation.REMOVE\n            var hash2 = Math.abs((1997 * 139 * hash1) % 9_000)\n            return new Tuple2(operation, hash2.toString())\n        })","(0..10_000).collect({\n        /*\n            Here the operations come in sequences of 50, which\n            means 50 add operations, then 50 remove operations then 50 add... etc.\n            There is a total of 160 possible values!\n         */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var item = 160-Math.abs(it % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, item.toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in REVERSED and ORDERED sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var item = 190-Math.abs(it % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (item*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Association maintains full invariance with Map across all operations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Fresh association and reference map","code":["var assoc = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var map = new TreeMap<String,String>((k1, k2) -> k1 <=> k2)","var valueGenerator = { key -> \"[value-of:$key]\".toString() }","var replacementValueGenerator = { key -> \"[replaced-value-of:$key]\".toString() }","var operationsApplier = { currentAssoc ->","    operations.each { op, key ->","        switch (op) {","            case Operation.ADD:","                currentAssoc = currentAssoc.put(key, valueGenerator(key))","                map.put(key, valueGenerator(key))","                break","            case Operation.REMOVE:","                currentAssoc = currentAssoc.remove(key)","                map.remove(key)","                break","            case Operation.REPLACE:","                currentAssoc = currentAssoc.replace(key, replacementValueGenerator(key))","                if (map.containsKey(key)) {","                    map.put(key, replacementValueGenerator(key))","                }","                break","            case Operation.PUT_IF_ABSENT:","                currentAssoc = currentAssoc.putIfAbsent(key, valueGenerator(key))","                map.putIfAbsent(key, valueGenerator(key))","                break","            case Operation.CLEAR:","                currentAssoc = currentAssoc.clear()","                map.clear()","                break","        }","    }","    return currentAssoc","}"]},

        {"kind":"when","text":"Apply operations 3 times","code":["3.times {","    assoc = operationsApplier(assoc) as Association<String, String>","}"]},

        {"kind":"then","text":"Immediate invariance","code":["assoc.size() == map.size()","assoc.keySet().toSet() == map.keySet()","assoc.values().sort().toList() == map.values().sort()","assoc.toMap() == map","assoc.collect({it.first()}) == map.collect({it.key})","assoc.collect({it.second()}) == map.collect({it.value})"]},

        {"kind":"and","text":"","code":["map.every { k, v ->","    assoc.get(k).orElse(null) == v","}","assoc.every { pair ->","    pair.second() == map[pair.first()]","}"]},

        {"kind":"when","text":"We verify the `Iterable` implementation of the association by iterating over it.","code":["var pairSet = new HashSet()","for ( pair in assoc ) {","    pairSet.add(pair)","}"]},

        {"kind":"then","text":"The pair set is equal to the map and all sizes match.","code":["pairSet.size() == assoc.size()","pairSet.size() == map.size()","pairSet == map.collect({ k, v -> Pair.of(k, v) }).toSet()"]},

        {"kind":"where","text":"","code":{"operations":["(0..2000).collect {\n        var random = new Random(it*1997).nextInt()\n        var randKey = \"key-\"+Integer.toHexString(random)\n        var op = Operation.values()Math.abs(random % 5)]\n        return new Tuple2(op, randKey)\n    }",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var association = Association.betweenSorted(String, String, (k1, k2) -> k1 <=> k2 )","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var association1 = operationsApplier(association) as Association<String, String>","var association2 = operationsApplier(association) as Association<String, String>"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["association1 = association1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","association1 = association1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["association1 == association2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["association2 = association2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["association1 != association2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["association1.hashCode() != association2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.ADD, 'a'),\n                       new Tuple2(Operation.REMOVE, 'a'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.ADD, 'b'),\n                       new Tuple2(Operation.REMOVE, 'b'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.ADD, 'c'),\n                       new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two associations into one using the `putAll` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var associations2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"d\", 4).put(\"e\", 5).put(\"f\", 6)"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == 6","mergedAssociations.get(\"a\").orElseThrow(MissingItemException::new) == 1","mergedAssociations.get(\"b\").orElseThrow(MissingItemException::new) == 2","mergedAssociations.get(\"c\").orElseThrow(MissingItemException::new) == 3","mergedAssociations.get(\"d\").orElseThrow(MissingItemException::new) == 4","mergedAssociations.get(\"e\").orElseThrow(MissingItemException::new) == 5","mergedAssociations.get(\"f\").orElseThrow(MissingItemException::new) == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of one association from another, using the `removeAll(ValueSet)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["association1 = association1.put(\"x\", 1).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["association2 = association2.put(\"y\", 2).put(\"z\", 3).put(\"o\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = association1.removeAll(association2.keySet())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"x\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of one association from another, using the `removeAll(Set)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["association1 = association1.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["association2 = association2.put(\"b\", 2).put(\"c\", 3).put(\"d\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = association1.removeAll(association2.keySet().toSet())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"a\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You remove the entries of one sorted association from another, using the `removeAll(Stream)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty sorted associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the first association.","code":["association1 = association1.put(\"x\", 1).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["association2 = association2.put(\"y\", 2).put(\"z\", 3).put(\"i\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first using a stream of keys.","code":["var result = association1.removeAll(association2.keySet().stream())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"x\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove entries from a sorted association selectively, using `removeIf(Predicate)`. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove key/value pairs from a sorted association which satisfy\n            a given `Predicate` lambda. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            pair, then it will be removed, otherwise, it will remain in the\n            returned association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association and a regular JDK map containing some test elements.","code":["var assoc = Association.betweenSorted(type, String).putAll(elements.stream().map(it->Pair.of(it, it.toString())))","Map<?,String> map = new TreeMap<Object, String>().putAll(elements.stream().map(it->new AbstractMap.SimpleEntry<>(it, it.toString())).collect(Collectors.toList()))"]},

        {"kind":"when","text":"We apply a predicate to both types of mappings...","code":["var updatedAssoc = assoc.removeIf(predicate)","map.removeAll(entry -> predicate.test(Pair.of(entry.key, entry.value)))"]},

        {"kind":"then","text":"They contain the exact same entries!","code":["updatedAssoc.toMap() == map"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({ Integer it -> Month.values()[it%12]})"],"predicate":["{ (it.first() - it.first() % 1) == it.first() }","{ it.first() % 3 == 1 }","{ it.first().hashCode() % 5 == 1 }","{ it.hashCode() * 1997 % 8 == 2 }","{ it.first() == 'x' as char }","{ it.first() }","{ it.first() == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `clear` method creates an empty association with the same key and value types.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","association = association.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"expect","text":"The association is not empty.","code":["association.isNotEmpty()","!association.isEmpty()"]},

        {"kind":"when","text":"We clear the association.","code":["association = association.clear()"]},

        {"kind":"then","text":"The association is empty, sorted but not linked.","code":["association.isEmpty()","association.isSorted()","!association.isLinked()"]},

        {"kind":"and","text":"The key and value types are the same.","code":["association.keyType() == String","association.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var association1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association1.putAll(association2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var association1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association1.putAll(association2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var association1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association1.putAll(association2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var association1 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association1.putAll(association2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = association1.removeAll(association2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = association1.removeAll(association2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = association1.removeAll(association2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var association1 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var association2 = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association1 = association1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    association2 = association2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = association1.removeAll(association2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var association = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association = association.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var association = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association = association.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var association = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association = association.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var association = Association.betweenSorted(String, Character, (k1, k2) -> k1 <=> k2 )","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    association = association.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = association.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An `Association` has an intuitive string representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"then","text":"The string representation of the association is as expected.","code":["association.toString() == 'SortedAssociation<String,Integer>[\"a\"  1, \"b\"  2, \"c\"  3]'"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A larger `Association` will have a trimmed string representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Character, Byte, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["30.times { index ->","    var key = Math.abs(65+(index)) as char","    var value = Math.abs(1997*index) as byte","    association = association.put(key, value)","}"]},

        {"kind":"then","text":"The string representation of the association is as expected.","code":["association.toString() == \"SortedAssociation<Character,Byte>['A'  0, 'B'  -51, 'C'  -102, 'D'  103, 'E'  52, 'F'  1, 'G'  -50, 'H'  -101, ... 22 items left]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `replace` method replaces the value of a key with a new value, if and only if the key is present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We replace the value of a key that is present.","code":["association = association.replace(\"b\", 4)"]},

        {"kind":"then","text":"The value of the key is replaced.","code":["association.get(\"b\").orElseThrow(MissingItemException::new) == 4"]},

        {"kind":"and","text":"The size of the association remains the same.","code":["association.size() == 3"]},

        {"kind":"when","text":"We call the `replace` method with a key that is not present.","code":["association = association.replace(\"d\", 5)"]},

        {"kind":"then","text":"The size of the association remains the same.","code":["association.size() == 3"]},

        {"kind":"and","text":"The value of the key is not replaced.","code":["!association.get(\"d\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Pair...)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.putAll(","    Pair.of(\"I\", 1),","    Pair.of(\"was\", 2),","    Pair.of(\"added\", 3),","    Pair.of(\"to\", 4),","    Pair.of(\"the\", 5),","    Pair.of(\"association\", 6)",")"]},

        {"kind":"then","text":"The association contains the values.","code":["association.size() == 6","association.get(\"I\").orElseThrow(MissingItemException::new) == 1","association.get(\"was\").orElseThrow(MissingItemException::new) == 2","association.get(\"added\").orElseThrow(MissingItemException::new) == 3","association.get(\"to\").orElseThrow(MissingItemException::new) == 4","association.get(\"the\").orElseThrow(MissingItemException::new) == 5","association.get(\"association\").orElseThrow(MissingItemException::new) == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, String, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.putAll(","    Tuple.of(","        Pair.of(1, \"I\"),","        Pair.of(2, \"was\"),","        Pair.of(3, \"added\"),","        Pair.of(4, \"to\"),","        Pair.of(5, \"the\"),","        Pair.of(6, \"association\")","    )",")"]},

        {"kind":"then","text":"The association contains the values.","code":["association.size() == 6","association.get(1).orElseThrow(MissingItemException::new) == \"I\"","association.get(2).orElseThrow(MissingItemException::new) == \"was\"","association.get(3).orElseThrow(MissingItemException::new) == \"added\"","association.get(4).orElseThrow(MissingItemException::new) == \"to\"","association.get(5).orElseThrow(MissingItemException::new) == \"the\"","association.get(6).orElseThrow(MissingItemException::new) == \"association\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Collection` interface, which\n            is especially useful when you have a list of pairs that you want to\n            populate the association with.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, String, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.putAll([","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")","])"]},

        {"kind":"then","text":"The association contains the values.","code":["association.size() == 6","association.get(1).orElseThrow(MissingItemException::new) == \"I\"","association.get(2).orElseThrow(MissingItemException::new) == \"was\"","association.get(3).orElseThrow(MissingItemException::new) == \"added\"","association.get(4).orElseThrow(MissingItemException::new) == \"to\"","association.get(5).orElseThrow(MissingItemException::new) == \"the\"","association.get(6).orElseThrow(MissingItemException::new) == \"association\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Set` interface, which\n            is especially useful when you have a set of pairs that you want to\n            populate the association with.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Character, String, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.putAll([","    Pair.of('I' as char, \"I\"),","    Pair.of('w' as char, \"was\"),","    Pair.of('a' as char, \"added\"),","    Pair.of('t' as char, \"to\"),","    Pair.of('t' as char, \"the\"), // overwrites the previous value","    Pair.of('a' as char, \"association\") // overwrites the previous value","] as Set)"]},

        {"kind":"then","text":"The association contains the values.","code":["association.size() == 4","association.get('I' as char).orElseThrow(MissingItemException::new) == \"I\"","association.get('w' as char).orElseThrow(MissingItemException::new) == \"was\"","association.get('a' as char).orElseThrow(MissingItemException::new) == \"association\"","association.get('t' as char).orElseThrow(MissingItemException::new) == \"the\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAllIfAbsent(Pair...)` to populate a sorted association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `putAllIfAbsent(Pair...)` method allows you to populate a sorted association from\n            an array of entry pairs. However, it only adds new entries to the new association,\n            if they are not already present.\n            So contrary to `putAll`, the `putAllIfAbsent` does not overwrite existing entries!\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association with some initial entries:","code":["var associations = Association.betweenSorted(String, Integer).putAll(","    Pair.of(\"was\", -1),","    Pair.of(\"the\", -2),","    Pair.of(\"association\", -3)",")"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAllIfAbsent(","    Pair.of(\"I\", 1),","    Pair.of(\"was\", 2),","    Pair.of(\"added\", 3),","    Pair.of(\"to\", 4),","    Pair.of(\"the\", 5),","    Pair.of(\"association\", 6)",")"]},

        {"kind":"then","text":"The sorted association contains the values.","code":["associations.size() == 6","associations.get(\"I\").orElseThrow(MissingItemException::new) == 1","associations.get(\"was\").orElseThrow(MissingItemException::new) == -1","associations.get(\"added\").orElseThrow(MissingItemException::new) == 3","associations.get(\"to\").orElseThrow(MissingItemException::new) == 4","associations.get(\"the\").orElseThrow(MissingItemException::new) == -2","associations.get(\"association\").orElseThrow(MissingItemException::new) == -3"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAllIfAbsent(Tuple<Pair>)` to populate a sorted association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `putAllIfAbsent(Tuple<Pair>)` method allows you to populate a sorted association from\n            a tuple of entry pairs. However, it only adds new entries to the new association,\n            if they are not already present.\n            So contrary to `putAll`, the `putAllIfAbsent` does not overwrite existing entries!\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association with some initial entries:","code":["var associations = Association.betweenSorted(Integer, String).putAll(","    Pair.of(2, \":o\"),","    Pair.of(4, \":3\"),","    Pair.of(6, \":I\")",")"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAllIfAbsent(","    Tuple.of(","        Pair.of(1, \"I\"),","        Pair.of(2, \"was\"),","        Pair.of(3, \"added\"),","        Pair.of(4, \"to\"),","        Pair.of(5, \"the\"),","        Pair.of(6, \"association\")","    )",")"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(1).orElseThrow(MissingItemException::new) == \"I\"","associations.get(2).orElseThrow(MissingItemException::new) == \":o\"","associations.get(3).orElseThrow(MissingItemException::new) == \"added\"","associations.get(4).orElseThrow(MissingItemException::new) == \":3\"","associations.get(5).orElseThrow(MissingItemException::new) == \"the\"","associations.get(6).orElseThrow(MissingItemException::new) == \":I\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAllIfAbsent(Collection<Pair>)` to populate a sorted association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Collection` interface, which\n            is especially useful when you have a list of pairs that you want to\n            populate the sorted association with if they are not already present.\n\n            So contrary to `putAll`, the `putAllIfAbsent` does not overwrite existing entries!\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association with some initial entries:","code":["var associations = Association.betweenSorted(Integer, String).putAll(","    Pair.of(2, \":o\"),","    Pair.of(4, \":3\"),","    Pair.of(6, \":I\")",")"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAllIfAbsent([","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")","])"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(1).orElseThrow(MissingItemException::new) == \"I\"","associations.get(2).orElseThrow(MissingItemException::new) == \":o\"","associations.get(3).orElseThrow(MissingItemException::new) == \"added\"","associations.get(4).orElseThrow(MissingItemException::new) == \":3\"","associations.get(5).orElseThrow(MissingItemException::new) == \"the\"","associations.get(6).orElseThrow(MissingItemException::new) == \":I\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAllIfAbsent(Set<Pair>)` to populate a sorted association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Set` interface, which\n            is especially useful when you have a set of pairs that you want to\n            populate the sorted association with if they are not already present.\n\n            So contrary to `putAll`, the `putAllIfAbsent` does not overwrite existing entries!\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association with some initial entries:","code":["var associations = Association.betweenSorted(Character, String).putAll(","    Pair.of('w' as char, \":)\"),","    Pair.of('t' as char, \":P\")",")"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAllIfAbsent([","    Pair.of('I' as char, \"I\"),","    Pair.of('w' as char, \"was\"),","    Pair.of('a' as char, \"added\"),","    Pair.of('t' as char, \"to\"),","    Pair.of('t' as char, \"the\"), // does not overwrite the previous value","    Pair.of('a' as char, \"association\") // does not overwrite the previous value","] as Set)"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 4","associations.get('I' as char).orElseThrow(MissingItemException::new) == \"I\"","associations.get('w' as char).orElseThrow(MissingItemException::new) == \":)\"","associations.get('a' as char).orElseThrow(MissingItemException::new) == \"added\"","associations.get('t' as char).orElseThrow(MissingItemException::new) == \":P\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAllIfAbsent(Map<K,V>)` to populate a sorted association at once from a regular Java map.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Map` interface, which\n            is especially useful when you have a plain old key-value mapping that you want to\n            use to populate the association with if they are not already present.\n\n            So contrary to `putAll`, the `putAllIfAbsent` does not overwrite existing entries!\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create an association with some initial entries:","code":["var associations = Association.betweenSorted(Character, String).putAll(","    Pair.of('w' as char, \":)\"),","    Pair.of('t' as char, \":P\")",")"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAllIfAbsent([","    ('I' as char): \"I\",","    ('w' as char): \"was\",","    ('a' as char): \"added\",","    ('t' as char): \"to\",","    ('t' as char): \"the\",","    ('a' as char): \"association\"","] as LinkedHashMap)"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 4","associations.get('I' as char).orElseThrow(MissingItemException::new) == \"I\"","associations.get('w' as char).orElseThrow(MissingItemException::new) == \":)\"","associations.get('a' as char).orElseThrow(MissingItemException::new) == \"association\"","associations.get('t' as char).orElseThrow(MissingItemException::new) == \":P\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAllIfAbsent(Association<K,V>)` to populate a sorted association from another one.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method merges a sorted association with another one\n            in a way where only those key-value pairs are added from the supplied \n            association, whose keys are not already present in the targeted one.\n\n            So contrary to `putAll`, the `putAllIfAbsent` does not overwrite existing entries!\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a sorted association with some initial entries:","code":["var associations = Association.betweenSorted(Character, String).putAll(","    Pair.of('w' as char, \":)\"),","    Pair.of('t' as char, \":P\")",")"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAllIfAbsent(Association.betweenSorted(Character, String).putAll(","    Pair.of('I' as char, \"I\"),","    Pair.of('w' as char, \"was\"),","    Pair.of('a' as char, \"added\"),","    Pair.of('t' as char, \"to\"),","    Pair.of('t' as char, \"the\"),","    Pair.of('a' as char, \"association\")","))"]},

        {"kind":"then","text":"The sorted association contains the expected values.","code":["associations.size() == 4","associations.get('I' as char).orElseThrow(MissingItemException::new) == \"I\"","associations.get('w' as char).orElseThrow(MissingItemException::new) == \":)\"","associations.get('a' as char).orElseThrow(MissingItemException::new) == \"association\"","associations.get('t' as char).orElseThrow(MissingItemException::new) == \":P\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association between shorts and chars and add a bunch of entries to the association.","code":["var association = Association.betweenSorted(Short, Character, (k1, k2) -> k1 <=> k2 ).putAll([","    Pair.of(11 as short, 'a' as char),","    Pair.of(22 as short, 'b' as char),","    Pair.of(33 as short, 'c' as char),","    Pair.of(44 as short, 'x' as char),","    Pair.of(55 as short, 'y' as char),","    Pair.of(66 as short, 'z' as char)","])"]},

        {"kind":"when","text":"We add a new entry to the association.","code":["association = association.putIfAbsent(77 as short, 'w' as char)"]},

        {"kind":"then","text":"The new entry is added to the association.","code":["association.size() == 7","association.get(77 as short).orElseThrow(MissingItemException::new) == 'w' as char"]},

        {"kind":"when","text":"We try to add an entry with a key that is already present.","code":["association = association.putIfAbsent(44 as short, 'v' as char)"]},

        {"kind":"then","text":"The association remains the same.","code":["association.size() == 7","association.get(44 as short).orElseThrow(MissingItemException::new) == 'x' as char"]},

        {"kind":"when","text":"We now ry this for every key in the association.","code":["association.keySet().forEach { key ->","    association = association.putIfAbsent(key, '!' as char)","}"]},

        {"kind":"then","text":"The association still remains the same.","code":["association.size() == 7","association.get(44 as short).orElseThrow(MissingItemException::new) == 'x' as char"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `Association.betweenSorted(Number.class, Number.class)` to create an association between all kinds of numbers.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Number.class, Number.class, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"expect","text":"","code":["association.isEmpty()","association.keyType() == Number.class","association.valueType() == Number.class"]},

        {"kind":"when","text":"We add some values to the association.","code":["association = association.put(1, 1).put(2L, 2L).put(3.0f, 3.0f).put(4.0, 4.0)"]},

        {"kind":"then","text":"The association contains the values.","code":["association.size() == 4","association.get(1).orElseThrow(MissingItemException::new) == 1","association.get(2L).orElseThrow(MissingItemException::new) == 2L","association.get(3.0f).orElseThrow(MissingItemException::new) == 3.0f","association.get(4.0).orElseThrow(MissingItemException::new) == 4.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The classTyped method returns the correct class and handles null parameters",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["var associationClass = Association.classTyped(String, Integer)"]},

        {"kind":"then","text":"","code":["associationClass == Association.class"]},

        {"kind":"when","text":"","code":["Association.classTyped(null, Integer)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["Association.classTyped(String, null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The of factory method throws NPE for null parameters",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["Association.ofSorted(null, \"value\", (k1, k2) -> k1 <=> k2)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["Association.ofSorted(\"key\", null, (k1, k2) -> k1 <=> k2)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `entrySet` is immutable and contains correct pairs",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2)"]},

        {"kind":"when","text":"","code":["var entryValueSet = assoc.entrySet()","var entrySet = entryValueSet.toSet()"]},

        {"kind":"then","text":"","code":["entrySet.size() == 2","entrySet.contains(Pair.of(\"a\", 1))","entrySet.contains(Pair.of(\"b\", 2))"]},

        {"kind":"and","text":"","code":["entryValueSet.size() == 2","entryValueSet.contains(Pair.of(\"a\", 1))","entryValueSet.contains(Pair.of(\"b\", 2))"]},

        {"kind":"when","text":"","code":["entrySet.add(Pair.of(\"c\", 3))"]},

        {"kind":"then","text":"","code":["thrown(UnsupportedOperationException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can iterate over the `entrySet` of all pairs in an `Association`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.betweenSorted(Integer, String, (k1, k2)-> k1 <=> k2 ).putAll(","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")",")"]},

        {"kind":"when","text":"","code":["var entries = []","for (var entry : assoc.entrySet().toSet()) {","    entries << entry","}"]},

        {"kind":"then","text":"","code":["entries.size() == 6","entries.contains(Pair.of(1, \"I\"))","entries.contains(Pair.of(2, \"was\"))","entries.contains(Pair.of(3, \"added\"))","entries.contains(Pair.of(4, \"to\"))","entries.contains(Pair.of(5, \"the\"))","entries.contains(Pair.of(6, \"association\"))"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `replaceAll(Map<K,V>)` to only updates existing keys.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)","var replacementMap = [a:10, d:40, c:30] as Map"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(replacementMap)"]},

        {"kind":"then","text":"","code":["updated.size() == 3","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2  // Should remain unchanged","updated.get(\"c\").get() == 30","!updated.containsKey(\"d\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `replaceAll(Pair<K,V>...)` method only updates existing key-value pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(","        Pair.of(\"a\", 10),","        Pair.of(\"d\", 40),","        Pair.of(\"c\", 30)","    )"]},

        {"kind":"then","text":"","code":["updated.size() == 3","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2  // Should remain unchanged","updated.get(\"c\").get() == 30","!updated.containsKey(\"d\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `replaceAll(Tuple<Pair<K,V>>)` method only updates existing key-value pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(Tuple.of(","        Pair.of(\"a\", 10),","        Pair.of(\"d\", 40),","        Pair.of(\"c\", 30)","    ))"]},

        {"kind":"then","text":"","code":["updated.size() == 3","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2  // Should remain unchanged","updated.get(\"c\").get() == 30","!updated.containsKey(\"d\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `replaceAll(Set<Pair<K,V>>)` method only updates existing key-value pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll([","        Pair.of(\"a\", 10),","        Pair.of(\"d\", 40),","        Pair.of(\"c\", 30)","    ] as Set)"]},

        {"kind":"then","text":"","code":["updated.size() == 3","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2  // Should remain unchanged","updated.get(\"c\").get() == 30","!updated.containsKey(\"d\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll` method keeps only specified keys",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"","code":["var retained = assoc.retainAll([\"a\", \"c\"] as Set)"]},

        {"kind":"then","text":"","code":["retained.size() == 2","retained.containsKey(\"a\")","retained.containsKey(\"c\")","!retained.containsKey(\"b\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent` does not overwrite an existing value already stored in an association.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).putIfAbsent(\"a\", 2)"]},

        {"kind":"expect","text":"","code":["assoc.get(\"a\").get() == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `containsKey` method of a sorted `Association` throws an exception when passing arguments of the wrong type.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, Number)"]},

        {"kind":"when","text":"","code":["association.containsKey(\"Boom!\")"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.containsKey(null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.containsKey(42)"]},

        {"kind":"then","text":"","code":["noExceptionThrown()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `remove` method of a sorted `Association` throws an exception when passing arguments of the wrong type.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, Number)"]},

        {"kind":"when","text":"","code":["association.remove(\"Boom!\")"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.remove(null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.remove(42)"]},

        {"kind":"then","text":"","code":["noExceptionThrown()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `get` method of a sorted `Association` throws an exception when passing arguments of the wrong type.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, Number)"]},

        {"kind":"when","text":"","code":["association.get(\"Boom!\")"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.get(null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.remove(42)"]},

        {"kind":"then","text":"","code":["noExceptionThrown()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent` method of a sorted `Association` throws an exception when passing arguments of the wrong type.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, Number)"]},

        {"kind":"when","text":"","code":["association.putIfAbsent(\"Boom!\", 42)"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.putIfAbsent(42, \"Boom!\")"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.putIfAbsent(42.666f, 42)"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.putIfAbsent(42, null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.putIfAbsent(null, 42)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.putIfAbsent(42, 42)"]},

        {"kind":"then","text":"","code":["noExceptionThrown()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `put` method of a sorted `Association` throws an exception when passing arguments of the wrong type.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Integer, Number)"]},

        {"kind":"when","text":"","code":["association.put(\"Boom!\", 42)"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.put(42, \"Boom!\")"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.put(42.666f, 42)"]},

        {"kind":"then","text":"","code":["thrown(IllegalArgumentException)"]},

        {"kind":"when","text":"","code":["association.put(42, null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.put(null, 42)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["association.put(42, 42)"]},

        {"kind":"then","text":"","code":["noExceptionThrown()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Associations with same entries in different order are equal",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var comparator = { k1, k2 -> k1 <=> k2 }","var assoc1 = Association.ofSorted(\"a\", 1, comparator).put(\"b\", 2).put(\"c\", 3)","var assoc2 = Association.ofSorted(\"c\", 3, comparator).put(\"b\", 2).put(\"a\", 1)"]},

        {"kind":"expect","text":"","code":["assoc1 == assoc2","assoc1.hashCode() == assoc2.hashCode()"]},

        {"kind":"and","text":"","code":["assoc1.toList() == assoc2.toList()","assoc1.toList() == [","    Pair.of(\"a\", 1),","    Pair.of(\"b\", 2),","    Pair.of(\"c\", 3)","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"values() contains all values including duplicates",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.ofSorted(\"c\", 10, (k1, k2) -> k1 <=> k2)","    .put(\"b\", 20)","    .put(\"a\", 10) // Duplicate value"]},

        {"kind":"when","text":"","code":["var values = assoc.values()"]},

        {"kind":"then","text":"","code":["values.size() == 3","values.sort().toList() == [10, 10, 20]"]},

        {"kind":"and","text":"The values are in the expected order.","code":["assoc.toList() == [","    Pair.of(\"a\", 10),","    Pair.of(\"b\", 20),","    Pair.of(\"c\", 10)","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"replaceAll ignores non-existing keys in replacement stream",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.ofSorted(\"a\", 1, (k1, k2) -> k1 <=> k2).put(\"b\", 2)","var replacements = [Pair.of(\"k\", -40), Pair.of(\"a\", 10), Pair.of(\"v\", 30)]"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(replacements.stream())"]},

        {"kind":"then","text":"","code":["updated.size() == 2","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2 // Unchanged","!updated.containsKey(\"k\")","!updated.containsKey(\"v\")"]},

        {"kind":"and","text":"The updated association has the expected order.","code":["updated.toList() == [","    Pair.of(\"a\", 10),","    Pair.of(\"b\", 2)","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"clear on empty association returns an empty instance",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var emptyAssoc = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 ).clear()"]},

        {"kind":"expect","text":"","code":["emptyAssoc.isEmpty()","emptyAssoc.keyType() == String","emptyAssoc.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Association` class is an `Iterable` which allows you to iterate over its entries.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.ofSorted(\"x\", 1, (k1, k2) -> k1 <=> k2).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"when","text":"","code":["var entries = []","for (var entry : associations) {","    entries << entry","}"]},

        {"kind":"then","text":"","code":["entries == [Pair.of(\"x\", 1), Pair.of(\"y\", 2), Pair.of(\"z\", 3)]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var sentence = Stream.of(","    Pair.of(0, \"I\"),","    Pair.of(1, \"watch\"),","    Pair.of(2, \"dominion\"),","    Pair.of(3, \"documentary\"),","    Pair.of(4, \"on\"),","    Pair.of(5, \"www.dominionmovement.com\")",")"]},

        {"kind":"when","text":"","code":["var association = sentence.collect(Association.collectorOfSorted(Integer, String, (k1, k2) -> k1 <=> k2))"]},

        {"kind":"then","text":"","code":["association.size() == 6","association.get(0).get() == \"I\"","association.get(1).get() == \"watch\"","association.get(2).get() == \"dominion\"","association.get(3).get() == \"documentary\"","association.get(4).get() == \"on\"","association.get(5).get() == \"www.dominionmovement.com\""]},

        {"kind":"and","text":"The entry has the correct order.","code":["association.toList() == [","    Pair.of(0, \"I\"),","    Pair.of(1, \"watch\"),","    Pair.of(2, \"dominion\"),","    Pair.of(3, \"documentary\"),","    Pair.of(4, \"on\"),","    Pair.of(5, \"www.dominionmovement.com\")","]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A no-op operations returns the same instance!",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This test ensures that no-op operations like `putAll`, `retainAll`, `removeAll`... \n            do not create a new instance of the `Association` class, but rather return the same instance\n            when passed an empty collection or set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(String, Integer, (k1, k2) -> k1 <=> k2 )"]},

        {"kind":"and","text":"We add some initial values to the association.","code":["association = association.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"We call the `putAll` method with an empty collection.","code":["var result = association.putAll([])"]},

        {"kind":"then","text":"The result is the same instance as the original association.","code":["result.is(association)"]},

        {"kind":"when","text":"We call the `retainAll` method with an empty set.","code":["result = association.retainAll([] as Set)"]},

        {"kind":"then","text":"The result is the same instance as the original association.","code":["result.is(association)"]},

        {"kind":"when","text":"We call the `removeAll` method with an empty set.","code":["result = association.removeAll([] as Set)"]},

        {"kind":"then","text":"The result is the same instance as the original association.","code":["result.is(association)"]},

        {"kind":"when","text":"We now do the same thing with cases where the entries already exist in the association.","code":["result = association.putAll([","    Pair.of(\"a\", 1),","    Pair.of(\"b\", 2),","    Pair.of(\"c\", 3)","])"]},

        {"kind":"then","text":"The result is still the same instance as the original association.","code":["result.is(association)"]},

        {"kind":"when","text":"We call the `retainAll` method with a set that contains all keys of the association.","code":["result = association.retainAll(association.keySet())"]},

        {"kind":"then","text":"The result is still the same instance as the original association.","code":["result.is(association)"]},

        {"kind":"when","text":"We call the `removeAll` method with a set that contains irrelevant keys.","code":["result = association.removeAll([\"x\", \"y\", \"z\"] as Set)"]},

        {"kind":"then","text":"The result is still the same instance as the original association.","code":["result.is(association)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `toMap()` method to convert a sorted `Association` to an unmodifiable `Map`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var association = Association.betweenSorted(Byte, String)","    .put((byte) 1, \"one\")","    .put((byte) 2, \"two\")","    .put((byte) 3, \"three\")"]},

        {"kind":"when","text":"","code":["var map = association.toMap()"]},

        {"kind":"then","text":"","code":["map instanceof Map","map.size() == 3","map.get((byte) 1) == \"one\"","map.get((byte) 2) == \"two\"","map.get((byte) 3) == \"three\""]},

        {"kind":"when","text":"We try to modify the map.","code":["map.put((byte) 4, \"four\")"]},

        {"kind":"then","text":"An UnsupportedOperationException is thrown.","code":["thrown(UnsupportedOperationException)"]},

        {"kind":"when","text":"We try to remove an entry from the map.","code":["map.remove((byte) 1)"]},

        {"kind":"then","text":"An UnsupportedOperationException is thrown.","code":["thrown(UnsupportedOperationException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The spliterator of a sorted association preserves order during traversal. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The spliterator of a sorted `Association` must report the correct characteristics:\n                - DISTINCT: Entries are unique\n                - IMMUTABLE: Cannot be modified\n                - SIZED: Knows exact size\n                - NONNULL: Entries aren't null\n                - ORDERED: The order according to the comparator\n\n            Elements must be traversed in sorted order regardless of splitting.\n            All entries should be traversed exactly once regardless of splitting strategy.\n            It must support both sequential and parallel traversal, including splitting, \n            where parallel splitting should maintain global ordering.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssociation = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> sortedAssociation = sortedAssociation.put(i, i*i) }","var expectedOrder = (0..<size).collect { Pair.of(it, it*it) }"]},

        {"kind":"when","text":"We create a spliterator...","code":["var spliterator = sortedAssociation.spliterator()"]},

        {"kind":"then","text":"The characteristics include ORDERED, among other things:","code":["spliterator.characteristics() & Spliterator.ORDERED","spliterator.characteristics() & Spliterator.DISTINCT","spliterator.characteristics() & Spliterator.IMMUTABLE","spliterator.characteristics() & Spliterator.SIZED","spliterator.estimateSize() == size"]},

        {"kind":"when","text":"We do a sequential traversal...","code":["var collected = []","spliterator.forEachRemaining { collected.add(it) }"]},

        {"kind":"then","text":"The elements are in ascending order!","code":["collected == expectedOrder"]},

        {"kind":"when","text":"We do a parallel-ready traversal with splitting","code":["var spliterator2 = sortedAssociation.spliterator()","var collectedBySplitting = []","var consumer = { Pair<Integer, Integer> pair -> collectedBySplitting.add(pair) } as Consumer<Pair<Integer, Integer>>","while (spliterator2.tryAdvance(consumer)) {","    var split = spliterator2.trySplit()","    if (split != null) split.forEachRemaining(consumer)","}"]},

        {"kind":"then","text":"Global order maintained despite splits","code":["collectedBySplitting == expectedOrder"]},

        {"kind":"where","text":"","code":{"size":["0","1","2","10","100","1000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The spliterator of a sorted association preserves order during traversal. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The spliterator of a sorted `Association` must report the correct characteristics:\n                - DISTINCT: Entries are unique\n                - IMMUTABLE: Cannot be modified\n                - SIZED: Knows exact size\n                - NONNULL: Entries aren't null\n                - ORDERED: The order according to the comparator\n\n            Elements must be traversed in sorted order regardless of splitting.\n            All entries should be traversed exactly once regardless of splitting strategy.\n            It must support both sequential and parallel traversal, including splitting, \n            where parallel splitting should maintain global ordering.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssociation = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> sortedAssociation = sortedAssociation.put(i, i*i) }","var expectedOrder = (0..<size).collect { Pair.of(it, it*it) }"]},

        {"kind":"when","text":"We create a spliterator...","code":["var spliterator = sortedAssociation.spliterator()"]},

        {"kind":"then","text":"The characteristics include ORDERED, among other things:","code":["spliterator.characteristics() & Spliterator.ORDERED","spliterator.characteristics() & Spliterator.DISTINCT","spliterator.characteristics() & Spliterator.IMMUTABLE","spliterator.characteristics() & Spliterator.SIZED","spliterator.estimateSize() == size"]},

        {"kind":"when","text":"We do a sequential traversal...","code":["var collected = []","spliterator.forEachRemaining { collected.add(it) }"]},

        {"kind":"then","text":"The elements are in ascending order!","code":["collected == expectedOrder"]},

        {"kind":"when","text":"We do a parallel-ready traversal with splitting","code":["var spliterator2 = sortedAssociation.spliterator()","var collectedBySplitting = []","var consumer = { Pair<Integer, Integer> pair -> collectedBySplitting.add(pair) } as Consumer<Pair<Integer, Integer>>","while (spliterator2.tryAdvance(consumer)) {","    var split = spliterator2.trySplit()","    if (split != null) split.forEachRemaining(consumer)","}"]},

        {"kind":"then","text":"Global order maintained despite splits","code":["collectedBySplitting == expectedOrder"]},

        {"kind":"where","text":"","code":{"size":["0","1","2","10","100","1000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The spliterator of a sorted association preserves order during traversal. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The spliterator of a sorted `Association` must report the correct characteristics:\n                - DISTINCT: Entries are unique\n                - IMMUTABLE: Cannot be modified\n                - SIZED: Knows exact size\n                - NONNULL: Entries aren't null\n                - ORDERED: The order according to the comparator\n\n            Elements must be traversed in sorted order regardless of splitting.\n            All entries should be traversed exactly once regardless of splitting strategy.\n            It must support both sequential and parallel traversal, including splitting, \n            where parallel splitting should maintain global ordering.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssociation = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> sortedAssociation = sortedAssociation.put(i, i*i) }","var expectedOrder = (0..<size).collect { Pair.of(it, it*it) }"]},

        {"kind":"when","text":"We create a spliterator...","code":["var spliterator = sortedAssociation.spliterator()"]},

        {"kind":"then","text":"The characteristics include ORDERED, among other things:","code":["spliterator.characteristics() & Spliterator.ORDERED","spliterator.characteristics() & Spliterator.DISTINCT","spliterator.characteristics() & Spliterator.IMMUTABLE","spliterator.characteristics() & Spliterator.SIZED","spliterator.estimateSize() == size"]},

        {"kind":"when","text":"We do a sequential traversal...","code":["var collected = []","spliterator.forEachRemaining { collected.add(it) }"]},

        {"kind":"then","text":"The elements are in ascending order!","code":["collected == expectedOrder"]},

        {"kind":"when","text":"We do a parallel-ready traversal with splitting","code":["var spliterator2 = sortedAssociation.spliterator()","var collectedBySplitting = []","var consumer = { Pair<Integer, Integer> pair -> collectedBySplitting.add(pair) } as Consumer<Pair<Integer, Integer>>","while (spliterator2.tryAdvance(consumer)) {","    var split = spliterator2.trySplit()","    if (split != null) split.forEachRemaining(consumer)","}"]},

        {"kind":"then","text":"Global order maintained despite splits","code":["collectedBySplitting == expectedOrder"]},

        {"kind":"where","text":"","code":{"size":["0","1","2","10","100","1000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The spliterator of a sorted association preserves order during traversal. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The spliterator of a sorted `Association` must report the correct characteristics:\n                - DISTINCT: Entries are unique\n                - IMMUTABLE: Cannot be modified\n                - SIZED: Knows exact size\n                - NONNULL: Entries aren't null\n                - ORDERED: The order according to the comparator\n\n            Elements must be traversed in sorted order regardless of splitting.\n            All entries should be traversed exactly once regardless of splitting strategy.\n            It must support both sequential and parallel traversal, including splitting, \n            where parallel splitting should maintain global ordering.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssociation = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> sortedAssociation = sortedAssociation.put(i, i*i) }","var expectedOrder = (0..<size).collect { Pair.of(it, it*it) }"]},

        {"kind":"when","text":"We create a spliterator...","code":["var spliterator = sortedAssociation.spliterator()"]},

        {"kind":"then","text":"The characteristics include ORDERED, among other things:","code":["spliterator.characteristics() & Spliterator.ORDERED","spliterator.characteristics() & Spliterator.DISTINCT","spliterator.characteristics() & Spliterator.IMMUTABLE","spliterator.characteristics() & Spliterator.SIZED","spliterator.estimateSize() == size"]},

        {"kind":"when","text":"We do a sequential traversal...","code":["var collected = []","spliterator.forEachRemaining { collected.add(it) }"]},

        {"kind":"then","text":"The elements are in ascending order!","code":["collected == expectedOrder"]},

        {"kind":"when","text":"We do a parallel-ready traversal with splitting","code":["var spliterator2 = sortedAssociation.spliterator()","var collectedBySplitting = []","var consumer = { Pair<Integer, Integer> pair -> collectedBySplitting.add(pair) } as Consumer<Pair<Integer, Integer>>","while (spliterator2.tryAdvance(consumer)) {","    var split = spliterator2.trySplit()","    if (split != null) split.forEachRemaining(consumer)","}"]},

        {"kind":"then","text":"Global order maintained despite splits","code":["collectedBySplitting == expectedOrder"]},

        {"kind":"where","text":"","code":{"size":["0","1","2","10","100","1000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The spliterator of a sorted association preserves order during traversal. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The spliterator of a sorted `Association` must report the correct characteristics:\n                - DISTINCT: Entries are unique\n                - IMMUTABLE: Cannot be modified\n                - SIZED: Knows exact size\n                - NONNULL: Entries aren't null\n                - ORDERED: The order according to the comparator\n\n            Elements must be traversed in sorted order regardless of splitting.\n            All entries should be traversed exactly once regardless of splitting strategy.\n            It must support both sequential and parallel traversal, including splitting, \n            where parallel splitting should maintain global ordering.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssociation = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> sortedAssociation = sortedAssociation.put(i, i*i) }","var expectedOrder = (0..<size).collect { Pair.of(it, it*it) }"]},

        {"kind":"when","text":"We create a spliterator...","code":["var spliterator = sortedAssociation.spliterator()"]},

        {"kind":"then","text":"The characteristics include ORDERED, among other things:","code":["spliterator.characteristics() & Spliterator.ORDERED","spliterator.characteristics() & Spliterator.DISTINCT","spliterator.characteristics() & Spliterator.IMMUTABLE","spliterator.characteristics() & Spliterator.SIZED","spliterator.estimateSize() == size"]},

        {"kind":"when","text":"We do a sequential traversal...","code":["var collected = []","spliterator.forEachRemaining { collected.add(it) }"]},

        {"kind":"then","text":"The elements are in ascending order!","code":["collected == expectedOrder"]},

        {"kind":"when","text":"We do a parallel-ready traversal with splitting","code":["var spliterator2 = sortedAssociation.spliterator()","var collectedBySplitting = []","var consumer = { Pair<Integer, Integer> pair -> collectedBySplitting.add(pair) } as Consumer<Pair<Integer, Integer>>","while (spliterator2.tryAdvance(consumer)) {","    var split = spliterator2.trySplit()","    if (split != null) split.forEachRemaining(consumer)","}"]},

        {"kind":"then","text":"Global order maintained despite splits","code":["collectedBySplitting == expectedOrder"]},

        {"kind":"where","text":"","code":{"size":["0","1","2","10","100","1000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The spliterator of a sorted association preserves order during traversal. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The spliterator of a sorted `Association` must report the correct characteristics:\n                - DISTINCT: Entries are unique\n                - IMMUTABLE: Cannot be modified\n                - SIZED: Knows exact size\n                - NONNULL: Entries aren't null\n                - ORDERED: The order according to the comparator\n\n            Elements must be traversed in sorted order regardless of splitting.\n            All entries should be traversed exactly once regardless of splitting strategy.\n            It must support both sequential and parallel traversal, including splitting, \n            where parallel splitting should maintain global ordering.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssociation = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> sortedAssociation = sortedAssociation.put(i, i*i) }","var expectedOrder = (0..<size).collect { Pair.of(it, it*it) }"]},

        {"kind":"when","text":"We create a spliterator...","code":["var spliterator = sortedAssociation.spliterator()"]},

        {"kind":"then","text":"The characteristics include ORDERED, among other things:","code":["spliterator.characteristics() & Spliterator.ORDERED","spliterator.characteristics() & Spliterator.DISTINCT","spliterator.characteristics() & Spliterator.IMMUTABLE","spliterator.characteristics() & Spliterator.SIZED","spliterator.estimateSize() == size"]},

        {"kind":"when","text":"We do a sequential traversal...","code":["var collected = []","spliterator.forEachRemaining { collected.add(it) }"]},

        {"kind":"then","text":"The elements are in ascending order!","code":["collected == expectedOrder"]},

        {"kind":"when","text":"We do a parallel-ready traversal with splitting","code":["var spliterator2 = sortedAssociation.spliterator()","var collectedBySplitting = []","var consumer = { Pair<Integer, Integer> pair -> collectedBySplitting.add(pair) } as Consumer<Pair<Integer, Integer>>","while (spliterator2.tryAdvance(consumer)) {","    var split = spliterator2.trySplit()","    if (split != null) split.forEachRemaining(consumer)","}"]},

        {"kind":"then","text":"Global order maintained despite splits","code":["collectedBySplitting == expectedOrder"]},

        {"kind":"where","text":"","code":{"size":["0","1","2","10","100","1000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after removing a large part of entries. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (31 * it.hashCode() * (1997 * it.hashCode() ** 3)%1024) as int }","var keyHasher2 = { (256 * it.hashCode() * (1997 * it.hashCode() ** 2)%256) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different sorted `Association` instances from the two scrambled list...","code":["var association1 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries1)","var association2 = Association.betweenSorted(keyType, valueType).putAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two associations are equal!","code":["association1.equals(association2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["association1.hashCode() == association2.hashCode()"]},

        {"kind":"when","text":"We create versions of the associations where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it.first()}).toSet()","var smallerAssociation1 = association1.removeAll(toRemove)","var smallerAssociation2 = association2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerAssociation1 == smallerAssociation2","smallerAssociation1.hashCode() == smallerAssociation2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallAssociation1 = smallerAssociation1.putAll(toAdd1)","var lessSmallAssociation2 = smallerAssociation2.putAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallAssociation1.size() == lessSmallAssociation2.size()","lessSmallAssociation1 != lessSmallAssociation2","lessSmallAssociation1.hashCode() != lessSmallAssociation2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a sorted Association works reliably after a series of modifications. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sorted associations,\n            we can avoid a lot of work due to two  sorted associations sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = {42 * it.hashCode() * (1997 * it.hashCode() ** 3)%256}","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalAssociation = Association.betweenSorted(keyType, valueType).putAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var toRemove = quarter.collect({it.first()}).toSet()","var associationModified = originalAssociation.removeAll(toRemove)"]},

        {"kind":"then","text":"","code":["associationModified != originalAssociation","associationModified.hashCode() != originalAssociation.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var associationModified1 = associationModified.putAll(subSubList1)","var associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"when","text":"","code":["associationModified = associationModified.putAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalAssociation == associationModified","originalAssociation.hashCode() == associationModified.hashCode()"]},

        {"kind":"when","text":"","code":["associationModified1 = associationModified.putAll(subSubList1)","associationModified2 = associationModified.putAll(subSubList2)"]},

        {"kind":"then","text":"","code":["associationModified1.size() == associationModified2.size()","associationModified1 != associationModified2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"keyType":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"valueType":["Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double","Boolean","Byte","Integer","Double"],"entries":["(0..24).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..24).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..24).collect(it -> Pair.of(it, -it)).toList()","(0..24).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..128).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..128).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..128).collect(it -> Pair.of(it, -it)).toList()","(0..128).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..1_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..1_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..1_000).collect(it -> Pair.of(it, -it)).toList()","(0..1_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()","(0..10_000).collect(it -> Pair.of(it as Long, it%2==0)).toList()","(0..10_000).collect(it -> Pair.of(it as Short, (it*73) as Byte)).toList()","(0..10_000).collect(it -> Pair.of(it, -it)).toList()","(0..10_000).collect(it -> Pair.of(String.valueOf(it), -it * 1234e-5 as double)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `update` method transforms existing values using a function while preserving the sorted association structure.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `update` method provides a safe way to modify existing values in an association\n            without having to manually check for key existence. It only applies the transformation\n            to keys that actually exist in the association, making it ideal for selective updates.\n\n            This method is particularly useful when you want to apply business logic transformations\n            to specific entries without affecting the overall structure of the association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association representing product inventory with initial quantities","code":["var inventory = Association.betweenSorted(String, Integer).putAll(","    Pair.of(\"apples\", 10),","    Pair.of(\"oranges\", 15),","    Pair.of(\"bananas\", 20),","    Pair.of(\"grapes\", 8)",")"]},

        {"kind":"when","text":"We update quantities for specific products that exist","code":["var updatedInventory = inventory","    .update(\"apples\") { quantity -> quantity + 5 }      // Restock apples","    .update(\"grapes\") { quantity -> quantity - 2 }      // Sell some grapes","    .update(\"mangoes\") { quantity -> quantity * 2 }     // Non-existent key - no change"]},

        {"kind":"then","text":"Only existing entries are updated as expected","code":["updatedInventory.size() == 4","updatedInventory.get(\"apples\").get() == 15      // 10 + 5","updatedInventory.get(\"oranges\").get() == 15     // unchanged","updatedInventory.get(\"bananas\").get() == 20     // unchanged","updatedInventory.get(\"grapes\").get() == 6       // 8 - 2","!updatedInventory.containsKey(\"mangoes\")        // still doesn't exist"]},

        {"kind":"and","text":"The original association remains unchanged (immutability)","code":["inventory.get(\"apples\").get() == 10","inventory.get(\"grapes\").get() == 8"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `update` method handles edge cases and exceptions appropriately for sorted associations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association with various value types","code":["var assoc = Association.betweenSorted(String, Object).putAll(","    Pair.of(\"number\", 42),","    Pair.of(\"text\", \"hello\"),","    Pair.of(\"list\", [1, 2, 3])",")"]},

        {"kind":"when","text":"Updating with a function that returns null","code":["var result = assoc.update(\"number\") { null }"]},

        {"kind":"then","text":"Null values are rejected with NullPointerException","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"Updating with null key","code":["assoc.update(null) { it }"]},

        {"kind":"then","text":"Null keys are rejected","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"Updating with null function","code":["assoc.update(\"number\", null)"]},

        {"kind":"then","text":"Null functions are rejected","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `updateAll` with a Tuple of keys to batch-update multiple values efficiently on sorted associations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `updateAll(Tuple, Function)` method allows you to apply the same transformation\n            to multiple keys in a single operation. This is more efficient than calling `update`\n            multiple times and provides cleaner code when you need to apply uniform changes\n            to a predefined set of entries.\n\n            This method silently ignores keys that don't exist in the association, making it\n            safe to use with dynamic key lists.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association representing student grades","code":["var grades = Association.betweenSorted(String, Integer).putAll(","    Pair.of(\"Alice\", 85),","    Pair.of(\"Bob\", 72),","    Pair.of(\"Charlie\", 90),","    Pair.of(\"Diana\", 68),","    Pair.of(\"Eve\", 95)",")"]},

        {"kind":"when","text":"We apply a curve to specific students using a Tuple of keys","code":["var curvedGrades = grades.updateAll(","    Tuple.of(\"Bob\", \"Diana\", \"Frank\"),  // Frank doesn't exist - ignored","    { grade -> Math.min(grade + 5, 100) }  // Add 5 points, cap at 100",")"]},

        {"kind":"then","text":"Only the specified existing students receive the curve","code":["curvedGrades.size() == 5","curvedGrades.get(\"Alice\").get() == 85     // unchanged","curvedGrades.get(\"Bob\").get() == 77       // 72 + 5","curvedGrades.get(\"Charlie\").get() == 90   // unchanged","curvedGrades.get(\"Diana\").get() == 73     // 68 + 5","curvedGrades.get(\"Eve\").get() == 95       // unchanged"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `updateAll` with a ValueSet of keys for type-safe batch updates on sorted associations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            When you already have a ValueSet of keys (perhaps from filtering or other operations),\n            the `updateAll(ValueSet, Function)` method provides a type-safe way to apply\n            transformations to all matching entries.\n\n            ValueSets maintain their own ordering and uniqueness guarantees, making this method\n            particularly useful in data processing pipelines.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association of product prices and a ValueSet of products on sale","code":["var prices = Association.betweenSorted(String, Double).putAll(","    Pair.of(\"laptop\", 999.99d),","    Pair.of(\"mouse\", 25.50d),","    Pair.of(\"keyboard\", 75.00d),","    Pair.of(\"monitor\", 299.99d),","    Pair.of(\"headphones\", 149.99d)",")","var saleProducts = prices.keySet()","    .stream()","    .filter { key -> key in [\"mouse\", \"keyboard\", \"headphones\"] }","    .collect(ValueSet.collectorOf(String))"]},

        {"kind":"when","text":"We apply a discount to all sale products","code":["var salePrices = prices.updateAll(saleProducts) { price -> price * 0.85 }  // 15% discount"]},

        {"kind":"then","text":"Only sale products receive the discount","code":["salePrices.size() == 5","salePrices.get(\"laptop\").get() == 999.99      // unchanged","salePrices.get(\"monitor\").get() == 299.99     // unchanged","salePrices.get(\"mouse\").get() == 21.675       // 25.50 * 0.85","salePrices.get(\"keyboard\").get() == 63.75     // 75.00 * 0.85","salePrices.get(\"headphones\").get() == 127.4915 // 149.99 * 0.85"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `updateAll` with a Collection of keys for flexible batch updates on sorted associations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `updateAll(Collection, Function)` method accepts any Collection implementation,\n            making it the most flexible option for batch updates. This is ideal when integrating\n            with existing Java code that uses Lists, Sets, or other collection types.\n\n            Like the other updateAll variants, it safely ignores keys that don't exist in\n            the association.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An association of website traffic statistics","code":["var traffic = Association.betweenSorted(String, Integer).putAll(","    Pair.of(\"/home\", 1500),","    Pair.of(\"/about\", 800),","    Pair.of(\"/products\", 1200),","    Pair.of(\"/contact\", 300),","    Pair.of(\"/blog\", 950)",")","var highTrafficPages = [\"/home\", \"/products\", \"/blog\", \"/nonexistent\"] as List"]},

        {"kind":"when","text":"We add bonus traffic to high-performing pages","code":["var updatedTraffic = traffic.updateAll(highTrafficPages) { views -> views + 100 }"]},

        {"kind":"then","text":"Only existing high-traffic pages receive the bonus","code":["updatedTraffic.size() == 5","updatedTraffic.get(\"/home\").get() == 1600     // 1500 + 100","updatedTraffic.get(\"/about\").get() == 800     // unchanged","updatedTraffic.get(\"/products\").get() == 1300 // 1200 + 100","updatedTraffic.get(\"/contact\").get() == 300   // unchanged","updatedTraffic.get(\"/blog\").get() == 1050     // 950 + 100"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `updateAll` with a Stream of keys for efficient pipeline processing for sorted associations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `updateAll(Stream, Function)` method is designed for stream processing scenarios.\n            When you have a stream of keys (perhaps from filtering, mapping, or other stream\n            operations), this method allows you to efficiently apply transformations without\n            intermediate collection steps.\n\n            This is particularly useful in data processing pipelines where you want to maintain\n            the lazy evaluation benefits of streams.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An association of employee data","code":["var employees = Association.betweenSorted(String, Map).putAll(","    Pair.of(\"alice\", [department: \"Engineering\", salary: 80000, level: \"Senior\"]),","    Pair.of(\"bob\", [department: \"Marketing\", salary: 65000, level: \"Mid\"]),","    Pair.of(\"charlie\", [department: \"Engineering\", salary: 75000, level: \"Mid\"]),","    Pair.of(\"diana\", [department: \"HR\", salary: 60000, level: \"Junior\"])",")"]},

        {"kind":"when","text":"We give raises to engineering employees using a filtered stream","code":["var updatedEmployees = employees.updateAll(","    employees.entrySet().stream()","        .filter { entry -> entry.second().department == \"Engineering\" }","        .map { entry -> entry.first() },","    { employeeData ->","        def updated = new HashMap(employeeData)","        updated.salary = employeeData.salary * 1.10  // 10% raise","        updated","    }",")"]},

        {"kind":"then","text":"Only engineering employees receive raises","code":["updatedEmployees.size() == 4","updatedEmployees.get(\"alice\").get().salary == 88000      // 80000 * 1.10","updatedEmployees.get(\"bob\").get().salary == 65000        // unchanged","updatedEmployees.get(\"charlie\").get().salary == 82500    // 75000 * 1.10","updatedEmployees.get(\"diana\").get().salary == 60000      // unchanged"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The update methods work correctly with large datasets and maintain performance. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A large sorted association and a subset of keys to update","code":["var largeAssoc = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> largeAssoc = largeAssoc.put(i, i * 10) }","var keysToUpdate = (0..<size).findAll { it % 3 == 0 }  // Update every 3rd key"]},

        {"kind":"when","text":"We update values for the selected keys","code":["var updatedAssoc = largeAssoc.updateAll(keysToUpdate) { value -> value + 1000 }"]},

        {"kind":"then","text":"All specified keys are updated correctly","code":["keysToUpdate.every { key ->","    updatedAssoc.get(key).get() == (key * 10) + 1000","}","(0..<size).findAll { it % 3 != 0 }.every { key ->","    updatedAssoc.get(key).get() == key * 10  // Unchanged keys","}"]},

        {"kind":"and","text":"The association size remains the same","code":["updatedAssoc.size() == size"]},

        {"kind":"where","text":"","code":{"size":["100","1000","5000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The update methods work correctly with large datasets and maintain performance. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A large sorted association and a subset of keys to update","code":["var largeAssoc = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> largeAssoc = largeAssoc.put(i, i * 10) }","var keysToUpdate = (0..<size).findAll { it % 3 == 0 }  // Update every 3rd key"]},

        {"kind":"when","text":"We update values for the selected keys","code":["var updatedAssoc = largeAssoc.updateAll(keysToUpdate) { value -> value + 1000 }"]},

        {"kind":"then","text":"All specified keys are updated correctly","code":["keysToUpdate.every { key ->","    updatedAssoc.get(key).get() == (key * 10) + 1000","}","(0..<size).findAll { it % 3 != 0 }.every { key ->","    updatedAssoc.get(key).get() == key * 10  // Unchanged keys","}"]},

        {"kind":"and","text":"The association size remains the same","code":["updatedAssoc.size() == size"]},

        {"kind":"where","text":"","code":{"size":["100","1000","5000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The update methods work correctly with large datasets and maintain performance. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A large sorted association and a subset of keys to update","code":["var largeAssoc = Association.betweenSorted(Integer, Integer)","(0..<size).each { i -> largeAssoc = largeAssoc.put(i, i * 10) }","var keysToUpdate = (0..<size).findAll { it % 3 == 0 }  // Update every 3rd key"]},

        {"kind":"when","text":"We update values for the selected keys","code":["var updatedAssoc = largeAssoc.updateAll(keysToUpdate) { value -> value + 1000 }"]},

        {"kind":"then","text":"All specified keys are updated correctly","code":["keysToUpdate.every { key ->","    updatedAssoc.get(key).get() == (key * 10) + 1000","}","(0..<size).findAll { it % 3 != 0 }.every { key ->","    updatedAssoc.get(key).get() == key * 10  // Unchanged keys","}"]},

        {"kind":"and","text":"The association size remains the same","code":["updatedAssoc.size() == size"]},

        {"kind":"where","text":"","code":{"size":["100","1000","5000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Update methods can be chained for complex transformation pipelines on sorted associations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Since all update methods return new Association instances, they can be chained\n            together to create complex transformation pipelines. This functional style\n            makes it easy to express multi-step data transformations in a readable way.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"An association representing a shopping cart","code":["var cart = Association.betweenSorted(String, Map).putAll(","    Pair.of(\"item1\", [name: \"Book\", price: 29.99, quantity: 2, category: \"education\"]),","    Pair.of(\"item2\", [name: \"Pen\", price: 2.99, quantity: 5, category: \"office\"]),","    Pair.of(\"item3\", [name: \"Notebook\", price: 4.99, quantity: 3, category: \"office\"])",")"]},

        {"kind":"when","text":"We apply a series of transformations in a pipeline","code":["var processedCart = cart","    // Apply 10% discount to education items","    .update(\"item1\") { item ->","        def updated = new HashMap(item)","        updated.price = item.price * 0.90","        updated","    }","    // Apply bulk discount for office supplies with quantity > 3","    .updateAll([\"item2\", \"item3\"] as Set) { item ->","        if (item.quantity > 3) {","            def updated = new HashMap(item)","            updated.price = item.price * 0.95  // 5% bulk discount","            updated","        } else {","            item","        }","    }","    // Calculate total for each item","    .updateAll(cart.keySet().stream()) { item ->","        def updated = new HashMap(item)","        updated.total = item.price * item.quantity","        updated","    }"]},

        {"kind":"then","text":"All transformations are applied correctly","code":["processedCart.get(\"item1\").get().price == 26.991  // 29.99 * 0.90","processedCart.get(\"item1\").get().total == 53.982  // 26.991 * 2","processedCart.get(\"item2\").get().price == 2.8405  // 2.99 * 0.95 (bulk discount)","processedCart.get(\"item2\").get().total == 14.2025 // 2.8405 * 5","processedCart.get(\"item3\").get().price == 4.99    // no bulk discount (quantity <= 3)","processedCart.get(\"item3\").get().total == 14.97   // 4.99 * 3"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Update methods preserve sorted association characteristics.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association","code":["var sortedAssoc = Association.betweenSorted(String, Integer)","    .put(\"Charlie\", 30)","    .put(\"Alice\", 25)","    .put(\"Bob\", 28)"]},

        {"kind":"when","text":"We update values in the sorted association","code":["var updatedSorted = sortedAssoc.update(\"Alice\") { age -> age + 1 }"]},

        {"kind":"then","text":"The sorted characteristic is preserved","code":["updatedSorted.isSorted()","updatedSorted.keySet().toList() == [\"Alice\", \"Bob\", \"Charlie\"]  // Still sorted"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Update methods handle complex value types and nested structures.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"A sorted association with complex nested values","code":["var complexData = Association.betweenSorted(String, Map).putAll(","    Pair.of(\"user1\", [","        profile: [name: \"Alice\", age: 30],","        preferences: [theme: \"dark\", notifications: true],","        stats: [logins: 150, lastActive: \"2024-01-15\"]","    ]),","    Pair.of(\"user2\", [","        profile: [name: \"Bob\", age: 25],","        preferences: [theme: \"light\", notifications: false],","        stats: [logins: 75, lastActive: \"2024-01-10\"]","    ])",")"]},

        {"kind":"when","text":"We update nested structures within the values","code":["var updatedData = complexData.updateAll([\"user1\", \"user2\"] as Set) { userData ->","    def updated = new HashMap(userData)","    // Increment login count and update last active","    updated.stats = new HashMap(userData.stats)","    updated.stats.logins = userData.stats.logins + 1","    updated.stats.lastActive = \"2024-01-20\"","    updated","}"]},

        {"kind":"then","text":"Nested structures are updated correctly","code":["updatedData.get(\"user1\").get().stats.logins == 151","updatedData.get(\"user1\").get().stats.lastActive == \"2024-01-20\"","updatedData.get(\"user2\").get().stats.logins == 76","updatedData.get(\"user2\").get().stats.lastActive == \"2024-01-20\"","updatedData.get(\"user1\").get().profile.name == \"Alice\"","updatedData.get(\"user2\").get().preferences.theme == \"light\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
