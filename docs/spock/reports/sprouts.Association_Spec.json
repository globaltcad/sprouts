{
  "className":"sprouts.Association_Spec",
  "title":"Associations",
  "narrative":"Sprouts is a property library with a heavy focus on bridging the\n    gap between classical place oriented programming and modern\n    data oriented programming.\n    This is why sprouts has both the `Tuple` and `Association` classes.\n    The `Association` class is a value object that represents a set of\n    key-value pairs. You can think of it as an immutable map, but with\n    an API that is designed around transforming the data in the map\n    rather than mutating it.",
  "subjects":["sprouts.Association"],
  "statistics":{
    "runs":"58",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"An empty association is created by supplying the type of the key and value",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, Integer)"]},

        {"kind":"expect","text":"","code":["associations.isEmpty()","associations.keyType() == String","associations.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An association is invariant to a map. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, String)","var map = [:]","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                map[key] = \"value of \" + key","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                map.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to the associations and the map for the first time.","code":["associations = operationsApplier(associations)"]},

        {"kind":"then","text":"The associations and the map are equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We apply the operations to the associations and the map a few more times.","code":["10.times { associations = operationsApplier(associations) }"]},

        {"kind":"then","text":"The associations and the map are still equal in terms of size, keys, and values.","code":["associations.size() == map.size()","associations.keySet().toSet() == map.keySet()","associations.values().sort().toList() == map.values().sort()"]},

        {"kind":"and","text":"We can lookup any value from its corresponding key.","code":["map.values() as Set == map.keySet().collect { key -> associations.get(key).orElseThrow(MissingItemException::new) } as Set"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = associations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Association maintains full invariance with Map across all operations.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Fresh association and reference map","code":["var assoc = Association.between(String, String)","var map = new HashMap<String,String>()","var valueGenerator = { key -> \"[value-of:$key]\".toString() }","var replacementValueGenerator = { key -> \"[replaced-value-of:$key]\".toString() }","var operationsApplier = { currentAssoc ->","    operations.each { op, key ->","        switch (op) {","            case Operation.ADD:","                currentAssoc = currentAssoc.put(key, valueGenerator(key))","                map.put(key, valueGenerator(key))","                break","            case Operation.REMOVE:","                currentAssoc = currentAssoc.remove(key)","                map.remove(key)","                break","            case Operation.REPLACE:","                currentAssoc = currentAssoc.replace(key, replacementValueGenerator(key))","                if (map.containsKey(key)) {","                    map.put(key, replacementValueGenerator(key))","                }","                break","            case Operation.PUT_IF_ABSENT:","                currentAssoc = currentAssoc.putIfAbsent(key, valueGenerator(key))","                map.putIfAbsent(key, valueGenerator(key))","                break","            case Operation.CLEAR:","                currentAssoc = currentAssoc.clear()","                map.clear()","                break","        }","    }","    return currentAssoc","}"]},

        {"kind":"when","text":"Apply operations 3 times","code":["3.times { assoc = operationsApplier(assoc) }"]},

        {"kind":"then","text":"Immediate invariance","code":["assoc.size() == map.size()","assoc.keySet().toSet() == map.keySet()","assoc.values().sort().toList() == map.values().sort()","assoc.toMap() == map"]},

        {"kind":"and","text":"","code":["map.every { k, v ->","    assoc.get(k).orElse(null) == v","}","assoc.every { pair ->","    pair.second() == map[pair.first()]","}"]},

        {"kind":"when","text":"We verify the `Iterable` implementation of the association by iterating over it.","code":["var pairSet = new HashSet()","for ( pair in assoc ) {","    pairSet.add(pair)","}"]},

        {"kind":"then","text":"The pair set is equal to the map and all sizes match.","code":["pairSet.size() == assoc.size()","pairSet.size() == map.size()","pairSet == map.collect({ k, v -> Pair.of(k, v) }).toSet()"]},

        {"kind":"where","text":"","code":{"operations":["(0..2000).collect {\n        var random = new Random(it*1997).nextInt()\n        var randKey = \"key-\"+Integer.toHexString(random)\n        var op = Operation.values()Math.abs(random % 5)]\n        return new Tuple2(op, randKey)\n    }",""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Two associations the the same operations applied to them are always equal. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map as well as a closure to apply the operations to them.","code":["var associations = Association.between(String, String)","var operationsApplier = { currentAssociations ->","    operations.each { operation, key ->","        switch (operation) {","            case Operation.ADD:","                currentAssociations = currentAssociations.put(key, \"value of \" + key)","                break","            case Operation.REMOVE:","                currentAssociations = currentAssociations.remove(key)","                break","        }","    }","    return currentAssociations","}"]},

        {"kind":"when","text":"We apply the operations to two associations and the map for the first time.","code":["var associations1 = operationsApplier(associations)","var associations2 = operationsApplier(associations)"]},

        {"kind":"and","text":"We apply some more custom operations on top:","code":["associations1 = associations1.put(\"Temp1\", \"_\").put(\"Temp2\", \"_\")","associations1 = associations1.remove(\"Temp1\").remove(\"Temp2\")"]},

        {"kind":"then","text":"The two associations are equal.","code":["associations1 == associations2"]},

        {"kind":"and","text":"Their hash codes are equal.","code":["associations1.hashCode() == associations2.hashCode()"]},

        {"kind":"when","text":"We update the second association to be a bit different.","code":["associations2 = associations2.put(\"A bit\", \"different\")"]},

        {"kind":"then","text":"The two associations are not equal.","code":["associations1 != associations2"]},

        {"kind":"and","text":"Their hash codes are not equal.","code":["associations1.hashCode() != associations2.hashCode()"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c')\n        ]","new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.ADD, 'a'),\n            new Tuple2(Operation.REMOVE, 'a'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.ADD, 'b'),\n            new Tuple2(Operation.REMOVE, 'b'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.ADD, 'c'),\n            new Tuple2(Operation.REMOVE, 'c')\n        ]","(0..100).collect({\n            var hash = Math.abs((139 * (90 + it.hashCode())) % 100)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..1_000).collect({\n            var hash = Math.abs((31 * 139 * (500 + it.hashCode())) % 1_000)\n            var operation = hash % 3 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })","(0..5_000).collect({\n            var hash = Math.abs(it % 2_000)\n            var operation = it > 2_000 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, hash.toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two associations into one using the `putAll` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"d\", 4).put(\"e\", 5).put(\"f\", 6)"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == 6","mergedAssociations.get(\"a\").orElseThrow(MissingItemException::new) == 1","mergedAssociations.get(\"b\").orElseThrow(MissingItemException::new) == 2","mergedAssociations.get(\"c\").orElseThrow(MissingItemException::new) == 3","mergedAssociations.get(\"d\").orElseThrow(MissingItemException::new) == 4","mergedAssociations.get(\"e\").orElseThrow(MissingItemException::new) == 5","mergedAssociations.get(\"f\").orElseThrow(MissingItemException::new) == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You remove the entries of one association from another, using the `removeAll(ValueSet)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"x\", 1).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"y\", 2).put(\"z\", 3).put(\"o\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"x\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You remove the entries of one association from another, using the `removeAll(Set)` method.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)"]},

        {"kind":"when","text":"We add some values to the first association.","code":["associations1 = associations1.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We add some values to the second association.","code":["associations2 = associations2.put(\"b\", 2).put(\"c\", 3).put(\"d\", 4)"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet().toSet())"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == 1","result.get(\"a\").orElseThrow(MissingItemException::new) == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `clear` method creates an empty association with the same key and value types.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, Integer)","associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"expect","text":"The association is not empty.","code":["!associations.isEmpty()"]},

        {"kind":"when","text":"We clear the association.","code":["associations = associations.clear()"]},

        {"kind":"then","text":"The association is empty.","code":["associations.isEmpty()"]},

        {"kind":"and","text":"The key and value types are the same.","code":["associations.keyType() == String","associations.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.between(String, Character)","var associations2 = Association.between(String, Character)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.between(String, Character)","var associations2 = Association.between(String, Character)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.between(String, Character)","var associations2 = Association.between(String, Character)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge two large associations into one using the `putAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create two associations and some random key and value generators.","code":["var associations1 = Association.between(String, Character)","var associations2 = Association.between(String, Character)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations1.putAll(associations2)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"when","text":"We use the `toMap()` method to convert the association to a map.","code":["var convertedMap = mergedAssociations.toMap()"]},

        {"kind":"then","text":"The converted map is equal to the reference map.","code":["convertedMap == map"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove the entries of a large association from another, using the `removeAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"Two empty associations between strings and integers.","code":["var associations1 = Association.between(String, Integer)","var associations2 = Association.between(String, Integer)","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) }"]},

        {"kind":"and","text":"We create two regular mutable maps to check the results are correct based on their `remove` method.","code":["var map1 = [:]","var map2 = [:]"]},

        {"kind":"when","text":"We add some values to the first association and map.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations1 = associations1.put(key, value)","    map1[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association and map.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    associations2 = associations2.put(key, value)","    map2[key] = value","}"]},

        {"kind":"and","text":"We remove the entries of the second association from the first.","code":["var result = associations1.removeAll(associations2.keySet())"]},

        {"kind":"and","text":"We remove the entries of the second map from the first.","code":["map2.forEach { key, value -> map1.remove(key) }"]},

        {"kind":"then","text":"The result contains only the entries that were not in the second association.","code":["result.size() == map1.size()","result.keySet() as Set == map1.keySet()","result.values().sort().toList() == map1.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.between(String, Character)","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.between(String, Character)","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.between(String, Character)","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can merge a large association and a map into a single association using the `putAll` method. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association and a map and some random key and value generators.","code":["var associations = Association.between(String, Character)","var otherMap = [:]","var indexToRandomKey = { index -> Integer.toHexString(Math.abs((929 * (42 + index as int)) % size)) }","var indexToRandomValue = { index -> Math.abs(65+(index as int)) as char }"]},

        {"kind":"and","text":"We create a regular mutable map to check the results are correct.","code":["var map = [:]"]},

        {"kind":"when","text":"We add some values to the first association.","code":["size.times { index ->","    var key = indexToRandomKey(index%(size/2))","    var value = indexToRandomValue(index)","    associations = associations.put(key, value)","    map[key] = value","}"]},

        {"kind":"and","text":"We add some values to the second association.","code":["size.times { index ->","    var key = indexToRandomKey(-index%(size/2))","    var value = indexToRandomValue(index)","    otherMap[key] = value","    map[key] = value","}"]},

        {"kind":"and","text":"We merge the two associations.","code":["var mergedAssociations = associations.putAll(otherMap)"]},

        {"kind":"then","text":"The merged association contains all the values from the two associations.","code":["mergedAssociations.size() == map.size()","mergedAssociations.keySet() as Set == map.keySet()","mergedAssociations.values().sort().toList() == map.values().sort()"]},

        {"kind":"where","text":"","code":{"size":["10","100","1_000","10_000"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An `Association` has an intuitive string representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, Integer)"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"then","text":"The string representation of the association is as expected.","code":["associations.toString() == 'Association<String,Integer>[\"b\" ↦ 2, \"c\" ↦ 3, \"a\" ↦ 1]'"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A larger `Association` will have a trimmed string representation.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(Character, Byte)"]},

        {"kind":"when","text":"We add some values to the association.","code":["30.times { index ->","    var key = Math.abs(65+(index)) as char","    var value = Math.abs(1997*index) as byte","    associations = associations.put(key, value)","}"]},

        {"kind":"then","text":"The string representation of the association is as expected.","code":["associations.toString() == \"Association<Character,Byte>['P' ↦ 3, '\\\\' ↦ -97, 'F' ↦ 1, 'W' ↦ -98, 'U' ↦ 4, 'A' ↦ 0, 'R' ↦ -99, 'Z' ↦ 5, ...22 more entries]\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `replace` method replaces the value of a key with a new value, if and only if the key is present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, Integer)"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.put(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"and","text":"We replace the value of a key that is present.","code":["associations = associations.replace(\"b\", 4)"]},

        {"kind":"then","text":"The value of the key is replaced.","code":["associations.get(\"b\").orElseThrow(MissingItemException::new) == 4"]},

        {"kind":"and","text":"The size of the association remains the same.","code":["associations.size() == 3"]},

        {"kind":"when","text":"We call the `replace` method with a key that is not present.","code":["associations = associations.replace(\"d\", 5)"]},

        {"kind":"then","text":"The size of the association remains the same.","code":["associations.size() == 3"]},

        {"kind":"and","text":"The value of the key is not replaced.","code":["!associations.get(\"d\").isPresent()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Pair...)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(String, Integer)"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll(","    Pair.of(\"I\", 1),","    Pair.of(\"was\", 2),","    Pair.of(\"added\", 3),","    Pair.of(\"to\", 4),","    Pair.of(\"the\", 5),","    Pair.of(\"association\", 6)",")"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(\"I\").orElseThrow(MissingItemException::new) == 1","associations.get(\"was\").orElseThrow(MissingItemException::new) == 2","associations.get(\"added\").orElseThrow(MissingItemException::new) == 3","associations.get(\"to\").orElseThrow(MissingItemException::new) == 4","associations.get(\"the\").orElseThrow(MissingItemException::new) == 5","associations.get(\"association\").orElseThrow(MissingItemException::new) == 6"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Tuple<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(Integer, String)"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll(","    Tuple.of(","        Pair.of(1, \"I\"),","        Pair.of(2, \"was\"),","        Pair.of(3, \"added\"),","        Pair.of(4, \"to\"),","        Pair.of(5, \"the\"),","        Pair.of(6, \"association\")","    )",")"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(1).orElseThrow(MissingItemException::new) == \"I\"","associations.get(2).orElseThrow(MissingItemException::new) == \"was\"","associations.get(3).orElseThrow(MissingItemException::new) == \"added\"","associations.get(4).orElseThrow(MissingItemException::new) == \"to\"","associations.get(5).orElseThrow(MissingItemException::new) == \"the\"","associations.get(6).orElseThrow(MissingItemException::new) == \"association\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Collection<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Collection` interface, which\n            is especially useful when you have a list of pairs that you want to\n            populate the association with.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(Integer, String)"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll([","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")","])"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 6","associations.get(1).orElseThrow(MissingItemException::new) == \"I\"","associations.get(2).orElseThrow(MissingItemException::new) == \"was\"","associations.get(3).orElseThrow(MissingItemException::new) == \"added\"","associations.get(4).orElseThrow(MissingItemException::new) == \"to\"","associations.get(5).orElseThrow(MissingItemException::new) == \"the\"","associations.get(6).orElseThrow(MissingItemException::new) == \"association\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `putAll(Set<Pair>)` to populate an association at once from multiple pairs.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            This method ensures compatibility with the `Set` interface, which\n            is especially useful when you have a set of pairs that you want to\n            populate the association with.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(Character, String)"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.putAll([","    Pair.of('I' as char, \"I\"),","    Pair.of('w' as char, \"was\"),","    Pair.of('a' as char, \"added\"),","    Pair.of('t' as char, \"to\"),","    Pair.of('t' as char, \"the\"), // overwrites the previous value","    Pair.of('a' as char, \"association\") // overwrites the previous value","])"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 4","associations.get('I' as char).orElseThrow(MissingItemException::new) == \"I\"","associations.get('w' as char).orElseThrow(MissingItemException::new) == \"was\"","associations.get('a' as char).orElseThrow(MissingItemException::new) == \"association\"","associations.get('t' as char).orElseThrow(MissingItemException::new) == \"the\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent(K, V)` method adds a key-value pair to the association if, and only if, the key is not present.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"We create an association between shorts and chars and add a bunch of entries to the association.","code":["var associations = Association.between(Short, Character).putAll([","    Pair.of(11 as short, 'a' as char),","    Pair.of(22 as short, 'b' as char),","    Pair.of(33 as short, 'c' as char),","    Pair.of(44 as short, 'x' as char),","    Pair.of(55 as short, 'y' as char),","    Pair.of(66 as short, 'z' as char)","])"]},

        {"kind":"when","text":"We add a new entry to the association.","code":["associations = associations.putIfAbsent(77 as short, 'w' as char)"]},

        {"kind":"then","text":"The new entry is added to the association.","code":["associations.size() == 7","associations.get(77 as short).orElseThrow(MissingItemException::new) == 'w' as char"]},

        {"kind":"when","text":"We try to add an entry with a key that is already present.","code":["associations = associations.putIfAbsent(44 as short, 'v' as char)"]},

        {"kind":"then","text":"The association remains the same.","code":["associations.size() == 7","associations.get(44 as short).orElseThrow(MissingItemException::new) == 'x' as char"]},

        {"kind":"when","text":"We now ry this for every key in the association.","code":["associations.keySet().forEach { key ->","    associations = associations.putIfAbsent(key, '!' as char)","}"]},

        {"kind":"then","text":"The association still remains the same.","code":["associations.size() == 7","associations.get(44 as short).orElseThrow(MissingItemException::new) == 'x' as char"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `Association.between(Number.class, Number.class)` to create an association between all kinds of numbers.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.between(Number.class, Number.class)"]},

        {"kind":"expect","text":"","code":["associations.isEmpty()","associations.keyType() == Number.class","associations.valueType() == Number.class"]},

        {"kind":"when","text":"We add some values to the association.","code":["associations = associations.put(1, 1).put(2L, 2L).put(3.0f, 3.0f).put(4.0, 4.0)"]},

        {"kind":"then","text":"The association contains the values.","code":["associations.size() == 4","associations.get(1).orElseThrow(MissingItemException::new) == 1","associations.get(2L).orElseThrow(MissingItemException::new) == 2L","associations.get(3.0f).orElseThrow(MissingItemException::new) == 3.0f","associations.get(4.0).orElseThrow(MissingItemException::new) == 4.0"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The classTyped method returns the correct class and handles null parameters",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["var associationClass = Association.classTyped(String, Integer)"]},

        {"kind":"then","text":"","code":["associationClass == Association.class"]},

        {"kind":"when","text":"","code":["Association.classTyped(null, Integer)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["Association.classTyped(String, null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The of factory method throws NPE for null parameters",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"","code":["Association.of(null, \"value\")"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"","code":["Association.of(\"key\", null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `entrySet` is immutable and contains correct pairs",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.of(\"a\", 1).put(\"b\", 2)"]},

        {"kind":"when","text":"","code":["var entryValueSet = assoc.entrySet()","var entrySet = entryValueSet.toSet()"]},

        {"kind":"then","text":"","code":["entrySet.size() == 2","entrySet.contains(Pair.of(\"a\", 1))","entrySet.contains(Pair.of(\"b\", 2))"]},

        {"kind":"and","text":"","code":["entryValueSet.size() == 2","entryValueSet.contains(Pair.of(\"a\", 1))","entryValueSet.contains(Pair.of(\"b\", 2))"]},

        {"kind":"when","text":"","code":["entrySet.add(Pair.of(\"c\", 3))"]},

        {"kind":"then","text":"","code":["thrown(UnsupportedOperationException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can iterate over the `entrySet` of all pairs in an `Association`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.between(Integer, String).putAll(","    Pair.of(1, \"I\"),","    Pair.of(2, \"was\"),","    Pair.of(3, \"added\"),","    Pair.of(4, \"to\"),","    Pair.of(5, \"the\"),","    Pair.of(6, \"association\")",")"]},

        {"kind":"when","text":"","code":["var entries = []","for (var entry : assoc.entrySet().toSet()) {","    entries << entry","}"]},

        {"kind":"then","text":"","code":["entries.size() == 6","entries.contains(Pair.of(1, \"I\"))","entries.contains(Pair.of(2, \"was\"))","entries.contains(Pair.of(3, \"added\"))","entries.contains(Pair.of(4, \"to\"))","entries.contains(Pair.of(5, \"the\"))","entries.contains(Pair.of(6, \"association\"))"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"replaceAll with Map only updates existing keys",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.of(\"a\", 1).put(\"b\", 2).put(\"c\", 3)","var replacementMap = [a:10, d:40, c:30] as Map"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(replacementMap)"]},

        {"kind":"then","text":"","code":["updated.size() == 3","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2  // Should remain unchanged","updated.get(\"c\").get() == 30","!updated.containsKey(\"d\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainAll` method keeps only specified keys",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.of(\"a\", 1).put(\"b\", 2).put(\"c\", 3)"]},

        {"kind":"when","text":"","code":["var retained = assoc.retainAll([\"a\", \"c\"] as Set)"]},

        {"kind":"then","text":"","code":["retained.size() == 2","retained.containsKey(\"a\")","retained.containsKey(\"c\")","!retained.containsKey(\"b\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `putIfAbsent` does not overwrite an existing value already stored in an association.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.of(\"a\", 1).putIfAbsent(\"a\", 2)"]},

        {"kind":"expect","text":"","code":["assoc.get(\"a\").get() == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Associations with same entries in different order are equal",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc1 = Association.of(\"a\", 1).put(\"b\", 2).put(\"c\", 3)","var assoc2 = Association.of(\"c\", 3).put(\"b\", 2).put(\"a\", 1)"]},

        {"kind":"expect","text":"","code":["assoc1 == assoc2","assoc1.hashCode() == assoc2.hashCode()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"values() contains all values including duplicates",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var assoc = Association.of(\"a\", 10)","    .put(\"b\", 20)","    .put(\"c\", 10) // Duplicate value"]},

        {"kind":"when","text":"","code":["var values = assoc.values()"]},

        {"kind":"then","text":"","code":["values.size() == 3","values.sort().toList() == [10, 10, 20]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"replaceAll ignores non-existing keys in replacement stream",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = Association.of(\"a\", 1).put(\"b\", 2)","var replacements = [Pair.of(\"k\", -40), Pair.of(\"a\", 10), Pair.of(\"v\", 30)]"]},

        {"kind":"when","text":"","code":["var updated = original.replaceAll(replacements.stream())"]},

        {"kind":"then","text":"","code":["updated.size() == 2","updated.get(\"a\").get() == 10","updated.get(\"b\").get() == 2 // Unchanged","!updated.containsKey(\"k\")","!updated.containsKey(\"v\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"clear on empty association returns an empty instance",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var emptyAssoc = Association.between(String, Integer).clear()"]},

        {"kind":"expect","text":"","code":["emptyAssoc.isEmpty()","emptyAssoc.keyType() == String","emptyAssoc.valueType() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `Association` class is an `Iterable` which allows you to iterate over its entries.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var associations = Association.of(\"x\", 1).put(\"y\", 2).put(\"z\", 3)"]},

        {"kind":"when","text":"","code":["var entries = []","for (var entry : associations) {","    entries << entry","}"]},

        {"kind":"then","text":"","code":["entries.size() == 3","entries.contains(Pair.of(\"x\", 1))","entries.contains(Pair.of(\"y\", 2))","entries.contains(Pair.of(\"z\", 3))"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `Association.collectorOf(Class,Class)` to collect a stream of `Pair`s into a new `Association`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var sentence = Stream.of(","    Pair.of(0, \"I\"),","    Pair.of(1, \"watch\"),","    Pair.of(2, \"dominion\"),","    Pair.of(3, \"documentary\"),","    Pair.of(4, \"on\"),","    Pair.of(5, \"www.dominionmovement.com\")",")"]},

        {"kind":"when","text":"","code":["var associations = sentence.collect(Association.collectorOf(Integer, String))"]},

        {"kind":"then","text":"","code":["associations.size() == 6","associations.get(0).get() == \"I\"","associations.get(1).get() == \"watch\"","associations.get(2).get() == \"dominion\"","associations.get(3).get() == \"documentary\"","associations.get(4).get() == \"on\"","associations.get(5).get() == \"www.dominionmovement.com\""]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
