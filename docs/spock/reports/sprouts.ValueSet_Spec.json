{
  "className":"sprouts.ValueSet_Spec",
  "title":"ValueSet - a Data Oriented Set",
  "narrative":"ValueSet is a fundamental building block in sprouts' data-oriented programming model.\n    It represents an immutable collection of unique elements, providing an API focused on\n    deriving new sets from existing ones rather than mutating state. Unlike traditional\n    Java sets, all operations return new `ValueSet` instances, making it ideal for\n    functional-style programming and safe concurrent usage.",
  "subjects":["sprouts.ValueSet"],
  "statistics":{
    "runs":"132",
    "successRate":"100.0%",
    "failures":"0",
    "errors":"0",
    "skipped":"0",
    "duration":"?"
  },
  "headers":[],"tags":{},"see":[],
  "features":[ 
    {
      "id":"Use `ValueSet.of(Class, Iterable)` to create a value set from an iterable.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var iterable = [\"a\", \"b\", \"c\", \"d\", \"e\"] as Iterable<String>"]},

        {"kind":"when","text":"","code":["var valueSet = ValueSet.of(String, iterable)"]},

        {"kind":"then","text":"","code":["valueSet.size() == 5","valueSet.type() == String","valueSet.toSet() == [\"a\", \"b\", \"c\", \"d\", \"e\"] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"An empty ValueSet is created by specifying the element type",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            A `ValueSet` needs to be created with a type to allow for better\n            type safety during runtime as well as improved performance\n            due to primitive specialization.\n            A `ValueSet` based on the `Integer` class for example, will\n            internally use a primitive `int[]` array to store the values.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var emptySet = ValueSet.of(String)"]},

        {"kind":"expect","text":"","code":["emptySet.isEmpty()","emptySet.type() == String","!emptySet.isSorted()"]},

        {"kind":"when","text":"","code":["var emptySet2 = ValueSet.of(Integer)"]},

        {"kind":"then","text":"","code":["emptySet2.isEmpty()","emptySet2.type() == Integer","!emptySet2.isSorted()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `ValueSet` maintains invariance with Java Set across operations [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(String)","var referenceSet = new HashSet<>()","var operationsApplier = { currentSet ->","    operations.each { op, element ->","        switch (op) {","            case Operation.ADD:","                currentSet = currentSet.add(element)","                referenceSet.add(element)","                break","            case Operation.REMOVE:","                currentSet = currentSet.remove(element)","                referenceSet.remove(element)","                break","            case Operation.CLEAR:","                currentSet = currentSet.clear()","                referenceSet.clear()","                break","        }","    }","    return currentSet","}"]},

        {"kind":"when","text":"Apply operations first time","code":["valueSet = operationsApplier(valueSet)"]},

        {"kind":"then","text":"Immediate invariance","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { valueSet = operationsApplier(valueSet) }"]},

        {"kind":"then","text":"Consistent state","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"We use the stream API to map both the value set and the JDK based reference set.","code":["var mappedValueSet = valueSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSet = referenceSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and mapped set are equal.","code":["mappedValueSet.toSet() == mappedSet"]},

        {"kind":"when","text":"We use the parallel stream API to map both the value set and the reference set.","code":["var mappedValueSetParallel = valueSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSetParallel = referenceSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and JDK set are equal in terms of their contents.","code":["mappedValueSetParallel.toSet() == mappedSetParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n                new Tuple2(Operation.ADD, \"banana\"),\n                new Tuple2(Operation.REMOVE, \"apple\")\n        ]","(0..100).collect {\n            new Tuple2(it % 2 == 0 ? Operation.ADD : Operation.REMOVE,\n                    \"item-\"+(it % 50))\n        }","(0..1000).collect {\n            new Tuple2(new Random(it).nextBoolean() ? Operation.ADD : Operation.REMOVE,\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500))\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `ValueSet` maintains invariance with Java Set across operations [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(String)","var referenceSet = new HashSet<>()","var operationsApplier = { currentSet ->","    operations.each { op, element ->","        switch (op) {","            case Operation.ADD:","                currentSet = currentSet.add(element)","                referenceSet.add(element)","                break","            case Operation.REMOVE:","                currentSet = currentSet.remove(element)","                referenceSet.remove(element)","                break","            case Operation.CLEAR:","                currentSet = currentSet.clear()","                referenceSet.clear()","                break","        }","    }","    return currentSet","}"]},

        {"kind":"when","text":"Apply operations first time","code":["valueSet = operationsApplier(valueSet)"]},

        {"kind":"then","text":"Immediate invariance","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { valueSet = operationsApplier(valueSet) }"]},

        {"kind":"then","text":"Consistent state","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"We use the stream API to map both the value set and the JDK based reference set.","code":["var mappedValueSet = valueSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSet = referenceSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and mapped set are equal.","code":["mappedValueSet.toSet() == mappedSet"]},

        {"kind":"when","text":"We use the parallel stream API to map both the value set and the reference set.","code":["var mappedValueSetParallel = valueSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSetParallel = referenceSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and JDK set are equal in terms of their contents.","code":["mappedValueSetParallel.toSet() == mappedSetParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n                new Tuple2(Operation.ADD, \"banana\"),\n                new Tuple2(Operation.REMOVE, \"apple\")\n        ]","(0..100).collect {\n            new Tuple2(it % 2 == 0 ? Operation.ADD : Operation.REMOVE,\n                    \"item-\"+(it % 50))\n        }","(0..1000).collect {\n            new Tuple2(new Random(it).nextBoolean() ? Operation.ADD : Operation.REMOVE,\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500))\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `ValueSet` maintains invariance with Java Set across operations [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(String)","var referenceSet = new HashSet<>()","var operationsApplier = { currentSet ->","    operations.each { op, element ->","        switch (op) {","            case Operation.ADD:","                currentSet = currentSet.add(element)","                referenceSet.add(element)","                break","            case Operation.REMOVE:","                currentSet = currentSet.remove(element)","                referenceSet.remove(element)","                break","            case Operation.CLEAR:","                currentSet = currentSet.clear()","                referenceSet.clear()","                break","        }","    }","    return currentSet","}"]},

        {"kind":"when","text":"Apply operations first time","code":["valueSet = operationsApplier(valueSet)"]},

        {"kind":"then","text":"Immediate invariance","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { valueSet = operationsApplier(valueSet) }"]},

        {"kind":"then","text":"Consistent state","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"We use the stream API to map both the value set and the JDK based reference set.","code":["var mappedValueSet = valueSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSet = referenceSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and mapped set are equal.","code":["mappedValueSet.toSet() == mappedSet"]},

        {"kind":"when","text":"We use the parallel stream API to map both the value set and the reference set.","code":["var mappedValueSetParallel = valueSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSetParallel = referenceSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and JDK set are equal in terms of their contents.","code":["mappedValueSetParallel.toSet() == mappedSetParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n                new Tuple2(Operation.ADD, \"banana\"),\n                new Tuple2(Operation.REMOVE, \"apple\")\n        ]","(0..100).collect {\n            new Tuple2(it % 2 == 0 ? Operation.ADD : Operation.REMOVE,\n                    \"item-\"+(it % 50))\n        }","(0..1000).collect {\n            new Tuple2(new Random(it).nextBoolean() ? Operation.ADD : Operation.REMOVE,\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500))\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `ValueSet` maintains invariance with Java Set across operations [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(String)","var referenceSet = new HashSet<>()","var operationsApplier = { currentSet ->","    operations.each { op, element ->","        switch (op) {","            case Operation.ADD:","                currentSet = currentSet.add(element)","                referenceSet.add(element)","                break","            case Operation.REMOVE:","                currentSet = currentSet.remove(element)","                referenceSet.remove(element)","                break","            case Operation.CLEAR:","                currentSet = currentSet.clear()","                referenceSet.clear()","                break","        }","    }","    return currentSet","}"]},

        {"kind":"when","text":"Apply operations first time","code":["valueSet = operationsApplier(valueSet)"]},

        {"kind":"then","text":"Immediate invariance","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { valueSet = operationsApplier(valueSet) }"]},

        {"kind":"then","text":"Consistent state","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"We use the stream API to map both the value set and the JDK based reference set.","code":["var mappedValueSet = valueSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSet = referenceSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and mapped set are equal.","code":["mappedValueSet.toSet() == mappedSet"]},

        {"kind":"when","text":"We use the parallel stream API to map both the value set and the reference set.","code":["var mappedValueSetParallel = valueSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSetParallel = referenceSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and JDK set are equal in terms of their contents.","code":["mappedValueSetParallel.toSet() == mappedSetParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n                new Tuple2(Operation.ADD, \"banana\"),\n                new Tuple2(Operation.REMOVE, \"apple\")\n        ]","(0..100).collect {\n            new Tuple2(it % 2 == 0 ? Operation.ADD : Operation.REMOVE,\n                    \"item-\"+(it % 50))\n        }","(0..1000).collect {\n            new Tuple2(new Random(it).nextBoolean() ? Operation.ADD : Operation.REMOVE,\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500))\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `ValueSet` maintains invariance with Java Set across operations [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(String)","var referenceSet = new HashSet<>()","var operationsApplier = { currentSet ->","    operations.each { op, element ->","        switch (op) {","            case Operation.ADD:","                currentSet = currentSet.add(element)","                referenceSet.add(element)","                break","            case Operation.REMOVE:","                currentSet = currentSet.remove(element)","                referenceSet.remove(element)","                break","            case Operation.CLEAR:","                currentSet = currentSet.clear()","                referenceSet.clear()","                break","        }","    }","    return currentSet","}"]},

        {"kind":"when","text":"Apply operations first time","code":["valueSet = operationsApplier(valueSet)"]},

        {"kind":"then","text":"Immediate invariance","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"Apply operations multiple times","code":["5.times { valueSet = operationsApplier(valueSet) }"]},

        {"kind":"then","text":"Consistent state","code":["valueSet.size() == referenceSet.size()","valueSet.containsAll(referenceSet)","valueSet.toSet() == referenceSet"]},

        {"kind":"when","text":"We use the stream API to map both the value set and the JDK based reference set.","code":["var mappedValueSet = valueSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSet = referenceSet.stream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and mapped set are equal.","code":["mappedValueSet.toSet() == mappedSet"]},

        {"kind":"when","text":"We use the parallel stream API to map both the value set and the reference set.","code":["var mappedValueSetParallel = valueSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(ValueSet.collectorOf(String.class))","var mappedSetParallel = referenceSet.parallelStream().map({ it.toUpperCase() + \"!\" }).filter({ it.hashCode() % 2 == 0 }).collect(Collectors.toSet())"]},

        {"kind":"then","text":"The mapped value set and JDK set are equal in terms of their contents.","code":["mappedValueSetParallel.toSet() == mappedSetParallel"]},

        {"kind":"where","text":"","code":{"operations":["new Tuple2(Operation.ADD, \"apple\"),\n                new Tuple2(Operation.ADD, \"banana\"),\n                new Tuple2(Operation.REMOVE, \"apple\")\n        ]","(0..100).collect {\n            new Tuple2(it % 2 == 0 ? Operation.ADD : Operation.REMOVE,\n                    \"item-\"+(it % 50))\n        }","(0..1000).collect {\n            new Tuple2(new Random(it).nextBoolean() ? Operation.ADD : Operation.REMOVE,\n                    \"element-\"+Math.abs(new Random(it).nextInt() % 500))\n        }","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 50, which\n                means 50 add operations, then 50 remove operations then 50 add... etc.\n                There is a total of 160 possible values!\n             */\n            var hash = Math.abs((it*1997) % 160)\n            var operation = ((int)(it/50)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })","(0..10_000).collect({\n            /*\n                Here the operations come in sequences of 100, which\n                means 100 add operations, then 100 remove operations then 100 add... etc.\n                There is a total of 190 possible values!\n             */\n            var hash = Math.abs((it*1997) % 190)\n            var operation = ((int)(it/100)) % 2 == 0 ? Operation.REMOVE : Operation.ADD\n            return new Tuple2(operation, (hash*1997).toString())\n        })"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Set operations maintain mathematical set properties",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(Integer).add(1).add(2).add(3)"]},

        {"kind":"when","text":"Union with another set","code":["var union = initial.addAll(ValueSet.of(3,4,5))"]},

        {"kind":"then","text":"","code":["union.toSet() == [1,2,3,4,5] as Set"]},

        {"kind":"when","text":"Intersection","code":["var intersection = initial.retainAll([2,3,4] as Set)"]},

        {"kind":"then","text":"","code":["intersection.toSet() == [2,3] as Set"]},

        {"kind":"when","text":"Difference","code":["var difference = initial.removeAll([3] as Set)"]},

        {"kind":"then","text":"","code":["difference.toSet() == [1,2] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Equality and hash code follow set semantics",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var set1 = ValueSet.of(\"a\", \"b\", \"c\")","var set2 = ValueSet.of(\"c\", \"b\", \"a\")","var set3 = set1.add(\"d\")"]},

        {"kind":"expect","text":"","code":["set1 == set2","set1.hashCode() == set2.hashCode()","set1 != set3"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Bulk operations handle large datasets efficiently",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var size = 10_000","var elements = (1..size).collect { \"item-\"+it }","var valueSet = ValueSet.of(String).addAll(elements)"]},

        {"kind":"expect","text":"","code":["valueSet.size() == size","elements.every { valueSet.contains(it) }"]},

        {"kind":"when","text":"","code":["var removed = valueSet.removeAll(elements[0..5000])"]},

        {"kind":"then","text":"","code":["removed.size() == size - 5001"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Immutable characteristics are preserved",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var original = ValueSet.of(\"a\", \"b\")","var modified = original.add(\"c\")"]},

        {"kind":"expect","text":"","code":["original.size() == 2","modified.size() == 3","!original.contains(\"c\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `clear` operation works on a non-empty value set",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var set = ValueSet.of(1,2,3)"]},

        {"kind":"expect","text":"Contains checks","code":["set.isNotEmpty() && set.size() == 3","set.contains(2) && !set.contains(4)"]},

        {"kind":"when","text":"We apply the clear operation.","code":["var cleared = set.clear()"]},

        {"kind":"then","text":"","code":["cleared.isEmpty()","cleared.type() == Integer"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"String representation reflects contents",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var smallSet = ValueSet.of(\"a\", \"b\", \"c\")","var largeSet = ValueSet.of(Integer).addAll(1..35)"]},

        {"kind":"expect","text":"","code":["smallSet.toString() == 'ValueSet<String>[\"b\", \"c\", \"a\"]'","largeSet.toString().contains(\"... 27 items left]\")"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Edge cases are handled gracefully",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"Adding null element","code":["ValueSet.of(String).add(null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]},

        {"kind":"when","text":"Null element type","code":["ValueSet.of(null)"]},

        {"kind":"then","text":"","code":["thrown(NullPointerException)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Stream integration works properly",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var elements = [\"apple\", \"banana\", \"cherry\"]","var stream = elements.stream()"]},

        {"kind":"when","text":"","code":["var collectedSet = stream.collect(ValueSet.collectorOf(String))"]},

        {"kind":"then","text":"","code":["collectedSet.toSet() == elements as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Set operations with Java collections",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(\"a\", \"b\", \"c\")","var javaSet = [\"b\", \"c\", \"d\"] as Set"]},

        {"kind":"when","text":"Union with Java set","code":["var union = valueSet.addAll(javaSet)"]},

        {"kind":"then","text":"","code":["union.toSet() == [\"a\", \"b\", \"c\", \"d\"] as Set"]},

        {"kind":"when","text":"Intersection with Java set","code":["var intersection = valueSet.retainAll(javaSet)"]},

        {"kind":"then","text":"","code":["intersection.toSet() == [\"b\", \"c\"] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Iterator behavior conforms to set semantics",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var set = ValueSet.of(1,2,3)","var iterated = []"]},

        {"kind":"when","text":"","code":["for ( var element : set ) {","    iterated << element","}"]},

        {"kind":"then","text":"","code":["iterated.size() == 3","iterated as Set == [1,2,3] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Empty set special cases",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var empty = ValueSet.of(String).clear()"]},

        {"kind":"expect","text":"","code":["empty.isEmpty()","empty.type() == String","empty.add(\"test\").size() == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Duplicate additions have no effect",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var set = ValueSet.of(\"a\").add(\"a\").add(\"a\")"]},

        {"kind":"expect","text":"","code":["set.size() == 1"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"addAll supports various collection types",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(\"a\")"]},

        {"kind":"expect","text":"Elements from different collection types are added correctly","code":["initial.addAll([\"b\", \"c\"] as List).toSet() == [\"a\", \"b\", \"c\"] as Set","initial.addAll([\"b\", \"c\"] as Set).toSet() == [\"a\", \"b\", \"c\"] as Set","initial.addAll(Tuple.of(\"b\", \"c\")).toSet() == [\"a\", \"b\", \"c\"] as Set","initial.addAll([\"b\", \"c\"] as String[]).toSet() == [\"a\", \"b\", \"c\"] as Set","initial.addAll(Stream.of(\"b\", \"c\")).toSet() == [\"a\", \"b\", \"c\"] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"removeAll handles different input collection types",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(\"a\", \"b\", \"c\", \"d\")"]},

        {"kind":"expect","text":"Elements are removed regardless of input collection type","code":["initial.removeAll([\"a\", \"b\"] as List).toSet() == [\"c\", \"d\"] as Set","initial.removeAll([\"c\"] as Set).toSet() == [\"a\", \"b\", \"d\"] as Set","initial.removeAll(Tuple.of(\"d\", \"e\")).toSet() == [\"a\", \"b\", \"c\"] as Set","initial.removeAll([\"b\", \"c\"] as String[]).toSet() == [\"a\", \"d\"] as Set","initial.removeAll(Stream.of(\"a\", \"d\")).toSet() == [\"b\", \"c\"] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can remove items from a value set selectively, using `removeIf(Predicate)`. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can remove elements from a value set which satisfy\n            a given `Predicate`. Or in other words,\n            if the `Predicate.test(Object)` method yields `true` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"We apply a predicate to both types of sets...","code":["var updatedValueSet = valueSet.removeIf(predicate)","set.removeIf(predicate)"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"You can keep items in a value set selectively, using `retainIf(Predicate)`. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            You can keep elements in a value set which satisfy\n            a given `Predicate` and have them removed otherwise. Or in other words,\n            if the `Predicate.test(Object)` method yields `false` for a particular\n            element, then it will be removed, otherwise, it will remain in the\n            returned set.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create a value set and a regular JDK set containing some test elements.","code":["var valueSet = ValueSet.of(type, elements)","var set = elements.toSet()"]},

        {"kind":"when","text":"\n            We apply a predicate to both types of sets...\n            In case of the JDK set we use the negation of `removeIf`,\n            which does the same thing effectively.\n        ","code":["var updatedValueSet = valueSet.retainIf(predicate)","set.removeIf(predicate.negate())"]},

        {"kind":"then","text":"They contain the same elements!","code":["updatedValueSet.toSet() == set"]},

        {"kind":"where","text":"","code":{"type":["Float","Integer","String","Short","Character","Boolean","Month"],"elements":["[4.3f, 7f, 0.1f, 26.34f, 23f, 86.3f, 218f, 2f, 1.2f, 9f]","(-50..50).toList()","(-50..50).collect({Integer it -> it + \"!\"}).toList()","(0..1000).collect({Integer it -> it as Short}).toList()","['a' as char, 'x' as char, '4' as char, '#' as char]","(0..100).collect({Integer it -> ( it * 1997 ) % 2 == 0})","(0..100).collect({Integer it -> Month.values()[it%12]})"],"predicate":["{ (it - it % 1) == it  }","{ it % 3 == 1 }","{ it.hashCode() % 5 == 1 }","{ it * 1997 % 8 == 2 }","{ it == 'x' as char }","{ it }","{ it == Month.DECEMBER }"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"retainAll works with diverse collection sources",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(\"a\", \"b\", \"c\", \"d\")"]},

        {"kind":"expect","text":"Only elements present in both collections are retained","code":["initial.retainAll([\"b\", \"c\"] as List).toSet() == [\"b\", \"c\"] as Set","initial.retainAll([\"a\", \"d\"] as Set).toSet() == [\"a\", \"d\"] as Set","initial.retainAll(Tuple.of(\"c\", \"e\")).toSet() == [\"c\"] as Set","initial.retainAll([\"d\"] as String[]).toSet() == [\"d\"] as Set","initial.retainAll(Stream.of(\"a\", \"b\")).toSet() == [\"a\", \"b\"] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The various `containsAll(..)` methods accurately check membership across collection types.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(\"a\", \"b\", \"c\")"]},

        {"kind":"expect","text":"Membership checks work with all compatible collection types","code":["valueSet.containsAll([\"a\", \"b\"] as List)","valueSet.containsAll([\"b\", \"c\"] as Set)","valueSet.containsAll([\"b\", \"c\"] as Iterable<String>)","valueSet.containsAll([\"a\", \"b\", \"c\"] as String[])","valueSet.containsAll([\"a\", \"b\", \"c\"].stream())","valueSet.containsAll(Stream.of(\"b\", \"c\"))","valueSet.containsAll(Tuple.of(\"a\", \"c\"))","!valueSet.containsAll([\"a\", \"d\"] as List)","!valueSet.containsAll([\"a\", \"d\"] as Set)","!valueSet.containsAll([\"a\", \"d\"] as Iterable<String>)","!valueSet.containsAll([\"a\", \"d\"] as String[])","!valueSet.containsAll([\"a\", \"d\"].stream())","!valueSet.containsAll(Tuple.of(\"a\", \"d\"))","valueSet.containsAll([] as Set) // Empty collection always returns true","valueSet.containsAll(ValueSet.of(\"a\", \"c\"))","!valueSet.containsAll(ValueSet.of(\"b\", \"c\", \"d\"))"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"operations with empty collections have no effect or clear as expected",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(\"a\", \"b\")"]},

        {"kind":"expect","text":"Empty inputs leave set unchanged or clear appropriately","code":["initial.addAll([] as Set) == initial","initial.removeAll([] as Set) == initial","initial.retainAll([\"a\", \"b\"] as Set) == initial"]},

        {"kind":"when","text":"Retaining nothing clears the set","code":["var cleared = initial.retainAll([] as Set)"]},

        {"kind":"then","text":"","code":["cleared.isEmpty()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"bulk operations ignore duplicate elements in input",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(\"a\")"]},

        {"kind":"expect","text":"Duplicates in input collections have no effect","code":["initial.addAll([\"a\", \"a\", \"b\"] as List).toSet() == [\"a\", \"b\"] as Set","initial.removeAll([\"a\", \"a\"] as List).isEmpty()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"interoperates with Tuple collections",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(\"x\", \"y\", \"z\")","var valueSet = ValueSet.of(String).addAll(tuple)"]},

        {"kind":"expect","text":"Full interoperability with Tuple collections","code":["valueSet.containsAll(tuple)","valueSet.removeAll(tuple).isEmpty()"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"collector works with different stream sources",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"when","text":"Collecting from various stream sources","code":["var fromList = [\"a\", \"b\"].stream().collect(ValueSet.collectorOf(String))","var fromSet = ([\"c\", \"d\"] as Set).stream().collect(ValueSet.collectorOf(String))","var fromArray = Arrays.stream([\"e\", \"f\"] as String[]).collect(ValueSet.collectorOf(String))","var fromTuple = Tuple.of(\"g\", \"h\").stream().collect(ValueSet.collectorOf(String))"]},

        {"kind":"then","text":"All collected sets match source contents","code":["fromList.toSet() == [\"a\", \"b\"] as Set","fromSet.toSet() == [\"c\", \"d\"] as Set","fromArray.toSet() == [\"e\", \"f\"] as Set","fromTuple.toSet() == [\"g\", \"h\"] as Set"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"no-op operations return the same instance",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var initial = ValueSet.of(\"a\", \"b\", \"c\", \"d\")","var sameElements = [\"a\", \"b\", \"c\", \"d\"] as Set<String>","var empty = Collections.emptySet() as Set<String>"]},

        {"kind":"expect","text":"Using no-op operations on the initial set does not return a new instance.","code":["initial.addAll(empty).is(initial)","initial.addAll(sameElements).is(initial)","initial.removeAll(empty).is(initial)","initial.retainAll(sameElements).is(initial)"]},

        {"kind":"and","text":"Adding existing elements does not change the set.","code":["initial.add(\"a\").is(initial)","initial.add(\"b\").is(initial)","initial.add(\"c\").is(initial)","initial.add(\"d\").is(initial)"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use `ValueSet.classTyped(Class)` to created a typed class pointer to `ValueSet`.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var typed = ValueSet.classTyped(String)"]},

        {"kind":"expect","text":"","code":["typed == ValueSet.class"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A value set can directly be created from a tuple.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var tuple = Tuple.of(\"c\", \"a\", \"b\", \"a\", \"c\", \"b\", \"c\", \"d\", \"e\", \"b\")"]},

        {"kind":"when","text":"","code":["var valueSet = ValueSet.of(tuple)"]},

        {"kind":"then","text":"","code":["valueSet.size() == 5","valueSet.toSet() == [\"a\", \"b\", \"c\", \"d\", \"e\"] as Set","valueSet.containsAll(tuple)","valueSet.type() == String"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Use the `sort(Comparator)` method to create a sorted value set.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(\"c\", \"a\", \"b\", \"a\", \"c\", \"b\", \"c\", \"d\", \"e\", \"b\")"]},

        {"kind":"when","text":"","code":["var sorted = valueSet.sort(Comparator.naturalOrder())"]},

        {"kind":"then","text":"","code":["sorted.size() == 5","sorted.type() == String","sorted.toList() == [\"a\", \"b\", \"c\", \"d\", \"e\"]"]},

        {"kind":"when","text":"We sort the value set in reverse order.","code":["var sortedReverse = valueSet.sort(Comparator.reverseOrder())"]},

        {"kind":"then","text":"","code":["sortedReverse.size() == 5","sortedReverse.type() == String","sortedReverse.toList() == [\"e\", \"d\", \"c\", \"b\", \"a\"]"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"A `ValueSet` can handle all kinds of item types. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"","code":["var valueSet = ValueSet.of(Tuple.of(type, items))","var set = items as Set"]},

        {"kind":"expect","text":"","code":["valueSet.type() == type"]},

        {"kind":"when","text":"","code":["var tupleResult = valueSet.removeAll(valueSet.toTuple().sort().slice(1, 5))"]},

        {"kind":"and","text":"","code":["var setResult = set - set.toList().toSorted().subList(1, 5)"]},

        {"kind":"then","text":"","code":["tupleResult.toSet() == setResult"]},

        {"kind":"where","text":"","code":{"type":["Integer","Byte","Short","Long","Float","Double","Character","String"],"items":["[0,5,-4,-3,5,1,0,4,8,41,2,6,-3,9,4,5] as int[]","[2,8,1,7,5,1,3,7,8,41,2,7,3,0,-4,8,1] as byte[]","[4,5,7,93,5,1,2,77,8,41,2,6,63,9,4,7] as short[]","[6,6,-8,23,5,1,-60,6,-3,41,6,6,3,9,4] as long[]","[0.3f,5f,9.3f,6f,5.2f,1.67f,7f,3f,0f] as float[]","[6.4,-5.2,1d,0d,5.2d,1.11d,5d,83d,3d] as double[]","[0,4,4,7,5,1,8,6,3,41,2,6,3,9,4,84,5] as char[]","[\"watch\",\"dominion\",\"movie\",\"now\",\"!\"] as String[]"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet work reliably for a large number of entries. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledElements1 = elements.toSorted(randomSort1)","var scrambledElements2 = elements.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type, scrambledElements1)","var set2 = ValueSet.of(type, scrambledElements2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create modified version of the two sets...","code":["var randomElement = elements[Math.abs(elements.hashCode()*1997)%elements.size()]","var modifiedSet1 = set1.remove(randomElement)","var modifiedSet2 = set2.remove(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!modifiedSet1.equals(set1)","!modifiedSet2.equals(set2)","!modifiedSet1.equals(set2)","!modifiedSet2.equals(set1)","modifiedSet1.equals(modifiedSet2)"]},

        {"kind":"when","text":"We put back in the old element to restore the previous states...","code":["var restoredSet1 = modifiedSet1.add(randomElement)","var restoredSet2 = modifiedSet2.add(randomElement)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!restoredSet1.equals(modifiedSet1)","!restoredSet2.equals(modifiedSet2)","!restoredSet1.equals(modifiedSet2)","!restoredSet2.equals(modifiedSet1)","restoredSet1.equals(restoredSet2)","restoredSet1.equals(set1)","restoredSet2.equals(set2)","restoredSet1.equals(set2)","restoredSet2.equals(set1)"]},

        {"kind":"when","text":"We create smaller version of the two sets by removing something...","code":["var randomElement2 = elements[Math.abs(elements.hashCode()*31)%elements.size()]","var smallerSet1 = set1.remove(randomElement2)","var smallerSet2 = set2.remove(randomElement2)"]},

        {"kind":"then","text":"We have the expected relationships between all of the objects:","code":["!smallerSet1.equals(set1)","!smallerSet2.equals(set2)","!smallerSet1.equals(set2)","!smallerSet2.equals(set1)","smallerSet1.equals(smallerSet2)"]},

        {"kind":"and","text":"","code":["smallerSet1.hashCode() != set1.hashCode()","smallerSet2.hashCode() != set2.hashCode()","smallerSet1.hashCode() != set2.hashCode()","smallerSet2.hashCode() != set1.hashCode()","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Byte","Short","Integer","String","Byte","Short","Integer","String","Byte","Short","Integer","String"],"elements":["(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()","(0..100).collect(it -> it as Byte).toList()","(0..100).collect(it -> it as Short).toList()","(0..100).collect(it -> it).toList()","(0..100).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after removing a large part of elements. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value set,\n            we can avoid a lot of work due to two set sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher1 = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","var keyHasher2 = { (it.hashCode() + (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort1 = (a, b) -> (keyHasher1(a)<=>keyHasher1(b))","Comparator<Object> randomSort2 = (a, b) -> (keyHasher2(a)<=>keyHasher2(b))","var scrambledEntries1 = entries.toSorted(randomSort1)","var scrambledEntries2 = entries.toSorted(randomSort2)"]},

        {"kind":"when","text":"We create two different `ValueSet` instances from the two scrambled list...","code":["var set1 = ValueSet.of(type).addAll(scrambledEntries1)","var set2 = ValueSet.of(type).addAll(scrambledEntries2)"]},

        {"kind":"then","text":"The two sets are equal!","code":["set1.equals(set2)"]},

        {"kind":"and","text":"They also have the same hash codes:","code":["set1.hashCode() == set2.hashCode()"]},

        {"kind":"when","text":"We create versions of the sets where parts are removed...","code":["var subList = entries.subList(0, (entries.size() * 0.5) as int)","var toRemove = subList.collect({it}).toSet()","var smallerSet1 = set1.removeAll(toRemove)","var smallerSet2 = set2.removeAll(toRemove)"]},

        {"kind":"then","text":"They are equal...","code":["smallerSet1 == smallerSet2","smallerSet1.hashCode() == smallerSet2.hashCode()"]},

        {"kind":"when","text":"We make them different by adding to them...","code":["var toAdd1 = subList.subList(0, (subList.size() * 0.5) as int).toSet()","var toAdd2 = subList.subList((subList.size() * 0.5) as int, subList.size()).toSet()","var lessSmallSet1 = smallerSet1.addAll(toAdd1)","var lessSmallSet2 = smallerSet2.addAll(toAdd2)"]},

        {"kind":"then","text":"","code":["lessSmallSet1.size() == lessSmallSet2.size()","lessSmallSet1 != lessSmallSet2","lessSmallSet1.hashCode() != lessSmallSet2.hashCode()"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `equals` and `hashCode` implementations of a ValueSet works reliably after a serious of modifications. [15]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            Here we test the implementation of the `equals` and `hashCode` methods exhaustively.\n            This may look like an exaggerated amount of test data and equality checks, but you\n            have to know that under the hood specifically the `equals` implementations are\n            highly optimized to specific cases which need to be covered.\n\n            More specifically, if there are only small differences between value sets,\n            we can avoid a lot of work due to two sets sharing most of their branches.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"We create randomly sorted variants of the test data:","code":["var keyHasher = { (it.hashCode() ^ (it.hashCode() ** 2)) as int }","Comparator<Object> randomSort = (a, b) -> (keyHasher(a)<=>keyHasher(b))","entries.sort(randomSort)","var firstHalf = entries.subList(0, (entries.size() * 0.5) as int)","var secondHalf = entries.subList(1 + (entries.size() * 0.5) as int, entries.size())"]},

        {"kind":"and","text":"","code":["var originalSet = ValueSet.of(type).addAll(firstHalf)"]},

        {"kind":"when","text":"","code":["var quarter = firstHalf.subList(0, (firstHalf.size() * 0.5) as int)","var modifiedSet = originalSet.removeAll(quarter.toSet())"]},

        {"kind":"then","text":"","code":["modifiedSet != originalSet","modifiedSet.hashCode() != originalSet.hashCode()"]},

        {"kind":"when","text":"","code":["var subSubList1 = secondHalf.subList(0, (secondHalf.size() * 0.5) as int)","var subSubList2 = secondHalf.subList((secondHalf.size() * 0.5) as int, secondHalf.size())","var modifiedSet1 = modifiedSet.addAll(subSubList1)","var modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"when","text":"","code":["modifiedSet = modifiedSet.addAll(firstHalf)"]},

        {"kind":"then","text":"","code":["originalSet == modifiedSet","originalSet.hashCode() == modifiedSet.hashCode()"]},

        {"kind":"when","text":"","code":["modifiedSet1 = modifiedSet.addAll(subSubList1)","modifiedSet2 = modifiedSet.addAll(subSubList2)"]},

        {"kind":"then","text":"","code":["modifiedSet1.size() == modifiedSet2.size()","modifiedSet1 != modifiedSet2"]},

        {"kind":"where","text":"We use the following entry data source:","code":{"type":["Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String","Long","Short","Integer","String"],"entries":["(0..24).collect(it -> it as Long).toList()","(0..24).collect(it -> it as Short).toList()","(0..24).collect(it -> it).toList()","(0..24).collect(it -> String.valueOf(it)).toList()","(0..128).collect(it -> it as Long).toList()","(0..128).collect(it -> it as Short).toList()","(0..128).collect(it -> it).toList()","(0..128).collect(it -> String.valueOf(it)).toList()","(0..1_000).collect(it -> it as Long).toList()","(0..1_000).collect(it -> it as Short).toList()","(0..1_000).collect(it -> it).toList()","(0..1_000).collect(it -> String.valueOf(it)).toList()","(0..10_000).collect(it -> it as Long).toList()","(0..10_000).collect(it -> it as Short).toList()","(0..10_000).collect(it -> it).toList()","(0..10_000).collect(it -> String.valueOf(it)).toList()"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method filters out items of the specified type while preserving the value set characteristics.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method creates a new value set containing only items that are NOT \n            instances of the specified type. This is useful for filtering out specific types from \n            a heterogeneous value set.\n\n            Important behavior:\n            - The returned value set has the same ordering characteristics (linked/sorted) as the original\n            - Items that are instances of the specified type (including subclasses) are removed\n            - The element type of the returned value set remains the same as the original\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with mixed types","code":["var mixed = ValueSet.of(Object).addAll(\"hello\", 42, \"world\", 3.14, \"!\", 100, \"test\")"]},

        {"kind":"when","text":"We remove all String instances","code":["var withoutStrings = mixed.removeIf(String)"]},

        {"kind":"then","text":"Only non-String items remain","code":["withoutStrings == ValueSet.of(Object).addAll(42, 3.14, 100)","withoutStrings.type() == Object","!withoutStrings.isLinked()","!withoutStrings.isSorted()"]},

        {"kind":"when","text":"We remove all Integer instances","code":["var withoutIntegers = mixed.removeIf(Integer)"]},

        {"kind":"then","text":"Only non-Integer items remain","code":["withoutIntegers == ValueSet.of(Object).addAll(\"hello\", \"world\", 3.14, \"!\", \"test\")","withoutIntegers.type() == Object"]},

        {"kind":"when","text":"We remove all Number instances (including Integer and Double)","code":["var withoutNumbers = mixed.removeIf(Number)"]},

        {"kind":"then","text":"Only non-Number items remain","code":["withoutNumbers == ValueSet.of(Object).addAll(\"hello\", \"world\", \"!\", \"test\")","withoutNumbers.type() == Object"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method keeps only items of the specified type and returns a properly typed value set.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method creates a new value set containing only items that ARE \n            instances of the specified type. This is useful for extracting specific types from \n            a heterogeneous value set.\n\n            Important behavior:\n            - Only items that are instances of the specified type (including subclasses) are retained\n            - The returned value set is properly typed as ValueSet<V> where V is the specified type\n            - The ordering characteristics (linked/sorted) are preserved in the result\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with mixed types","code":["var mixed = ValueSet.of(Object).addAll(\"hello\", 42, \"world\", 3.14, \"!\", 100, \"test\")"]},

        {"kind":"when","text":"We retain only String instances","code":["var onlyStrings = mixed.retainIf(String)"]},

        {"kind":"then","text":"Only String items remain and result is properly typed","code":["onlyStrings == ValueSet.of(\"hello\", \"world\", \"!\", \"test\")","onlyStrings.type() == String","!onlyStrings.isLinked()","!onlyStrings.isSorted()"]},

        {"kind":"when","text":"We retain only Integer instances","code":["var onlyIntegers = mixed.retainIf(Integer)"]},

        {"kind":"then","text":"Only Integer items remain and result is properly typed","code":["onlyIntegers == ValueSet.of(42, 100)","onlyIntegers.type() == Integer"]},

        {"kind":"when","text":"We retain only Number instances (including both Integer and Double)","code":["var onlyNumbers = mixed.retainIf(Number)"]},

        {"kind":"then","text":"All Number items remain and result is properly typed","code":["onlyNumbers == ValueSet.of(Number).addAll(42, 3.14, 100)","onlyNumbers.type() == Number"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `removeIf(Class)` method efficiently filters large heterogeneous collections while preserving set characteristics. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `removeIf(Class)` method should efficiently handle large collections while \n            maintaining the original value set's characteristics. This test verifies that:\n\n            - Large datasets are processed correctly\n            - The operation maintains performance characteristics\n            - The result has the same ordering characteristics as the input\n\n            This is particularly important for data processing pipelines where value sets \n            might contain thousands of heterogeneous elements.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType).addAll(items)"]},

        {"kind":"when","text":"We remove all instances of the specified type","code":["var result = valueSet.removeIf(typeToRemove)"]},

        {"kind":"then","text":"The result contains only non-matching items with preserved characteristics","code":["result == expected","result.type() == baseType","result.isLinked() == valueSet.isLinked()","result.isSorted() == valueSet.isSorted()"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more\", 100]","[\"keep\", 100, \"remove\", 200, \"also remove\"]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRemove":["String","Integer","Number","String","String","Integer","Number","Integer"],"expected":["ValueSet.of(Object).addAll(generateMixedTypeList(100).findAll { !(it instanceof String) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(500).findAll { !(it instanceof Integer) }.toSet())","ValueSet.of(Object).addAll(generateMixedTypeList(1000).findAll { !(it instanceof Number) }.toSet())","ValueSet.of(Object).addAll(42, 3.14, 100)","ValueSet.of(Object).addAll(100, 200)","ValueSet.of(Number).addAll(2.5, 4.7)","ValueSet.of(Number)","ValueSet.of(Integer)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `retainIf(Class)` method efficiently extracts typed subsets from large heterogeneous collections. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `retainIf(Class)` method should efficiently extract homogeneous subsets \n            from large heterogeneous collections. This test verifies that:\n\n            - Large datasets are processed correctly with proper type filtering\n            - The returned value set is properly typed\n            - Type safety is maintained throughout the operation\n            - Ordering characteristics are preserved when applicable\n\n            This is crucial for type-safe data extraction in data processing scenarios \n            where you need to work with specific subtypes from mixed collections.\n        "]
      },
      "blocks":[
        {"kind":"given","text":"A value set with a large collection of mixed-type items","code":["var valueSet = ValueSet.of(baseType, items)"]},

        {"kind":"when","text":"We retain only instances of the specified type","code":["var result = valueSet.retainIf(typeToRetain)"]},

        {"kind":"then","text":"The result contains only matching items and is properly typed","code":["result == expected","result.type() == typeToRetain"]},

        {"kind":"where","text":"","code":{"baseType":["Object","Object","Object","Object","Object","Object","Number","Number","Integer"],"items":["generateMixedTypeList(100)","generateMixedTypeList(500)","generateMixedTypeList(1000)","[\"text\", 42, 3.14, \"more text\", 100]","[\"keep\", 100, \"also keep\", 200, \"and this\"]","[1, \"text\", 2.5, \"more\", 3, 4.7]","[1, 2.5, 3, 4.7, 5]","[1, 2.5, 3, 4.7, 5]","[1, 2, 3, 4, 5, 6, 7]"],"typeToRetain":["String","Integer","Number","String","String","Number","Integer","Number","Integer"],"expected":["ValueSet.of(String).addAll(generateMixedTypeList(100).findAll { it instanceof String }.toSet())","ValueSet.of(Integer).addAll(generateMixedTypeList(500).findAll { it instanceof Integer }.toSet())","ValueSet.of(Number).addAll(generateMixedTypeList(1000).findAll { it instanceof Number }.toSet())","ValueSet.of(\"text\", \"more text\")","ValueSet.of(\"keep\", \"also keep\", \"and this\")","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7)","ValueSet.of(Integer).addAll(1, 3, 5)","ValueSet.of(Number).addAll(1, 2.5, 3, 4.7, 5)","ValueSet.of(Integer).addAll(1, 2, 3, 4, 5, 6, 7)"]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"Edge cases for `removeIf(Class)` and `retainIf(Class)` methods are handled correctly.",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":[]
      },
      "blocks":[
        {"kind":"given","text":"An empty value set","code":["var empty = ValueSet.of(String)"]},

        {"kind":"when","text":"We try to remove items from an empty set","code":["var result1 = empty.removeIf(String)"]},

        {"kind":"then","text":"The empty set is returned unchanged","code":["result1.isEmpty()","result1.is(empty)"]},

        {"kind":"when","text":"We try to retain items in an empty set","code":["var result2 = empty.retainIf(String)"]},

        {"kind":"then","text":"The empty set is returned unchanged","code":["result2.isEmpty()","result2.type() == String"]},

        {"kind":"when","text":"A value set where no items match the filter criteria for removal","code":["var numbers = ValueSet.of(Integer).addAll(1, 2, 3, 4, 5)"]},

        {"kind":"and","text":"We try to remove String instances from an Integer set","code":["var result3 = numbers.removeIf(String)"]},

        {"kind":"then","text":"The set is returned unchanged","code":["result3 == numbers","result3.is(numbers)"]},

        {"kind":"when","text":"We try to retain String instances from an Integer set","code":["var result4 = numbers.retainIf(String)"]},

        {"kind":"then","text":"An empty String set is returned","code":["result4.isEmpty()","result4.type() == String"]},

        {"kind":"when","text":"A value set where all items match the filter criteria for retention","code":["var strings = ValueSet.of(String).addAll(\"a\", \"b\", \"c\")"]},

        {"kind":"and","text":"We retain String instances from a String set","code":["var result5 = strings.retainIf(String)"]},

        {"kind":"then","text":"The set is returned unchanged (but may be a new instance)","code":["result5 == strings","result5.type() == String"]},

        {"kind":"when","text":"We remove Object instances from a String set (all items are instances)","code":["var result6 = strings.removeIf(Object)"]},

        {"kind":"then","text":"An empty set is returned","code":["result6.isEmpty()","result6.type() == String"]}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [0]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [1]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [2]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [3]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [4]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [5]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [6]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [7]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [8]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [9]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [10]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [11]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [12]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [13]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    },
  
    {
      "id":"The `join(String)` method handles all kinds of value sets correctly. [14]",
      "result":"PASS",
      "duration":"?",
      "iterations":{
      "tags":{},"see":[],"extraInfo":["\n            The `join(String)` method creates a string representation of the value set's elements\n            by concatenating them with the specified delimiter. The order of elements depends on\n            the value set type:\n            - Regular value sets: undefined but consistent order\n            - Linked value sets: insertion order\n            - Sorted value sets: sorted order\n\n            Since value sets cannot contain null elements (as specified in the class documentation),\n            null handling is not a concern for this method.\n        "]
      },
      "blocks":[
        {"kind":"when","text":"We join the elements","code":["var result = valueSet.join(delimiter)"]},

        {"kind":"then","text":"The result matches the expected joined string you would get from a tuple (ordered).","code":["result == valueSet.toTuple().join(delimiter)"]},

        {"kind":"where","text":"","code":{"valueSet":["ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(\"a\", \"b\", \"c\")","ValueSet.of(Integer).addAll(1, 2, 3)","ValueSet.of(Double).addAll(1.5d, 2.7d, 3.9d)","ValueSet.of(Boolean).addAll(true, false, true)","ValueSet.of(Integer)","ValueSet.of(String).add(\"single\")","ValueSet.of(Double).add(3.14d)","ValueSet.ofLinked(\"c\", \"a\", \"b\")","ValueSet.ofLinked(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(\"c\", \"a\", \"b\")","ValueSet.ofSorted(Integer).addAll(3, 1, 2)","ValueSet.ofSorted(String, Comparator.reverseOrder()).addAll( \"a\", \"c\", \"b\")"],"delimiter":["\", \"","\"-\"","\"\"","\" -> \"","\", \"","\"  \"","\" & \"","\", \"","\" - \"","\"...\"","\", \"","\"-\"","\", \"","\"-\"","\", \""]}}
      ],
      "problems":{"dataValues":[], "errors":[]}
    }
  
  ],
  "generator":"https://github.com/renatoathaydes/spock-reports"
}
