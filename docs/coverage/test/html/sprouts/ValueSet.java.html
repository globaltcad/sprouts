<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">ValueSet.java</span></div><h1>ValueSet.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import sprouts.impl.Sprouts;

import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 *  An immutable collection of non-null elements that contains no duplicates,
 *  meaning that it can never contain a pair of elements e1 and e2 such that e1.equals(e2).
 *  As implied by its name, this interface models the mathematical set abstraction,
 *  similar to {@link Set}, but with the difference that this has consistent
 *  value object semantics and is immutable. &lt;br&gt;
 *  This means that you cannot modify the contents of a value set after it
 *  has been created, but you can create a new value set with the desired
 *  changes using methods like {@code ValueSet::add(E)} or {@code ValueSet::remove(E)},
 *  which will return a new value set with the changes applied.
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;p&gt;&lt;b&gt;
 *      Note: Mutable objects should not be stored in a
 *      value set, which is especially important with respect to
 *      their hash codes and equality,
 *      which have to stay constant for the lifetime
 *      within the value set, as it assumes that their behavior
 *      does not change (due to element code hash caching for example).
 *      The behavior of this class is uncertain if an element
 *      is changed in a manner that affects equals
 *      or hashCode after it has been added to the value set.
 *  &lt;/b&gt;
 *
 * @param &lt;E&gt; The type of the elements in this value set, which must be immutable.
 * @see Association An immutable key-value pair with consistent value object semantics.
 * @see Tuple An immutable collection of ordered and indexed item with consistent value object semantics.
 */
public interface ValueSet&lt;E&gt; extends Iterable&lt;E&gt; {

    /**
     *  An alternative to {@code ValueSet.class} which also includes the parameter
     *  type in the type signature of the returned {@link ValueSet} class.
     *  This is useful when you want to use value sets as items in collection
     *  types or properties...
     *
     * @param elementType The element type {@code K} in the returned {@code Class&lt;ValueSet&lt;K&gt;&gt;}.
     * @return The {@code ValueSet.class} but with the parameter type included as {@code K} in {@code Class&lt;ValueSet&lt;K&gt;&gt;}.
     * @param &lt;E&gt; The type of elements in the value set class parameter signature.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; Class&lt;ValueSet&lt;E&gt;&gt; classTyped( Class&lt;E&gt; elementType ) {
<span class="fc" id="L56">        Objects.requireNonNull(elementType);</span>
<span class="fc" id="L57">        return (Class) ValueSet.class;</span>
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into
     *  a value set. The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOf(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new value set of string elements
     *  where the strings are all uppercased.
     *  If there are null values in the stream, an exception will be thrown,
     *  because a value set cannot contain null elements.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into a value set.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    static &lt;E&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOf( Class&lt;E&gt; type ) {
<span class="fc" id="L83">        Objects.requireNonNull(type);</span>
<span class="fc" id="L84">        return Collector.of(</span>
                    (Supplier&lt;Set&lt;E&gt;&gt;) HashSet::new,
                    Set::add,
<span class="fc" id="L87">                    (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L88">                    set -&gt; ValueSet.of(type).addAll(set)</span>
                );
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into a linked value set with
     *  an order, which is defined by the insertion order of the elements.
     *  The types of the elements and values in the
     *  value set have to be specified when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOfLinked(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered value set of string elements
     *  where the strings are all uppercased and ordered by their insertion order.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into an ordered value set.
     */
    static &lt;E&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOfLinked( Class&lt;E&gt; type ) {
<span class="fc" id="L113">        Objects.requireNonNull(type);</span>
<span class="fc" id="L114">        return Collector.of(</span>
                (Supplier&lt;Set&lt;E&gt;&gt;) LinkedHashSet::new,
                Set::add,
<span class="fc" id="L117">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L118">                set -&gt; ValueSet.ofLinked(type).addAll(set)</span>
        );
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into
     *  a value set with an explicit order defined by the supplied comparator.
     *  The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOfSorted(String.class, Comparator.naturalOrder()));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered value set of string elements
     *  where the strings are all uppercased and ordered by their natural order.
     *
     * @param type The type of the elements in the value set to collect.
     * @param comparator The comparator to use for sorting the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into an ordered value set.
     */
    static &lt;E&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOfSorted( Class&lt;E&gt; type, Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L144">        Objects.requireNonNull(type);</span>
<span class="fc" id="L145">        Objects.requireNonNull(comparator);</span>
<span class="fc" id="L146">        return Collector.of(</span>
                (Supplier&lt;List&lt;E&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L149">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L150">                list -&gt; ValueSet.ofSorted(type, comparator).addAll(list)</span>
        );
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into a value set with the order being based
     *  on the {@link Comparable} implementation of the elements and the
     *  natural ordering of the elements.&lt;br&gt;
     *  The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOfSorted(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered value set of string elements
     *  where the strings are all uppercased and ordered by their natural order.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into an ordered value set.
     */
    static &lt;E extends Comparable&lt;? super E&gt;&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOfSorted( Class&lt;E&gt; type ) {
<span class="fc" id="L176">        Objects.requireNonNull(type);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if ( !Comparable.class.isAssignableFrom(type) ) {</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(&quot;The provided type must implement Comparable.&quot;);</span>
        }
<span class="fc" id="L180">        return Collector.of(</span>
                (Supplier&lt;List&lt;E&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L183">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L184">                list -&gt; ValueSet.ofSorted(type).addAll(list)</span>
        );
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type.
     *  A value set knows the types of its elements, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( Class&lt;E&gt; type ) {
<span class="fc" id="L199">        Objects.requireNonNull(type);</span>
<span class="fc" id="L200">        return Sprouts.factory().valueSetOf(type);</span>
    }

    /**
     *  Creates a new value set from a single non-null element.
     *  The type of the element is captured from the element itself
     *  through the {@link Object#getClass()} method.
     *  The resulting value set will have a size of 1 and does not
     *  allow null elements.
     *
     * @param element The element to store as the only element in the value set.
     * @param &lt;E&gt; The type of the element in the value set, this must be an immutable type.
     * @return A new value set with the given element
     *         and a size of 1.
     * @throws NullPointerException If the provided element is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( final @NonNull E element ) {
<span class="fc" id="L217">        Objects.requireNonNull(element);</span>
<span class="fc" id="L218">        return of((Class&lt;E&gt;) element.getClass()).add(element);</span>
    }
    
    /**
     *  Creates a new value set from the given elements.
     *  The types of the elements are inferred from the elements themselves
     *  through the {@link Object#getClass()} method.
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; ValueSet&lt;E&gt; of( @NonNull E first, @NonNull E... rest ) {
<span class="fc" id="L235">        Objects.requireNonNull(first);</span>
<span class="fc" id="L236">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L237">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L238">        return of(type).add(first).addAll(rest);</span>
    }

    /**
     *  Creates a new value set from the given {@link Tuple} of elements.
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If the provided tuple is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( Tuple&lt;E&gt; tuple ) {
<span class="fc" id="L252">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L253">        return Sprouts.factory().valueSetOf(tuple.type()).addAll(tuple);</span>
    }

    /**
     *  Creates a new value set from the given {@link Iterable} of elements.
     *  The type of the elements must be provided explicitly in case
     *  of the iterable being empty.
     *
     * @param type The type of the elements in the value set.
     * @param elements The iterable of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null or if the provided iterable is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( @NonNull Class&lt;E&gt; type, @NonNull Iterable&lt;E&gt; elements ) {
<span class="fc" id="L268">        Objects.requireNonNull(type);</span>
<span class="fc" id="L269">        Objects.requireNonNull(elements);</span>
<span class="fc" id="L270">        return of(type).addAll(elements);</span>
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type,
     *  and where the order of the elements is defined by the insertion order.
     *  Which means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  A value set knows the types of its elements, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new linked value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( Class&lt;E&gt; type ) {
<span class="fc" id="L287">        Objects.requireNonNull(type);</span>
<span class="fc" id="L288">        return Sprouts.factory().valueSetOfLinked(type);</span>
    }

    /**
     *  Creates a new linked value of the supplied type as well as
     *  elements from the supplied {@link Iterable} to it,
     *  where the order of the elements is defined by the insertion order.
     *  This means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  A value set knows the types of its elements, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    ValueSet.ofLinked(
     *       String.class,
     *       List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *    );
     *  }&lt;/pre&gt;
     *
     * @param type The type of the elements in the value set.
     * @param elements The iterable of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new linked value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( Class&lt;E&gt; type, Iterable&lt;E&gt; elements ) {
<span class="fc" id="L314">        Objects.requireNonNull(type);</span>
<span class="fc" id="L315">        Objects.requireNonNull(elements);</span>
<span class="fc" id="L316">        return ofLinked(type).addAll(elements);</span>
    }

    /**
     *  Creates a new linked value set of one or more elements,
     *  where the order of the elements is defined by the insertion order.
     *  The order of the supplied items is preserved in the new value set,
     *  which means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  The type of the elements is captured from the first element through
     *  the {@link Object#getClass()} method.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    ValueSet.ofLinked(1, 2, 3);
     *  }&lt;/pre&gt;
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new linked value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( @NonNull E first, @NonNull E... rest ) {
<span class="fc" id="L341">        Objects.requireNonNull(first);</span>
<span class="fc" id="L342">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L343">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L344">        return ofLinked(type).add(first).addAll(rest);</span>
    }

    /**
     *  Creates a new linked value set from the given {@link Tuple} of elements,
     *  where the order of the elements is defined by the insertion order.
     *  The order of the items in the tuple is preserved in the value set,
     *  which means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type.
     * @return A new linked value set with the given elements.
     * @throws NullPointerException If the supplied tuple is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( Tuple&lt;E&gt; tuple ) {
<span class="fc" id="L362">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L363">        return Sprouts.factory().valueSetOf(tuple.type()).addAll(tuple);</span>
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type,
     *  but with an explicit order defined by the supplied comparator.
     *  A value set knows the types of its elements and values, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used
     *  to create a set with string elements sorted by their length:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    ValueSet.ofSorted(
     *       String.class,
     *       Comparator.comparing(String::length)
     *    );
     *  }&lt;/pre&gt;
     *
     * @param type The type of the elements in the value set.
     * @param comparator The comparator to use for sorting the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new sorted value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofSorted( Class&lt;E&gt; type, Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L387">        Objects.requireNonNull(type);</span>
<span class="fc" id="L388">        Objects.requireNonNull(comparator);</span>
<span class="fc" id="L389">        return Sprouts.factory().valueSetOfSorted(type, comparator);</span>
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type,
     *  elements are sorted based on the natural ordering of the elements
     *  (which are expected to implement {@link Comparable}).
     *  A value set knows the types of its elements and values, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  specified element type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new sorted value set specific to the given element type.
     */
    static &lt;E extends Comparable&lt;? super E&gt;&gt; ValueSet&lt;E&gt; ofSorted( Class&lt;E&gt; type ) {
<span class="fc" id="L405">        Objects.requireNonNull(type);</span>
<span class="fc" id="L406">        return Sprouts.factory().valueSetOfSorted(type);</span>
    }

    /**
     *  Creates a new sorted value set from the given {@link Tuple} of
     *  {@link Comparable} elements.&lt;br&gt;
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *  The elements are sorted based on their natural ordering,
     *  which is defined by their {@link Comparable} implementation.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type and implement {@link Comparable}.
     * @return A new sorted value set with the given elements.
     * @throws NullPointerException If the supplied tuple is null.
     */
    static &lt;E extends Comparable&lt;? super E&gt;&gt; ValueSet&lt;E&gt; ofSorted( Tuple&lt;E&gt; tuple ) {
<span class="fc" id="L423">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L424">        return Sprouts.factory().valueSetOfSorted(tuple.type()).addAll(tuple);</span>
    }

    /**
     *  Creates a new sorted value set from the given {@link Tuple} of elements,
     *  with an explicit order defined by the supplied {@link Comparator}.
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param comparator The comparator to use for sorting the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type.
     * @return A new sorted value set with the given elements.
     * @throws NullPointerException If any of the provided parameters are null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofSorted( Tuple&lt;E&gt; tuple, Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L440">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L441">        Objects.requireNonNull(comparator, &quot;The provided comparator cannot be null.&quot;);</span>
<span class="fc" id="L442">        return Sprouts.factory().valueSetOfSorted(tuple.type(), comparator).addAll(tuple);</span>
    }

    /**
     *  Creates a new sorted value set of one or more {@link Comparable} elements.
     *  The elements are sorted based on their natural ordering.
     *  The type of the elements is captured from the first element through
     *  the {@link Object#getClass()} method.
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type and implement {@link Comparable}.
     * @return A new sorted value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    static &lt;E extends Comparable&lt;E&gt;&gt; ValueSet&lt;E&gt; ofSorted( E first, E... rest ) {
<span class="fc" id="L459">        Objects.requireNonNull(first);</span>
<span class="fc" id="L460">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L461">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L462">        return ofSorted(type).add(first).addAll(rest);</span>
    }

    /**
     *  Returns the total number of all elements in this value set.
     *
     * @return The number of elements in this value set.
     */
    int size();

    /**
     *  Checks if this value set is empty and returns
     *  {@code true} if it is, otherwise {@code false}.
     *
     * @return {@code true} if this value set is empty, otherwise {@code false}.
     */
    default boolean isEmpty() {
<span class="fc bfc" id="L479" title="All 2 branches covered.">        return size() == 0;</span>
    }

    /**
     *  Checks if this value set is not empty and returns
     *  {@code true} if it is not, otherwise {@code false}.
     *
     * @return {@code true} if this value set is not empty, otherwise {@code false}.
     */
    default boolean isNotEmpty() {
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        return !isEmpty();</span>
    }

    /**
     *  Checks if this value set is a linked value set and returns
     *  {@code true} if it is, otherwise {@code false}.
     *  A linked value set is a value set that preserves the insertion order
     *  of the elements, meaning that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *
     * @return {@code true} if this set is a linked value set, otherwise {@code false}.
     */
    boolean isLinked();

    /**
     *  Checks if this value set is sorted and returns
     *  {@code true} if it is, otherwise {@code false}.
     *  A value set is sorted if the entries are sorted in
     *  natural order or according to a supplied comparator
     *  when the set was created.&lt;br&gt;
     *  You can create a sorted set using factory methods
     *  like {@link #ofSorted(Class, Comparator)}, or
     *  by converting an existing set to a sorted one
     *  using the {@link #sort(Comparator)} method.
     *
     * @return {@code true} if this set is sorted, otherwise {@code false}.
     */
    boolean isSorted();

    /**
     *  Returns the {@link Class} of the
     *  type of the elements in this value set.
     *  Note that this may also be a superclass of the actual
     *  elements in the value set, but it will always be the
     *  type that was used to create the value set.
     *
     * @return The type of the elements in this value set.
     */
    Class&lt;E&gt; type();

    /**
     *  Checks if the supplied element is present in this value set
     *  and returns {@code true} if it is, otherwise {@code false}.
     *
     * @param element The element whose presence in this value set is to be checked.
     * @return {@code true} if the element is present, otherwise {@code false}.
     */
    boolean contains( E element );

    /**
     *  Checks if all the elements in the supplied value set are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified set is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The value set whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given value set are present, otherwise {@code false}.
     * @throws NullPointerException if the provided value set is {@code null}.
     */
    default boolean containsAll( ValueSet&lt;? extends E&gt; elements ) {
<span class="fc" id="L549">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="fc" id="L550">        return elements.stream().parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Checks if all the elements in the given set are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified set is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The set whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given set are present, otherwise {@code false}.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default boolean containsAll( Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L564">        Objects.requireNonNull(elements, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L565">        return containsAll((Collection&lt;? extends E&gt;) elements);</span>
    }
    
    /**
     *  Checks if all the elements in the given array are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified array is effectively
     *  a &lt;i&gt;subset&lt;/i&gt; of this set, and then returns {@code true} if it is.
     *
     * @param elements The array whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given array are present, otherwise {@code false}.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default boolean containsAll( E... elements ) {
<span class="fc" id="L579">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc" id="L580">        return Arrays.stream(elements).parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Collection} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified collection is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The collection whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given collection are present, otherwise {@code false}.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default boolean containsAll( Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L594">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc" id="L595">        return elements.stream().parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Tuple} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified tuple is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The tuple whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given tuple are present, otherwise {@code false}.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default boolean containsAll( Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L609">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L610">        return elements.stream().parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Iterable} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified iterable is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The iterable whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given iterable are present, otherwise {@code false}.
     * @throws NullPointerException if the provided iterable is {@code null}.
     */
    default boolean containsAll( Iterable&lt;? extends E&gt; elements ) {
<span class="fc" id="L624">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="fc" id="L625">        return StreamSupport.stream(elements.spliterator(), false).allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Stream} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified stream is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The stream whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given stream are present, otherwise {@code false}.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    default boolean containsAll( Stream&lt;? extends E&gt; elements ) {
<span class="fc" id="L639">        return elements.parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Returns a new value set with the supplied element
     *  added to it, or this value set if the element is already present
     *  in this value set. The element must not be null.
     *
     * @param element The element to add to this value set.
     * @return A new value set with the given element,
     *        or this value set if the element is already present.
     */
    ValueSet&lt;E&gt; add( E element );

    /**
     *  Returns a new value set with all the elements from
     *  the supplied value set added to this one.
     *  If the given value set is empty, then this
     *  value set is returned unchanged.
     *
     * @param other The value set to merge with this one.
     * @return A new value set with the elements from the given value set.
     * @throws NullPointerException if the provided value set is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final ValueSet&lt;? extends E&gt; other ) {
<span class="fc" id="L664">        Objects.requireNonNull(other, &quot;The provided value set cannot be null.&quot;);</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">        if ( other.isEmpty() )</span>
<span class="nc" id="L666">            return this;</span>
<span class="fc" id="L667">        return addAll(other.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Set} of elements added to it.
     *  If the supplied set is empty or there are no new elements in the
     *  supplied set, then this value set is returned unchanged.
     *
     * @param elements The set of elements to add to this value set.
     * @return A new value set with the elements from the provided set,
     *          or this value set if the provided set is empty.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L682">        Objects.requireNonNull(elements, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L683">        return addAll((Collection&lt;? extends E&gt;) elements);</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied array of elements added to it.
     *  If the provided array is empty, then this value set is
     *  returned unchanged.
     *
     * @param elements The array of elements to add to this value set.
     * @return A new value set with the elements from the provided array.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final E... elements ) {
<span class="fc" id="L697">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if ( elements.length == 0 )</span>
<span class="fc" id="L699">            return this;</span>
<span class="fc" id="L700">        return addAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Tuple} of elements added to it.
     *  If the provided tuple is empty, then this value set is
     *  returned unchanged.
     *
     * @param elements The tuple of elements to add to this value set.
     * @return A new value set with the elements from the provided tuple.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Tuple&lt;E&gt; elements ) {
<span class="fc" id="L714">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L716">            return this;</span>
<span class="fc" id="L717">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Collection} added to it.
     *  If the provided collection is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The collection of elements to add to this value set.
     * @return A new value set with the elements from the provided collection.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L731">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        if ( elements.isEmpty() )</span>
<span class="fc" id="L733">            return this;</span>
<span class="fc" id="L734">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Iterable} added to it.
     *  If the provided iterable is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The iterable of elements to add to this value set.
     * @return A new value set with the elements from the provided iterable.
     * @throws NullPointerException if the provided iterable is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Iterable&lt;? extends E&gt; elements ) {
<span class="fc" id="L748">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="fc" id="L749">        return addAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Stream} added to it.
     *  If the provided stream is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The stream of elements to add to this value set.
     * @return A new value set with the elements from the provided stream.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    ValueSet&lt;E&gt; addAll( final Stream&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set without the supplied element,
     *  but all other elements still kept.
     *  If the element is not present in this value set,
     *  then this value set is returned completely unchanged.
     *
     * @param element The element to be removed in the returned value set.
     * @return A new value set without the given element.
     */
    ValueSet&lt;E&gt; remove( E element );

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied set. If the
     *  supplied set is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the supplied set.
     *
     * @param elements The elements to remove from this value set.
     * @return A new value set without the elements in the given set.
     */
    default ValueSet&lt;E&gt; removeAll( Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L786">        Objects.requireNonNull(elements);</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">        if ( elements.isEmpty() )</span>
<span class="fc" id="L788">            return this;</span>
<span class="fc" id="L789">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied value set. 
     *  If the supplied value set is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the supplied set.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the given value set, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final ValueSet&lt;? extends E&gt; elements ) {
<span class="nc" id="L803">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L805">            return this;</span>
<span class="nc" id="L806">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied array. If the
     *  supplied array is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied array of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the given array, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final E... elements ) {
<span class="fc" id="L821">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        if ( elements.length == 0 )</span>
<span class="nc" id="L823">            return this;</span>
<span class="fc" id="L824">        return removeAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Collection}. 
     *  If the supplied collection is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied collection of elements.
     *
     * @param elements The collection of elements to remove from this value set (if present).
     * @return A new value set without the elements in the supplied collection, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L839">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L841">            return this;</span>
<span class="fc" id="L842">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Tuple}. 
     *  If the supplied tuple is empty, then this value set is returned
     *  completely unchanged.
     *  In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied tuple of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the supplied tuple, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L858">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">        if (toTuple().isEmpty() )</span>
<span class="nc" id="L860">            return this;</span>
<span class="fc" id="L861">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Iterable}. 
     *  If the supplied iterable has no elements, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied iterable of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements found in the supplied iterable, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L876">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L877">        return removeAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Stream}. 
     *  If the supplied stream has no elements, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied stream of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements found in the supplied stream, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    ValueSet&lt;E&gt; removeAll( final Stream&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set where only those elements
     *  are kept that have an element present in the supplied set. 
     *  In other words, removes all of its elements in the new set that are 
     *  not contained in the specified set, which effectively creates 
     *  a value set that is the &lt;b&gt;intersection between this set and the other set&lt;/b&gt;.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. 
     *  If the supplied set is empty, then an empty set is returned.
     *
     * @param elements The elements to retain in this value set.
     * @return A new value set with only the elements in the given set.
     */
    ValueSet&lt;E&gt; retainAll( Set&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set where only those elements
     *  are kept that have an element present in the supplied value set.
     *  In other words, it removes from the new set all the elements that are 
     *  not contained in the specified set, which creates 
     *  a value set that is the &lt;b&gt;intersection between this set and the other value set&lt;/b&gt;.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied value set is empty, 
     *  then an empty set is returned.
     *
     * @param elements The elements to retain in this value set.
     * @return A new value set with only the elements in the given value set.
     */
    default ValueSet&lt;E&gt; retainAll( ValueSet&lt;? extends E&gt; elements ) {
<span class="nc" id="L922">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="nc" id="L923">        return retainAll(elements.toSet());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied array of elements. 
     *  In other words, removes from this set all of its elements that are 
     *  not contained in the specified array. So if you interpret the
     *  specified array as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the array.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied array is empty,
     *  then an empty set is returned.
     *  
     * @param elements An array of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value 
     *         set that are also present in the supplied array.
     * @throws NullPointerException If the array of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( E... elements ) {
<span class="fc" id="L943">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc" id="L944">        return retainAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Collection} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified collection. So if you interpret the
     *  specified collection as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the collection.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied collection is empty,
     *  then an empty set is returned.
     *
     * @param elements A collection of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied collection.
     * @throws NullPointerException If the collection of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L964">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc" id="L965">        return retainAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Tuple} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified tuple. So if you interpret the
     *  specified tuple as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the tuple.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied tuple is empty,
     *  then an empty set is returned.
     *
     * @param elements A tuple of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied tuple.
     * @throws NullPointerException If the tuple of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L985">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L986">        return retainAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Iterable} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified iterable. So if you interpret the
     *  specified iterable as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the iterable.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied iterable is empty,
     *  then an empty set is returned.
     *
     * @param elements An iterable of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied iterable.
     * @throws NullPointerException If the iterable of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L1006">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L1007">        return retainAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Stream} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified stream. So if you interpret the
     *  specified stream as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the stream.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied stream is empty,
     *  then an empty set is returned.
     *
     * @param elements A stream of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied stream.
     * @throws NullPointerException If the stream of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Stream&lt;? extends E&gt; elements ) {
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L1028">            return this;</span>
<span class="fc" id="L1029">        Set&lt;E&gt; elementsSet = elements.collect(HashSet::new, HashSet::add, HashSet::addAll);</span>
<span class="fc" id="L1030">        return retainAll(elementsSet);</span>
    }

    /**
     *  Returns a completely empty value set but
     *  with the same element type as this one.
     *  So the {@link #type()} of the returned value set will be the same
     *  as the type of this value set.
     *
     * @return A new value set without any elements,
     *         or this value set if it is already empty.
     */
    ValueSet&lt;E&gt; clear();

    /**
     *  Converts this value set to a java.util.Map.
     *  Note that the returned map is also immutable.
     *
     * @return A java.util.Map representation of this value set.
     */
    default Set&lt;E&gt; toSet()  {
<span class="fc" id="L1051">        return new AbstractSet&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L1054">                return ValueSet.this.iterator();</span>
            }
            @Override
            public int size() {
<span class="fc" id="L1058">                return ValueSet.this.size();</span>
            }
            @Override
            public boolean contains(@Nullable Object o) {
<span class="pc bpc" id="L1062" title="2 of 4 branches missed.">                if (o != null &amp;&amp; ValueSet.this.type().isAssignableFrom(o.getClass())) {</span>
<span class="fc" id="L1063">                    return ValueSet.this.contains(ValueSet.this.type().cast(o));</span>
                }
<span class="nc" id="L1065">                return false;</span>
            }
        };
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if any of them match the predicate,
     *  otherwise {@code false}. So if one or more elements match the predicate,
     *  then this method will always return {@code true}.
     *
     *  @param predicate The predicate to check.
     *  @return True if any of the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean any( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L1081">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1082">        return this.stream().anyMatch( predicate );</span>
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if all of them match the predicate,
     *  otherwise {@code false}. So if one or more elements do not match the predicate,
     *  then this method will always return {@code false}.
     *
     *  @param predicate The predicate to check.
     *  @return True if all the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean all( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L1096">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1097">        return this.stream().allMatch( predicate );</span>
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if none of them match the predicate,
     *  otherwise {@code false}. So if one or more elements match the predicate,
     *  then this method will always return {@code false}.
     *
     *  @param predicate The predicate to run over all elements.
     *  @return True if none of the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean none( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L1111">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1112">        return this.stream().noneMatch( predicate );</span>
    }
    
    /**
     *  Returns a sequential {@link Stream} with this value set as its source.
     *
     * @return A sequential stream of the elements in this value set.
     */
    default Stream&lt;E&gt; stream() {
<span class="fc" id="L1121">        return StreamSupport.stream(spliterator(), false);</span>
    }

    /**
     *  Returns a parallel {@link Stream} with this value set as its source.
     *
     * @return A parallel stream of the elements in this value set.
     */
    default Stream&lt;E&gt; parallelStream() {
<span class="fc" id="L1130">        return StreamSupport.stream(spliterator(), true);</span>
    }

    /**
     *  Returns a new sorted value set with the elements in this value set,
     *  sorted according to the provided comparator.
     *  The type of the elements in the returned value set will be the same
     *  as the type of this value set.
     *
     * @param comparator The comparator to use for sorting the elements.
     * @return A new sorted value set with the elements in this value set.
     * @throws NullPointerException if the provided comparator is {@code null}.
     */
    default ValueSet&lt;E&gt; sort( Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L1144">        Objects.requireNonNull(comparator, &quot;The provided comparator cannot be null.&quot;);</span>
<span class="fc" id="L1145">        return Sprouts.factory().valueSetOfSorted(type(), comparator).addAll(this);</span>
    }

    /**
     *  Converts this value set to a {@link Tuple} of all the elements in it,
     *  where the {@link Tuple#type()} is the same as the {@link #type()} of this value set.
     *  Note that the order of the elements in the tuple will not
     *  have any specific meaning, as the value set is an unordered collection.
     *
     * @return A {@link Tuple} of all the elements in this value set.
     */
    default Tuple&lt;E&gt; toTuple() {
<span class="fc" id="L1157">        return Tuple.of(type(), this);</span>
    }

    /**
     * Compares the specified object with this set for equality.
     * Returns {@code true} if the specified object is also a value set,
     * and the two sets have the same size, and every member of the specified
     * set is contained in this set (or equivalently, every member of this set is
     * contained in the specified set). This definition ensures that the
     * equals method works properly across different implementations of the
     * set interface.
     *
     * @param o object to be compared for equality with this set
     * @return {@code true} if the specified object is equal to this set
     */
    @Override
    boolean equals( Object o );

    /**
     * Returns the hash code value for this set. The hash code of a set is
     * defined to be the sum of the hash codes of the elements in the set.
     * This ensures that {@code s1.equals(s2)} implies that
     * {@code s1.hashCode()==s2.hashCode()} for any two sets {@code s1}
     * and {@code s2}, as required by the general contract of
     * {@link Object#hashCode}.
     *
     * @return The hash code value for this set as a 32-bit integer,
     *         based on the sum of the hash codes of all elements in this set.
     * @see Object#equals(Object)
     * @see Set#equals(Object)
     */
    @Override
    int hashCode();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>