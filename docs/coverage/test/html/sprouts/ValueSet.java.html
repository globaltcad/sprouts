<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">ValueSet.java</span></div><h1>ValueSet.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import sprouts.impl.Sprouts;

import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 *  An immutable collection of non-null elements that contains no duplicates,
 *  meaning that it can never contain a pair of elements e1 and e2 such that e1.equals(e2).
 *  As implied by its name, this interface models the mathematical set abstraction,
 *  similar to {@link Set}, but with the difference that this has consistent
 *  value object semantics and is immutable. &lt;br&gt;
 *  This means that you cannot modify the contents of a value set after it
 *  has been created, but you can create a new value set with the desired
 *  changes using methods like {@link #add(E)} or {@link #remove(E)},
 *  which will return a new value set with the changes applied.
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;p&gt;&lt;b&gt;
 *      Note: Mutable objects should not be stored in a
 *      value set, which is especially important with respect to
 *      their hash codes and equality,
 *      which have to stay constant for the lifetime
 *      within the value set, as it assumes that their behavior
 *      does not change (due to element code hash caching for example).
 *      The behavior of this class is uncertain if an element
 *      is changed in a manner that affects equals
 *      or hashCode after it has been added to the value set.
 *  &lt;/b&gt;
 *
 * @param &lt;E&gt; The type of the elements in this value set, which must be immutable.
 * @see Association An immutable key-value pair with consistent value object semantics.
 * @see Tuple An immutable collection of ordered and indexed item with consistent value object semantics.
 */
public interface ValueSet&lt;E&gt; extends Iterable&lt;E&gt; {

    /**
     *  An alternative to {@code ValueSet.class} which also includes the parameter
     *  type in the type signature of the returned {@link ValueSet} class.
     *  This is useful when you want to use value sets as items in collection
     *  types or properties...
     *
     * @param elementType The element type {@code K} in the returned {@code Class&lt;ValueSet&lt;K&gt;&gt;}.
     * @return The {@code ValueSet.class} but with the parameter type included as {@code K} in {@code Class&lt;ValueSet&lt;K&gt;&gt;}.
     * @param &lt;K&gt; The type of elements in the value set class parameter signature.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;K&gt; Class&lt;ValueSet&lt;K&gt;&gt; classTyped( Class&lt;K&gt; elementType ) {
<span class="fc" id="L56">        Objects.requireNonNull(elementType);</span>
<span class="fc" id="L57">        return (Class) ValueSet.class;</span>
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into
     *  a value set. The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOf(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new value set of string elements
     *  where the strings are all uppercased.
     *  If there are null values in the stream, an exception will be thrown,
     *  because a value set cannot contain null elements.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;K&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into a value set.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    static &lt;K&gt; Collector&lt;K, ?, ValueSet&lt;K&gt;&gt; collectorOf( Class&lt;K&gt; type ) {
<span class="fc" id="L83">        Objects.requireNonNull(type);</span>
<span class="fc" id="L84">        return Collector.of(</span>
                    (Supplier&lt;List&lt;K&gt;&gt;) ArrayList::new,
                    List::add,
<span class="nc" id="L87">                    (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L88">                    list -&gt; ValueSet.of(type).addAll(list)</span>
                );
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type.
     *  A value set knows the types of its elements and values, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( Class&lt;E&gt; type ) {
<span class="fc" id="L103">        return Sprouts.factory().valueSetOf(type);</span>
    }

    /**
     *  Creates a new value set from a single non-null element.
     *  The type of the element is captured from the element itself
     *  through the {@link Object#getClass()} method.
     *  The resulting value set will have a size of 1 and does not
     *  allow null elements.
     *
     * @param element The element to store as the only element in the value set.
     * @param &lt;E&gt; The type of the element in the value set, this must be an immutable type.
     * @return A new value set with the given element
     *         and a size of 1.
     * @throws NullPointerException If the provided element is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( final @NonNull E element ) {
<span class="fc" id="L120">        Objects.requireNonNull(element);</span>
<span class="fc" id="L121">        return of((Class&lt;E&gt;) element.getClass()).add(element);</span>
    }
    
    /**
     *  Creates a new value set from the given elements.
     *  The types of the elements are inferred from the elements themselves
     *  through the {@link Object#getClass()} method.
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; ValueSet&lt;E&gt; of( @NonNull E first, @NonNull E... rest ) {
<span class="fc" id="L138">        Objects.requireNonNull(first);</span>
<span class="fc" id="L139">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L140">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L141">        return of(type).add(first).addAll(rest);</span>
    }

    /**
     *  Creates a new value set from the given {@link Iterable} of elements.
     *  The type of the elements must be provided explicitly in case
     *  of the iterable being empty.
     *
     * @param type The type of the elements in the value set.
     * @param elements The iterable of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null or if the provided iterable is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( @NonNull Class&lt;E&gt; type, @NonNull Iterable&lt;E&gt; elements ) {
<span class="fc" id="L156">        Objects.requireNonNull(type);</span>
<span class="fc" id="L157">        Objects.requireNonNull(elements);</span>
<span class="fc" id="L158">        return of(type).addAll(elements);</span>
    }

    /**
     *  Returns the total number of all elements in this value set.
     *
     * @return The number of elements in this value set.
     */
    int size();

    /**
     *  Checks if this value set is empty and returns
     *  {@code true} if it is, otherwise {@code false}.
     *
     * @return {@code true} if this value set is empty, otherwise {@code false}.
     */
    default boolean isEmpty() {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        return size() == 0;</span>
    }

    /**
     *  Checks if this value set is not empty and returns
     *  {@code true} if it is not, otherwise {@code false}.
     *
     * @return {@code true} if this value set is not empty, otherwise {@code false}.
     */
    default boolean isNotEmpty() {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        return !isEmpty();</span>
    }

    /**
     *  Returns the {@link Class} of the
     *  type of the elements in this value set.
     *  Note that this may also be a superclass of the actual
     *  elements in the value set, but it will always be the
     *  type that was used to create the value set.
     *
     * @return The type of the elements in this value set.
     */
    Class&lt;E&gt; type();

    /**
     *  Checks if the supplied element is present in this value set
     *  and returns {@code true} if it is, otherwise {@code false}.
     *
     * @param element The element whose presence in this value set is to be checked.
     * @return {@code true} if the element is present, otherwise {@code false}.
     */
    boolean contains( E element );

    /**
     *  Checks if all the elements in the supplied value set are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified set is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The value set whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given value set are present, otherwise {@code false}.
     * @throws NullPointerException if the provided value set is {@code null}.
     */
    default boolean containsAll( ValueSet&lt;? extends E&gt; elements ) {
<span class="fc" id="L219">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="fc" id="L220">        return elements.stream().parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Checks if all the elements in the given set are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified set is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The set whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given set are present, otherwise {@code false}.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default boolean containsAll( Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L234">        Objects.requireNonNull(elements, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L235">        return elements.stream().parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Checks if all the elements in the given array are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified array is effectively
     *  a &lt;i&gt;subset&lt;/i&gt; of this set, and then returns {@code true} if it is.
     *
     * @param elements The array whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given array are present, otherwise {@code false}.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default boolean containsAll( E... elements ) {
<span class="fc" id="L249">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc" id="L250">        return Arrays.stream(elements).parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Collection} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified collection is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The collection whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given collection are present, otherwise {@code false}.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default boolean containsAll( Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L264">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc" id="L265">        return elements.stream().parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Tuple} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified tuple is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The tuple whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given tuple are present, otherwise {@code false}.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default boolean containsAll( Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L279">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L280">        return elements.stream().parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Iterable} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified iterable is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The iterable whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given iterable are present, otherwise {@code false}.
     * @throws NullPointerException if the provided iterable is {@code null}.
     */
    default boolean containsAll( Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L294">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L295">        return StreamSupport.stream(elements.spliterator(), false).allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Stream} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified stream is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The stream whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given stream are present, otherwise {@code false}.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    default boolean containsAll( Stream&lt;? extends E&gt; elements ) {
<span class="fc" id="L309">        return elements.parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Returns a new value set with the supplied element
     *  added to it, or this value set if the element is already present
     *  in this value set. The element must not be null.
     *
     * @param element The element to add to this value set.
     * @return A new value set with the given element,
     *        or this value set if the element is already present.
     */
    ValueSet&lt;E&gt; add( E element );

    /**
     *  Returns a new value set with all the elements from
     *  the supplied value set added to this one.
     *  If the given value set is empty, then this
     *  value set is returned unchanged.
     *
     * @param other The value set to merge with this one.
     * @return A new value set with the elements from the given value set.
     * @throws NullPointerException if the provided value set is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final ValueSet&lt;? extends E&gt; other ) {
<span class="fc" id="L334">        Objects.requireNonNull(other, &quot;The provided value set cannot be null.&quot;);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if ( other.isEmpty() )</span>
<span class="nc" id="L336">            return this;</span>
<span class="fc" id="L337">        return addAll(other.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Set} of elements added to it.
     *  If the supplied set is empty or there are no new elements in the
     *  supplied set, then this value set is returned unchanged.
     *
     * @param elements The set of elements to add to this value set.
     * @return A new value set with the elements from the provided set,
     *          or this value set if the provided set is empty.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L352">        Objects.requireNonNull(elements, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if ( elements.isEmpty() )</span>
<span class="fc" id="L354">            return this;</span>
<span class="fc" id="L355">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied array of elements added to it.
     *  If the provided array is empty, then this value set is
     *  returned unchanged.
     *
     * @param elements The array of elements to add to this value set.
     * @return A new value set with the elements from the provided array.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final E... elements ) {
<span class="fc" id="L369">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if ( elements.length == 0 )</span>
<span class="nc" id="L371">            return this;</span>
<span class="fc" id="L372">        return addAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Tuple} of elements added to it.
     *  If the provided tuple is empty, then this value set is
     *  returned unchanged.
     *
     * @param elements The tuple of elements to add to this value set.
     * @return A new value set with the elements from the provided tuple.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Tuple&lt;E&gt; elements ) {
<span class="fc" id="L386">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L388">            return this;</span>
<span class="fc" id="L389">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Collection} added to it.
     *  If the provided collection is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The collection of elements to add to this value set.
     * @return A new value set with the elements from the provided collection.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Collection&lt;E&gt; elements ) {
<span class="fc" id="L403">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L405">            return this;</span>
<span class="fc" id="L406">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Iterable} added to it.
     *  If the provided iterable is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The iterable of elements to add to this value set.
     * @return A new value set with the elements from the provided iterable.
     * @throws NullPointerException if the provided iterable is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Iterable&lt;? extends E&gt; elements ) {
<span class="fc" id="L420">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="fc" id="L421">        return addAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Stream} added to it.
     *  If the provided stream is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The stream of elements to add to this value set.
     * @return A new value set with the elements from the provided stream.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    ValueSet&lt;E&gt; addAll( final Stream&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set without the supplied element,
     *  but all other elements still kept.
     *  If the element is not present in this value set,
     *  then this value set is returned completely unchanged.
     *
     * @param element The element to be removed in the returned value set.
     * @return A new value set without the given element.
     */
    ValueSet&lt;E&gt; remove( E element );

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied set. If the
     *  supplied set is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the supplied set.
     *
     * @param elements The elements to remove from this value set.
     * @return A new value set without the elements in the given set.
     */
    default ValueSet&lt;E&gt; removeAll( Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L458">        Objects.requireNonNull(elements);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if ( elements.isEmpty() )</span>
<span class="fc" id="L460">            return this;</span>
<span class="fc" id="L461">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied value set. 
     *  If the supplied value set is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the supplied set.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the given value set, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final ValueSet&lt;? extends E&gt; elements ) {
<span class="nc" id="L475">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L477">            return this;</span>
<span class="nc" id="L478">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied array. If the
     *  supplied array is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied array of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the given array, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final E... elements ) {
<span class="fc" id="L493">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if ( elements.length == 0 )</span>
<span class="nc" id="L495">            return this;</span>
<span class="fc" id="L496">        return removeAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Collection}. 
     *  If the supplied collection is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied collection of elements.
     *
     * @param elements The collection of elements to remove from this value set (if present).
     * @return A new value set without the elements in the supplied collection, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L511">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L513">            return this;</span>
<span class="fc" id="L514">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Tuple}. 
     *  If the supplied tuple is empty, then this value set is returned
     *  completely unchanged.
     *  In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied tuple of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the supplied tuple, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L530">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (toTuple().isEmpty() )</span>
<span class="nc" id="L532">            return this;</span>
<span class="fc" id="L533">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Iterable}. 
     *  If the supplied iterable has no elements, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied iterable of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements found in the supplied iterable, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L548">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L549">        return removeAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Stream}. 
     *  If the supplied stream has no elements, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied stream of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements found in the supplied stream, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    ValueSet&lt;E&gt; removeAll( final Stream&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set where only those elements
     *  are kept that have an element present in the supplied set. 
     *  In other words, removes all of its elements in the new set that are 
     *  not contained in the specified set, which effectively creates 
     *  a value set that is the &lt;b&gt;intersection between this set and the other set&lt;/b&gt;.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. 
     *  If the supplied set is empty, then an empty set is returned.
     *
     * @param elements The elements to retain in this value set.
     * @return A new value set with only the elements in the given set.
     */
    ValueSet&lt;E&gt; retainAll( Set&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set where only those elements
     *  are kept that have an element present in the supplied value set.
     *  In other words, it removes from the new set all the elements that are 
     *  not contained in the specified set, which creates 
     *  a value set that is the &lt;b&gt;intersection between this set and the other value set&lt;/b&gt;.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied value set is empty, 
     *  then an empty set is returned.
     *
     * @param elements The elements to retain in this value set.
     * @return A new value set with only the elements in the given value set.
     */
    default ValueSet&lt;E&gt; retainAll( ValueSet&lt;? extends E&gt; elements ) {
<span class="nc" id="L594">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="nc" id="L595">        return retainAll(elements.toSet());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied array of elements. 
     *  In other words, removes from this set all of its elements that are 
     *  not contained in the specified array. So if you interpret the
     *  specified array as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the array.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied array is empty,
     *  then an empty set is returned.
     *  
     * @param elements An array of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value 
     *         set that are also present in the supplied array.
     * @throws NullPointerException If the array of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( E... elements ) {
<span class="fc" id="L615">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc" id="L616">        return retainAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Collection} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified collection. So if you interpret the
     *  specified collection as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the collection.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied collection is empty,
     *  then an empty set is returned.
     *
     * @param elements A collection of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied collection.
     * @throws NullPointerException If the collection of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L636">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc" id="L637">        return retainAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Tuple} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified tuple. So if you interpret the
     *  specified tuple as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the tuple.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied tuple is empty,
     *  then an empty set is returned.
     *
     * @param elements A tuple of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied tuple.
     * @throws NullPointerException If the tuple of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L657">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L658">        return retainAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Iterable} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified iterable. So if you interpret the
     *  specified iterable as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the iterable.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied iterable is empty,
     *  then an empty set is returned.
     *
     * @param elements An iterable of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied iterable.
     * @throws NullPointerException If the iterable of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L678">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L679">        return retainAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Stream} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified stream. So if you interpret the
     *  specified stream as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the stream.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied stream is empty,
     *  then an empty set is returned.
     *
     * @param elements A stream of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied stream.
     * @throws NullPointerException If the stream of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Stream&lt;? extends E&gt; elements ) {
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L700">            return this;</span>
<span class="fc" id="L701">        Set&lt;E&gt; elementsSet = elements.collect(HashSet::new, HashSet::add, HashSet::addAll);</span>
<span class="fc" id="L702">        return retainAll(elementsSet);</span>
    }

    /**
     *  Returns a completely empty value set but
     *  with the same element type as this one.
     *  So the {@link #type()} of the returned value set will be the same
     *  as the type of this value set.
     *
     * @return A new value set without any elements,
     *         or this value set if it is already empty.
     */
    default ValueSet&lt;E&gt; clear() {
<span class="fc" id="L715">        return Sprouts.factory().valueSetOf(this.type());</span>
    }

    /**
     *  Converts this value set to a java.util.Map.
     *  Note that the returned map is also immutable.
     *
     * @return A java.util.Map representation of this value set.
     */
    default Set&lt;E&gt; toSet()  {
<span class="fc" id="L725">        return new AbstractSet&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L728">                return ValueSet.this.iterator();</span>
            }
            @Override
            public int size() {
<span class="fc" id="L732">                return ValueSet.this.size();</span>
            }
            @Override
            public boolean contains(@Nullable Object o) {
<span class="pc bpc" id="L736" title="2 of 4 branches missed.">                if (o != null &amp;&amp; ValueSet.this.type().isAssignableFrom(o.getClass())) {</span>
<span class="fc" id="L737">                    return ValueSet.this.contains(ValueSet.this.type().cast(o));</span>
                }
<span class="nc" id="L739">                return false;</span>
            }
        };
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if any of them match the predicate,
     *  otherwise {@code false}. So if one or more elements match the predicate,
     *  then this method will always return {@code true}.
     *
     *  @param predicate The predicate to check.
     *  @return True if any of the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean any( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L755">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L756">        return this.stream().anyMatch( predicate );</span>
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if all of them match the predicate,
     *  otherwise {@code false}. So if one or more elements do not match the predicate,
     *  then this method will always return {@code false}.
     *
     *  @param predicate The predicate to check.
     *  @return True if all the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean all( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L770">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L771">        return this.stream().allMatch( predicate );</span>
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if none of them match the predicate,
     *  otherwise {@code false}. So if one or more elements match the predicate,
     *  then this method will always return {@code false}.
     *
     *  @param predicate The predicate to run over all elements.
     *  @return True if none of the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean none( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L785">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L786">        return this.stream().noneMatch( predicate );</span>
    }
    
    /**
     *  Returns a sequential {@link Stream} with this value set as its source.
     *
     * @return A sequential stream of the elements in this value set.
     */
    default Stream&lt;E&gt; stream() {
<span class="fc" id="L795">        return StreamSupport.stream(spliterator(), false);</span>
    }

    /**
     *  Returns a parallel {@link Stream} with this value set as its source.
     *
     * @return A parallel stream of the elements in this value set.
     */
    default Stream&lt;E&gt; parallelStream() {
<span class="nc" id="L804">        return StreamSupport.stream(spliterator(), true);</span>
    }

    /**
     *  Converts this value set to a {@link Tuple} of all the elements in it,
     *  where the {@link Tuple#type()} is the same as the {@link #type()} of this value set.
     *  Note that the order of the elements in the tuple will not
     *  have any specific meaning, as the value set is an unordered collection.
     *
     * @return A {@link Tuple} of all the elements in this value set.
     */
    default Tuple&lt;E&gt; toTuple() {
<span class="nc" id="L816">        return Tuple.of(type(), this);</span>
    }

    /**
     * Compares the specified object with this set for equality.
     * Returns {@code true} if the specified object is also a value set,
     * and the two sets have the same size, and every member of the specified
     * set is contained in this set (or equivalently, every member of this set is
     * contained in the specified set). This definition ensures that the
     * equals method works properly across different implementations of the
     * set interface.
     *
     * @param o object to be compared for equality with this set
     * @return {@code true} if the specified object is equal to this set
     */
    boolean equals( Object o );

    /**
     * Returns the hash code value for this set. The hash code of a set is
     * defined to be the sum of the hash codes of the elements in the set.
     * This ensures that {@code s1.equals(s2)} implies that
     * {@code s1.hashCode()==s2.hashCode()} for any two sets {@code s1}
     * and {@code s2}, as required by the general contract of
     * {@link Object#hashCode}.
     *
     * @return The hash code value for this set as a 32-bit integer,
     *         based on the sum of the hash codes of all elements in this set.
     * @see Object#equals(Object)
     * @see Set#equals(Object)
     */
    int hashCode();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>