<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ValueSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">ValueSet.java</span></div><h1>ValueSet.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import sprouts.impl.Sprouts;

import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 *  An immutable collection of non-null elements that contains no duplicates,
 *  meaning that it can never contain a pair of elements e1 and e2 such that e1.equals(e2).
 *  As implied by its name, this interface models the mathematical set abstraction,
 *  similar to {@link Set}, but with the difference that this has consistent
 *  value object semantics and is immutable. &lt;br&gt;
 *  This means that you cannot modify the contents of a value set after it
 *  has been created, but you can create a new value set with the desired
 *  changes using methods like {@code ValueSet::add(E)} or {@code ValueSet::remove(E)},
 *  which will return a new value set with the changes applied.
 *  &lt;br&gt;&lt;br&gt;
 *  &lt;p&gt;&lt;b&gt;
 *      Note: Mutable objects should not be stored in a
 *      value set, which is especially important with respect to
 *      their hash codes and equality,
 *      which have to stay constant for the lifetime
 *      within the value set, as it assumes that their behavior
 *      does not change (due to element code hash caching for example).
 *      The behavior of this class is uncertain if an element
 *      is changed in a manner that affects equals
 *      or hashCode after it has been added to the value set.
 *  &lt;/b&gt;
 *
 * @param &lt;E&gt; The type of the elements in this value set, which must be immutable.
 * @see Association An immutable key-value pair with consistent value object semantics.
 * @see Tuple An immutable collection of ordered and indexed item with consistent value object semantics.
 */
public interface ValueSet&lt;E&gt; extends Iterable&lt;E&gt; {

    /**
     *  An alternative to {@code ValueSet.class} which also includes the parameter
     *  type in the type signature of the returned {@link ValueSet} class.
     *  This is useful when you want to use value sets as items in collection
     *  types or properties...
     *
     * @param elementType The element type {@code K} in the returned {@code Class&lt;ValueSet&lt;K&gt;&gt;}.
     * @return The {@code ValueSet.class} but with the parameter type included as {@code K} in {@code Class&lt;ValueSet&lt;K&gt;&gt;}.
     * @param &lt;E&gt; The type of elements in the value set class parameter signature.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; Class&lt;ValueSet&lt;E&gt;&gt; classTyped( Class&lt;E&gt; elementType ) {
<span class="fc" id="L57">        Objects.requireNonNull(elementType);</span>
<span class="fc" id="L58">        return (Class) ValueSet.class;</span>
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into
     *  a value set. The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOf(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new value set of string elements
     *  where the strings are all uppercased.
     *  If there are null values in the stream, an exception will be thrown,
     *  because a value set cannot contain null elements.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into a value set.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    static &lt;E&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOf( Class&lt;E&gt; type ) {
<span class="fc" id="L84">        Objects.requireNonNull(type);</span>
<span class="fc" id="L85">        return Collector.of(</span>
                    (Supplier&lt;Set&lt;E&gt;&gt;) HashSet::new,
                    Set::add,
<span class="fc" id="L88">                    (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L89">                    set -&gt; ValueSet.of(type).addAll(set)</span>
                );
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into a linked value set with
     *  an order, which is defined by the insertion order of the elements.
     *  The types of the elements and values in the
     *  value set have to be specified when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOfLinked(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered value set of string elements
     *  where the strings are all uppercased and ordered by their insertion order.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into an ordered value set.
     */
    static &lt;E&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOfLinked( Class&lt;E&gt; type ) {
<span class="fc" id="L114">        Objects.requireNonNull(type);</span>
<span class="fc" id="L115">        return Collector.of(</span>
                (Supplier&lt;Set&lt;E&gt;&gt;) LinkedHashSet::new,
                Set::add,
<span class="fc" id="L118">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L119">                set -&gt; ValueSet.ofLinked(type).addAll(set)</span>
        );
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into
     *  a value set with an explicit order defined by the supplied comparator.
     *  The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOfSorted(String.class, Comparator.naturalOrder()));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered value set of string elements
     *  where the strings are all uppercased and ordered by their natural order.
     *
     * @param type The type of the elements in the value set to collect.
     * @param comparator The comparator to use for sorting the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into an ordered value set.
     */
    static &lt;E&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOfSorted( Class&lt;E&gt; type, Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L145">        Objects.requireNonNull(type);</span>
<span class="fc" id="L146">        Objects.requireNonNull(comparator);</span>
<span class="fc" id="L147">        return Collector.of(</span>
                (Supplier&lt;List&lt;E&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L150">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L151">                list -&gt; ValueSet.ofSorted(type, comparator).addAll(list)</span>
        );
    }

    /**
     *  A collector that can be used to collect elements
     *  from a Java {@link Stream} into a value set with the order being based
     *  on the {@link Comparable} implementation of the elements and the
     *  natural ordering of the elements.&lt;br&gt;
     *  The types of the elements and values in the
     *  value set have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; it.toUpperCase() )
     *                .collect(ValueSet.collectorOfSorted(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered value set of string elements
     *  where the strings are all uppercased and ordered by their natural order.
     *
     * @param type The type of the elements in the value set to collect.
     * @param &lt;E&gt; The type of the elements in the value set,
     *            which must be immutable and have value object semantics.
     * @return A collector that can be used to collect elements into an ordered value set.
     */
    static &lt;E extends Comparable&lt;? super E&gt;&gt; Collector&lt;E, ?, ValueSet&lt;E&gt;&gt; collectorOfSorted( Class&lt;E&gt; type ) {
<span class="fc" id="L177">        Objects.requireNonNull(type);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if ( !Comparable.class.isAssignableFrom(type) ) {</span>
<span class="nc" id="L179">            throw new IllegalArgumentException(&quot;The provided type must implement Comparable.&quot;);</span>
        }
<span class="fc" id="L181">        return Collector.of(</span>
                (Supplier&lt;List&lt;E&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L184">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L185">                list -&gt; ValueSet.ofSorted(type).addAll(list)</span>
        );
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type.
     *  A value set knows the types of its elements, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( Class&lt;E&gt; type ) {
<span class="fc" id="L200">        Objects.requireNonNull(type);</span>
<span class="fc" id="L201">        return Sprouts.factory().valueSetOf(type);</span>
    }

    /**
     *  Creates a new value set from a single non-null element.
     *  The type of the element is captured from the element itself
     *  through the {@link Object#getClass()} method.
     *  The resulting value set will have a size of 1 and does not
     *  allow null elements.
     *
     * @param element The element to store as the only element in the value set.
     * @param &lt;E&gt; The type of the element in the value set, this must be an immutable type.
     * @return A new value set with the given element
     *         and a size of 1.
     * @throws NullPointerException If the provided element is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( final @NonNull E element ) {
<span class="fc" id="L218">        Objects.requireNonNull(element);</span>
<span class="fc" id="L219">        return of((Class&lt;E&gt;) element.getClass()).add(element);</span>
    }
    
    /**
     *  Creates a new value set from the given elements.
     *  The types of the elements are inferred from the elements themselves
     *  through the {@link Object#getClass()} method.
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; ValueSet&lt;E&gt; of( @NonNull E first, @NonNull E... rest ) {
<span class="fc" id="L236">        Objects.requireNonNull(first);</span>
<span class="fc" id="L237">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L238">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L239">        return of(type).add(first).addAll(rest);</span>
    }

    /**
     *  Creates a new value set from the given {@link Tuple} of elements.
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If the provided tuple is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( Tuple&lt;E&gt; tuple ) {
<span class="fc" id="L253">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L254">        return Sprouts.factory().valueSetOf(tuple.type()).addAll(tuple);</span>
    }

    /**
     *  Creates a new value set from the given {@link Iterable} of elements.
     *  The type of the elements must be provided explicitly in case
     *  of the iterable being empty.
     *
     * @param type The type of the elements in the value set.
     * @param elements The iterable of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, this must be an immutable type.
     * @return A new value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null or if the provided iterable is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; of( @NonNull Class&lt;E&gt; type, @NonNull Iterable&lt;E&gt; elements ) {
<span class="fc" id="L269">        Objects.requireNonNull(type);</span>
<span class="fc" id="L270">        Objects.requireNonNull(elements);</span>
<span class="fc" id="L271">        return of(type).addAll(elements);</span>
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type,
     *  and where the order of the elements is defined by the insertion order.
     *  Which means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  A value set knows the types of its elements, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new linked value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( Class&lt;E&gt; type ) {
<span class="fc" id="L288">        Objects.requireNonNull(type);</span>
<span class="fc" id="L289">        return Sprouts.factory().valueSetOfLinked(type);</span>
    }

    /**
     *  Creates a new linked value of the supplied type as well as
     *  elements from the supplied {@link Iterable} to it,
     *  where the order of the elements is defined by the insertion order.
     *  This means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  A value set knows the types of its elements, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    ValueSet.ofLinked(
     *       String.class,
     *       List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *    );
     *  }&lt;/pre&gt;
     *
     * @param type The type of the elements in the value set.
     * @param elements The iterable of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new linked value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( Class&lt;E&gt; type, Iterable&lt;E&gt; elements ) {
<span class="fc" id="L315">        Objects.requireNonNull(type);</span>
<span class="fc" id="L316">        Objects.requireNonNull(elements);</span>
<span class="fc" id="L317">        return ofLinked(type).addAll(elements);</span>
    }

    /**
     *  Creates a new linked value set of one or more elements,
     *  where the order of the elements is defined by the insertion order.
     *  The order of the supplied items is preserved in the new value set,
     *  which means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  The type of the elements is captured from the first element through
     *  the {@link Object#getClass()} method.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    ValueSet.ofLinked(1, 2, 3);
     *  }&lt;/pre&gt;
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new linked value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( @NonNull E first, @NonNull E... rest ) {
<span class="fc" id="L342">        Objects.requireNonNull(first);</span>
<span class="fc" id="L343">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L344">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L345">        return ofLinked(type).add(first).addAll(rest);</span>
    }

    /**
     *  Creates a new linked value set from the given {@link Tuple} of elements,
     *  where the order of the elements is defined by the insertion order.
     *  The order of the items in the tuple is preserved in the value set,
     *  which means that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type.
     * @return A new linked value set with the given elements.
     * @throws NullPointerException If the supplied tuple is null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofLinked( Tuple&lt;E&gt; tuple ) {
<span class="fc" id="L363">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L364">        return Sprouts.factory().valueSetOf(tuple.type()).addAll(tuple);</span>
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type,
     *  but with an explicit order defined by the supplied comparator.
     *  A value set knows the types of its elements and values, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  type of the value set.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used
     *  to create a set with string elements sorted by their length:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    ValueSet.ofSorted(
     *       String.class,
     *       Comparator.comparing(String::length)
     *    );
     *  }&lt;/pre&gt;
     *
     * @param type The type of the elements in the value set.
     * @param comparator The comparator to use for sorting the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new sorted value set specific to the given element type.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofSorted( Class&lt;E&gt; type, Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L388">        Objects.requireNonNull(type);</span>
<span class="fc" id="L389">        Objects.requireNonNull(comparator);</span>
<span class="fc" id="L390">        return Sprouts.factory().valueSetOfSorted(type, comparator);</span>
    }

    /**
     *  Creates a new value set specifically for holding elements of the supplied type,
     *  elements are sorted based on the natural ordering of the elements
     *  (which are expected to implement {@link Comparable}).
     *  A value set knows the types of its elements and values, and so
     *  you can only add elements which are of the same type or a subtype of the
     *  specified element type of the value set.
     *
     * @param type The type of the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable value type.
     * @return A new sorted value set specific to the given element type.
     */
    static &lt;E extends Comparable&lt;? super E&gt;&gt; ValueSet&lt;E&gt; ofSorted( Class&lt;E&gt; type ) {
<span class="fc" id="L406">        Objects.requireNonNull(type);</span>
<span class="fc" id="L407">        return Sprouts.factory().valueSetOfSorted(type);</span>
    }

    /**
     *  Creates a new sorted value set from the given {@link Tuple} of
     *  {@link Comparable} elements.&lt;br&gt;
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *  The elements are sorted based on their natural ordering,
     *  which is defined by their {@link Comparable} implementation.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type and implement {@link Comparable}.
     * @return A new sorted value set with the given elements.
     * @throws NullPointerException If the supplied tuple is null.
     */
    static &lt;E extends Comparable&lt;? super E&gt;&gt; ValueSet&lt;E&gt; ofSorted( Tuple&lt;E&gt; tuple ) {
<span class="fc" id="L424">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L425">        return Sprouts.factory().valueSetOfSorted(tuple.type()).addAll(tuple);</span>
    }

    /**
     *  Creates a new sorted value set from the given {@link Tuple} of elements,
     *  with an explicit order defined by the supplied {@link Comparator}.
     *  The type of the elements is captured from the tuple itself
     *  through the {@link Tuple#type()} method.
     *
     * @param tuple The tuple of elements to store in the value set.
     * @param comparator The comparator to use for sorting the elements in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type.
     * @return A new sorted value set with the given elements.
     * @throws NullPointerException If any of the provided parameters are null.
     */
    static &lt;E&gt; ValueSet&lt;E&gt; ofSorted( Tuple&lt;E&gt; tuple, Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L441">        Objects.requireNonNull(tuple, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L442">        Objects.requireNonNull(comparator, &quot;The provided comparator cannot be null.&quot;);</span>
<span class="fc" id="L443">        return Sprouts.factory().valueSetOfSorted(tuple.type(), comparator).addAll(tuple);</span>
    }

    /**
     *  Creates a new sorted value set of one or more {@link Comparable} elements.
     *  The elements are sorted based on their natural ordering.
     *  The type of the elements is captured from the first element through
     *  the {@link Object#getClass()} method.
     *
     * @param first The first element to store in the value set.
     * @param rest The rest of the elements to store in the value set.
     * @param &lt;E&gt; The type of the elements in the value set, which must be an immutable type and implement {@link Comparable}.
     * @return A new sorted value set with the given elements.
     * @throws NullPointerException If any of the provided elements are null.
     */
    @SafeVarargs
    static &lt;E extends Comparable&lt;E&gt;&gt; ValueSet&lt;E&gt; ofSorted( E first, E... rest ) {
<span class="fc" id="L460">        Objects.requireNonNull(first);</span>
<span class="fc" id="L461">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L462">        Class&lt;E&gt; type = (Class&lt;E&gt;) first.getClass();</span>
<span class="fc" id="L463">        return ofSorted(type).add(first).addAll(rest);</span>
    }

    /**
     *  Returns the total number of all elements in this value set.
     *
     * @return The number of elements in this value set.
     */
    int size();

    /**
     *  Checks if this value set is empty and returns
     *  {@code true} if it is, otherwise {@code false}.
     *
     * @return {@code true} if this value set is empty, otherwise {@code false}.
     */
    default boolean isEmpty() {
<span class="fc bfc" id="L480" title="All 2 branches covered.">        return size() == 0;</span>
    }

    /**
     *  Checks if this value set is not empty and returns
     *  {@code true} if it is not, otherwise {@code false}.
     *
     * @return {@code true} if this value set is not empty, otherwise {@code false}.
     */
    default boolean isNotEmpty() {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        return !isEmpty();</span>
    }

    /**
     *  Checks if this value set is a linked value set and returns
     *  {@code true} if it is, otherwise {@code false}.
     *  A linked value set is a value set that preserves the insertion order
     *  of the elements, meaning that during iteration over the value set,
     *  the elements will be returned in the order they were added.
     *
     * @return {@code true} if this set is a linked value set, otherwise {@code false}.
     */
    boolean isLinked();

    /**
     *  Checks if this value set is sorted and returns
     *  {@code true} if it is, otherwise {@code false}.
     *  A value set is sorted if the entries are sorted in
     *  natural order or according to a supplied comparator
     *  when the set was created.&lt;br&gt;
     *  You can create a sorted set using factory methods
     *  like {@link #ofSorted(Class, Comparator)}, or
     *  by converting an existing set to a sorted one
     *  using the {@link #sort(Comparator)} method.
     *
     * @return {@code true} if this set is sorted, otherwise {@code false}.
     */
    boolean isSorted();

    /**
     *  Returns the {@link Class} of the
     *  type of the elements in this value set.
     *  Note that this may also be a superclass of the actual
     *  elements in the value set, but it will always be the
     *  type that was used to create the value set.
     *
     * @return The type of the elements in this value set.
     */
    Class&lt;E&gt; type();

    /**
     *  Checks if the supplied element is present in this value set
     *  and returns {@code true} if it is, otherwise {@code false}.
     *
     * @param element The element whose presence in this value set is to be checked.
     * @return {@code true} if the element is present, otherwise {@code false}.
     */
    boolean contains( E element );

    /**
     *  Checks if all the elements in the supplied value set are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified set is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The value set whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given value set are present, otherwise {@code false}.
     * @throws NullPointerException if the provided value set is {@code null}.
     */
    default boolean containsAll( ValueSet&lt;? extends E&gt; elements ) {
<span class="fc" id="L550">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="fc" id="L551">        return elements.stream().parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Checks if all the elements in the given set are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified set is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The set whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given set are present, otherwise {@code false}.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default boolean containsAll( Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L565">        Objects.requireNonNull(elements, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L566">        return containsAll((Collection&lt;? extends E&gt;) elements);</span>
    }
    
    /**
     *  Checks if all the elements in the given array are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified array is effectively
     *  a &lt;i&gt;subset&lt;/i&gt; of this set, and then returns {@code true} if it is.
     *
     * @param elements The array whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given array are present, otherwise {@code false}.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default boolean containsAll( E... elements ) {
<span class="fc" id="L580">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc" id="L581">        return Arrays.stream(elements).parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Collection} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified collection is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The collection whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given collection are present, otherwise {@code false}.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default boolean containsAll( Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L595">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc" id="L596">        return elements.stream().parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Tuple} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified tuple is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The tuple whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given tuple are present, otherwise {@code false}.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default boolean containsAll( Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L610">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L611">        return elements.stream().parallel().allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Iterable} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified iterable is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The iterable whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given iterable are present, otherwise {@code false}.
     * @throws NullPointerException if the provided iterable is {@code null}.
     */
    default boolean containsAll( Iterable&lt;? extends E&gt; elements ) {
<span class="fc" id="L625">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="fc" id="L626">        return StreamSupport.stream(elements.spliterator(), false).allMatch(this::contains);</span>
    }

    /**
     *  Checks if all the elements in the supplied {@link Stream} are present in this value set
     *  and returns {@code true} if they are, otherwise {@code false}.
     *  In other words, it checks if the specified stream is a &lt;i&gt;subset&lt;/i&gt; of this set,
     *  and then returns {@code true} if it is.
     *
     * @param elements The stream whose elements are to be checked for presence in this value set.
     * @return {@code true} if all the elements in the given stream are present, otherwise {@code false}.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    default boolean containsAll( Stream&lt;? extends E&gt; elements ) {
<span class="fc" id="L640">        return elements.parallel().allMatch(this::contains);</span>
    }
    
    /**
     *  Returns a new value set with the supplied element
     *  added to it, or this value set if the element is already present
     *  in this value set. The element must not be null.
     *
     * @param element The element to add to this value set.
     * @return A new value set with the given element,
     *        or this value set if the element is already present.
     */
    ValueSet&lt;E&gt; add( E element );

    /**
     *  Returns a new value set with all the elements from
     *  the supplied value set added to this one.
     *  If the given value set is empty, then this
     *  value set is returned unchanged.
     *
     * @param other The value set to merge with this one.
     * @return A new value set with the elements from the given value set.
     * @throws NullPointerException if the provided value set is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final ValueSet&lt;? extends E&gt; other ) {
<span class="fc" id="L665">        Objects.requireNonNull(other, &quot;The provided value set cannot be null.&quot;);</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">        if ( other.isEmpty() )</span>
<span class="nc" id="L667">            return this;</span>
<span class="fc" id="L668">        return addAll(other.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Set} of elements added to it.
     *  If the supplied set is empty or there are no new elements in the
     *  supplied set, then this value set is returned unchanged.
     *
     * @param elements The set of elements to add to this value set.
     * @return A new value set with the elements from the provided set,
     *          or this value set if the provided set is empty.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L683">        Objects.requireNonNull(elements, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L684">        return addAll((Collection&lt;? extends E&gt;) elements);</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied array of elements added to it.
     *  If the provided array is empty, then this value set is
     *  returned unchanged.
     *
     * @param elements The array of elements to add to this value set.
     * @return A new value set with the elements from the provided array.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final E... elements ) {
<span class="fc" id="L698">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        if ( elements.length == 0 )</span>
<span class="fc" id="L700">            return this;</span>
<span class="fc" id="L701">        return addAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Tuple} of elements added to it.
     *  If the provided tuple is empty, then this value set is
     *  returned unchanged.
     *
     * @param elements The tuple of elements to add to this value set.
     * @return A new value set with the elements from the provided tuple.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Tuple&lt;E&gt; elements ) {
<span class="fc" id="L715">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L717">            return this;</span>
<span class="fc" id="L718">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Collection} added to it.
     *  If the provided collection is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The collection of elements to add to this value set.
     * @return A new value set with the elements from the provided collection.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L732">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">        if ( elements.isEmpty() )</span>
<span class="fc" id="L734">            return this;</span>
<span class="fc" id="L735">        return addAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Iterable} added to it.
     *  If the provided iterable is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The iterable of elements to add to this value set.
     * @return A new value set with the elements from the provided iterable.
     * @throws NullPointerException if the provided iterable is {@code null}.
     */
    default ValueSet&lt;E&gt; addAll( final Iterable&lt;? extends E&gt; elements ) {
<span class="fc" id="L749">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="fc" id="L750">        return addAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set with all the elements from the
     *  supplied {@link Stream} added to it.
     *  If the provided stream is empty, then this
     *  value set is returned unchanged.
     *
     * @param elements The stream of elements to add to this value set.
     * @return A new value set with the elements from the provided stream.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    ValueSet&lt;E&gt; addAll( final Stream&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set without the supplied element,
     *  but all other elements still kept.
     *  If the element is not present in this value set,
     *  then this value set is returned completely unchanged.
     *
     * @param element The element to be removed in the returned value set.
     * @return A new value set without the given element.
     */
    ValueSet&lt;E&gt; remove( E element );

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied set. If the
     *  supplied set is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the supplied set.
     *
     * @param elements The elements to remove from this value set.
     * @return A new value set without the elements in the given set.
     */
    default ValueSet&lt;E&gt; removeAll( Set&lt;? extends E&gt; elements ) {
<span class="fc" id="L787">        Objects.requireNonNull(elements);</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        if ( elements.isEmpty() )</span>
<span class="fc" id="L789">            return this;</span>
<span class="fc" id="L790">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied value set. 
     *  If the supplied value set is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the supplied set.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the given value set, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final ValueSet&lt;? extends E&gt; elements ) {
<span class="nc" id="L804">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L806">            return this;</span>
<span class="nc" id="L807">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied array. If the
     *  supplied array is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied array of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the given array, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final E... elements ) {
<span class="fc" id="L822">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">        if ( elements.length == 0 )</span>
<span class="nc" id="L824">            return this;</span>
<span class="fc" id="L825">        return removeAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Collection}. 
     *  If the supplied collection is empty, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied collection of elements.
     *
     * @param elements The collection of elements to remove from this value set (if present).
     * @return A new value set without the elements in the supplied collection, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L840">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">        if ( elements.isEmpty() )</span>
<span class="nc" id="L842">            return this;</span>
<span class="fc" id="L843">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Tuple}. 
     *  If the supplied tuple is empty, then this value set is returned
     *  completely unchanged.
     *  In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied tuple of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements in the supplied tuple, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L859">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">        if (toTuple().isEmpty() )</span>
<span class="nc" id="L861">            return this;</span>
<span class="fc" id="L862">        return removeAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Iterable}. 
     *  If the supplied iterable has no elements, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied iterable of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements found in the supplied iterable, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    default ValueSet&lt;E&gt; removeAll( final Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L877">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L878">        return removeAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set that is the same as this one
     *  but without any of the elements in the supplied {@link Stream}. 
     *  If the supplied stream has no elements, then this value set is returned
     *  unchanged. In other words, this operation creates a value set which is
     *  the &lt;i&gt;asymmetric set difference&lt;/i&gt; between this set and the
     *  supplied stream of elements.
     *
     * @param elements The elements which should not be present in the returned value set.
     * @return A new value set without the elements found in the supplied stream, a.k.a. &lt;i&gt;asymmetric set difference&lt;/i&gt;.
     */
    ValueSet&lt;E&gt; removeAll( final Stream&lt;? extends E&gt; elements );

    /**
     *  Creates an updated {@link ValueSet} where all elements satisfying
     *  the given {@link Predicate}, are removed. Or in other words,
     *  if {@link Predicate#test(Object)} yields {@code true} for a particular
     *  element, then it will be removed, otherwise, it will remain in the
     *  returned set.&lt;br&gt;
     *  Note that errors or runtime exceptions thrown
     *  during iteration or by the predicate are relayed to the caller.
     *
     * @param filter A function which takes in a set element {@link E}, and returns
     *               {@code true} to trigger its removal and {@code false} to ensure it is kept.
     * @return An updated {@link ValueSet} where elements are removed according to the
     *         supplied predicate test, or this instance if nothing was removed.
     * @throws NullPointerException - if the specified filter is null
     */
    default ValueSet&lt;E&gt; removeIf( Predicate&lt;? super E&gt; filter ) {
<span class="fc" id="L910">        Objects.requireNonNull(filter);</span>
<span class="fc" id="L911">        return removeAll(stream().filter(filter));</span>
    }

    /**
     *  Returns a new value set where only those elements
     *  are kept that have an element present in the supplied set. 
     *  In other words, removes all of its elements in the new set that are 
     *  not contained in the specified set, which effectively creates 
     *  a value set that is the &lt;b&gt;intersection between this set and the other set&lt;/b&gt;.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. 
     *  If the supplied set is empty, then an empty set is returned.
     *
     * @param elements The elements to retain in this value set.
     * @return A new value set with only the elements in the given set.
     */
    ValueSet&lt;E&gt; retainAll( Set&lt;? extends E&gt; elements );

    /**
     *  Returns a new value set where only those elements
     *  are kept that have an element present in the supplied value set.
     *  In other words, it removes from the new set all the elements that are 
     *  not contained in the specified set, which creates 
     *  a value set that is the &lt;b&gt;intersection between this set and the other value set&lt;/b&gt;.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied value set is empty, 
     *  then an empty set is returned.
     *
     * @param elements The elements to retain in this value set.
     * @return A new value set with only the elements in the given value set.
     */
    default ValueSet&lt;E&gt; retainAll( ValueSet&lt;? extends E&gt; elements ) {
<span class="nc" id="L943">        Objects.requireNonNull(elements, &quot;The provided value set cannot be null.&quot;);</span>
<span class="nc" id="L944">        return retainAll(elements.toSet());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied array of elements. 
     *  In other words, removes from this set all of its elements that are 
     *  not contained in the specified array. So if you interpret the
     *  specified array as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the array.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied array is empty,
     *  then an empty set is returned.
     *  
     * @param elements An array of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value 
     *         set that are also present in the supplied array.
     * @throws NullPointerException If the array of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( E... elements ) {
<span class="fc" id="L964">        Objects.requireNonNull(elements, &quot;The provided array cannot be null.&quot;);</span>
<span class="fc" id="L965">        return retainAll(Arrays.stream(elements));</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Collection} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified collection. So if you interpret the
     *  specified collection as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the collection.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied collection is empty,
     *  then an empty set is returned.
     *
     * @param elements A collection of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied collection.
     * @throws NullPointerException If the collection of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Collection&lt;? extends E&gt; elements ) {
<span class="fc" id="L985">        Objects.requireNonNull(elements, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc" id="L986">        return retainAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Tuple} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified tuple. So if you interpret the
     *  specified tuple as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the tuple.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied tuple is empty,
     *  then an empty set is returned.
     *
     * @param elements A tuple of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied tuple.
     * @throws NullPointerException If the tuple of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Tuple&lt;? extends E&gt; elements ) {
<span class="fc" id="L1006">        Objects.requireNonNull(elements, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="fc" id="L1007">        return retainAll(elements.stream());</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Iterable} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified iterable. So if you interpret the
     *  specified iterable as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the iterable.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied iterable is empty,
     *  then an empty set is returned.
     *
     * @param elements An iterable of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied iterable.
     * @throws NullPointerException If the iterable of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Iterable&lt;? extends E&gt; elements ) {
<span class="nc" id="L1027">        Objects.requireNonNull(elements, &quot;The provided iterable cannot be null.&quot;);</span>
<span class="nc" id="L1028">        return retainAll(StreamSupport.stream(elements.spliterator(), false));</span>
    }

    /**
     *  Returns a new value set in which only those elements are kept,
     *  which are also present in the supplied {@link Stream} of elements.
     *  In other words, removes from this set all of its elements that are
     *  not contained in the specified stream. So if you interpret the
     *  specified stream as a set, this operation will effectively create
     *  a value set that is the intersection between this set and the stream.
     *  This is similar to the {@link Set#retainAll(Collection)} operation on
     *  a mutable JDK set. Note that if the supplied stream is empty,
     *  then an empty set is returned.
     *
     * @param elements A stream of elements which should be kept in the returned value set.
     * @return A new value set which keeps only those elements in this value
     *         set that are also present in the supplied stream.
     * @throws NullPointerException If the stream of elements is null or one of the elements is null.
     */
    default ValueSet&lt;E&gt; retainAll( Stream&lt;? extends E&gt; elements ) {
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L1049">            return this;</span>
<span class="fc" id="L1050">        Set&lt;E&gt; elementsSet = elements.collect(HashSet::new, HashSet::add, HashSet::addAll);</span>
<span class="fc" id="L1051">        return retainAll(elementsSet);</span>
    }

    /**
     *  Creates an updated {@link ValueSet} where only those elements are
     *  kept which satisfy the given {@link Predicate}. Or in other words,
     *  if {@link Predicate#test(Object)} yields {@code true} for a particular
     *  element, then it will be kept, otherwise, it will be removed from
     *  returned set.&lt;br&gt;
     *  Note that errors or runtime exceptions thrown
     *  during iteration or by the predicate are relayed to the caller.
     *
     * @param filter A function which takes in a set element {@link E}, and returns
     *               {@code false} to trigger its removal and {@code true} to ensure it is kept.
     * @return An updated {@link ValueSet} where elements are removed according to the
     *         supplied predicate test, or this instance if nothing was removed.
     * @throws NullPointerException - if the specified filter is null
     */
    default ValueSet&lt;E&gt; retainIf( Predicate&lt;? super E&gt; filter ) {
<span class="fc" id="L1070">        Objects.requireNonNull(filter);</span>
<span class="fc" id="L1071">        return retainAll(stream().filter(filter));</span>
    }

    /**
     *  Creates a new value set containing only the elements that are NOT instances of the specified type.
     *  This method filters out all elements that are assignable to the given class,
     *  effectively retaining entries that do not match the specified type criteria.&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Example:&lt;/b&gt;
     *  &lt;pre&gt;{@code
     *  // Given a value set with mixed types:
     *  var mixed = ValueSet.of(Object.class, 1, &quot;x&quot;, 2.5, &quot;z&quot;, 3);
     *
     *  // Remove all String instances
     *  ValueSet&lt;Object&gt; withoutStrings = mixed.removeIf(String.class);
     *  // Result: [1, 2.5, 3]
     *  }&lt;/pre&gt;&lt;br&gt;
     *
     *  &lt;b&gt;Type Safety:&lt;/b&gt;
     *  The returned value set maintains the same element type {@code E} as this value set,
     *  as the operation only removes elements but doesn't change the type of remaining elements.&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Null handling:&lt;/b&gt;
     *  Since value sets cannot contain null elements (as specified in the class documentation),
     *  null elements are never present and thus never need to be considered in the filtering process.&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Empty Result:&lt;/b&gt;
     *  If no elements in this value set match the specified type, this value set is returned unchanged.
     *
     * @param type The class type to filter out from the value set. Elements that are instances of this type
     *             (including subclasses) will be removed from the result.
     * @param &lt;V&gt; The type to filter out, must be a subtype of the value set's element type {@code E}.
     * @return A new value set containing only elements that are not instances of the specified type.
     * @throws NullPointerException if the provided {@code type} parameter is {@code null}.
     */
    default &lt;V extends E&gt; ValueSet&lt;E&gt; removeIf( Class&lt;V&gt; type ) {
<span class="fc" id="L1107">        Objects.requireNonNull(type, &quot;The provided type cannot be null.&quot;);</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (isEmpty()) {</span>
<span class="fc" id="L1109">            return this;</span>
        }
<span class="fc bfc" id="L1111" title="All 2 branches covered.">        if ( Objects.equals(this.type(), type) ) {</span>
<span class="fc" id="L1112">            return this.clear();</span>
        }
<span class="fc" id="L1114">        return removeIf(element -&gt; type.isAssignableFrom(element.getClass()));</span>
    }

    /**
     *  Creates a new value set containing only the elements that are instances of the specified type.
     *  This method filters the value set to retain all elements that are assignable to the given class,
     *  effectively keeping entries that match the specified type criteria while removing all others.&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Example:&lt;/b&gt;
     *  &lt;pre&gt;{@code
     *  // Given a value set with mixed types:
     *  var mixed = ValueSet.of(Object.class, 1, &quot;x&quot;, 2.5, &quot;z&quot;, 3);
     *
     *  // Keep only String instances
     *  ValueSet&lt;String&gt; onlyStrings = mixed.retainIf(String.class);
     *  // Result: [&quot;x&quot;, &quot;z&quot;]
     *  }&lt;/pre&gt;&lt;br&gt;
     *
     *  &lt;b&gt;Type Safety:&lt;/b&gt;
     *  The returned value set is explicitly typed with the specified class type {@code V},
     *  allowing for type-safe operations on the filtered results without the need for explicit casting.&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Null handling:&lt;/b&gt;
     *  Since value sets cannot contain null elements (as specified in the class documentation),
     *  null elements are never present and thus never need to be considered in the filtering process.
     *
     * @param type The class type to filter by. Only elements that are instances of this type
     *             (including subclasses) will be retained in the result.
     * @param &lt;V&gt; The type to filter by, must be a subtype of the value set's element type {@code E}.
     * @return A new value set containing only elements that are instances of the specified type,
     *         typed as {@code ValueSet&lt;V&gt;}.
     * @throws NullPointerException if the provided {@code type} parameter is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    &lt;V extends E&gt; ValueSet&lt;V&gt; retainIf( Class&lt;V&gt; type );

    /**
     *  Returns a completely empty value set but
     *  with the same element type as this one.
     *  So the {@link #type()} of the returned value set will be the same
     *  as the type of this value set.
     *
     * @return A new value set without any elements,
     *         or this value set if it is already empty.
     */
    ValueSet&lt;E&gt; clear();

    /**
     *  Converts this value set to a java.util.Map.
     *  Note that the returned map is also immutable.
     *
     * @return A java.util.Map representation of this value set.
     */
    default Set&lt;E&gt; toSet()  {
<span class="fc" id="L1168">        return new AbstractSet&lt;E&gt;() {</span>
            @Override
            public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L1171">                return ValueSet.this.iterator();</span>
            }
            @Override
            public int size() {
<span class="fc" id="L1175">                return ValueSet.this.size();</span>
            }
            @Override
            public boolean contains(@Nullable Object o) {
<span class="pc bpc" id="L1179" title="2 of 4 branches missed.">                if (o != null &amp;&amp; ValueSet.this.type().isAssignableFrom(o.getClass())) {</span>
<span class="fc" id="L1180">                    return ValueSet.this.contains(ValueSet.this.type().cast(o));</span>
                }
<span class="nc" id="L1182">                return false;</span>
            }
        };
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if any of them match the predicate,
     *  otherwise {@code false}. So if one or more elements match the predicate,
     *  then this method will always return {@code true}.
     *
     *  @param predicate The predicate to check.
     *  @return True if any of the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean any( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L1198">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1199">        return this.stream().anyMatch( predicate );</span>
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if all of them match the predicate,
     *  otherwise {@code false}. So if one or more elements do not match the predicate,
     *  then this method will always return {@code false}.
     *
     *  @param predicate The predicate to check.
     *  @return True if all the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean all( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L1213">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1214">        return this.stream().allMatch( predicate );</span>
    }

    /**
     *  Applies the supplied predicate lambda to all elements in this value set
     *  and returns {@code true} if none of them match the predicate,
     *  otherwise {@code false}. So if one or more elements match the predicate,
     *  then this method will always return {@code false}.
     *
     *  @param predicate The predicate to run over all elements.
     *  @return True if none of the elements in this value set match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean none( Predicate&lt;E&gt; predicate ) {
<span class="nc" id="L1228">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1229">        return this.stream().noneMatch( predicate );</span>
    }
    
    /**
     *  Returns a sequential {@link Stream} with this value set as its source.
     *
     * @return A sequential stream of the elements in this value set.
     */
    default Stream&lt;E&gt; stream() {
<span class="fc" id="L1238">        return StreamSupport.stream(spliterator(), false);</span>
    }

    /**
     *  Returns a parallel {@link Stream} with this value set as its source.
     *
     * @return A parallel stream of the elements in this value set.
     */
    default Stream&lt;E&gt; parallelStream() {
<span class="fc" id="L1247">        return StreamSupport.stream(spliterator(), true);</span>
    }

    /**
     *  Returns a new sorted value set with the elements in this value set,
     *  sorted according to the provided comparator.
     *  The type of the elements in the returned value set will be the same
     *  as the type of this value set.
     *
     * @param comparator The comparator to use for sorting the elements.
     * @return A new sorted value set with the elements in this value set.
     * @throws NullPointerException if the provided comparator is {@code null}.
     */
    default ValueSet&lt;E&gt; sort( Comparator&lt;E&gt; comparator ) {
<span class="fc" id="L1261">        Objects.requireNonNull(comparator, &quot;The provided comparator cannot be null.&quot;);</span>
<span class="fc" id="L1262">        return Sprouts.factory().valueSetOfSorted(type(), comparator).addAll(this);</span>
    }

    /**
     *  Converts this value set to a {@link Tuple} of all the elements in it,
     *  where the {@link Tuple#type()} is the same as the {@link #type()} of this value set.
     *  Note that the order of the elements in the tuple will not
     *  have any specific meaning, as the value set is an unordered collection.
     *
     * @return A {@link Tuple} of all the elements in this value set.
     */
    default Tuple&lt;E&gt; toTuple() {
<span class="fc" id="L1274">        return Tuple.of(type(), this);</span>
    }

    /**
     *  Returns a string consisting of the string representations of all elements
     *  in this value set, concatenated with the specified delimiter.
     *  The elements are converted to strings using {@link String#valueOf(Object)}
     *  and joined in the iteration order of this value set.&lt;br&gt;
     *
     *  &lt;b&gt;Examples:&lt;/b&gt;
     *  &lt;pre&gt;{@code
     *  var fruits = ValueSet.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;);
     *  String result1 = fruits.join(&quot;, &quot;);
     *  // Returns &quot;apple, banana, orange&quot;
     *
     *  ValueSet&lt;Integer&gt; numbers = ValueSet.of(1, 2, 3);
     *  String result2 = numbers.join(&quot;-&quot;); // Returns &quot;1-2-3&quot;
     *  }&lt;/pre&gt;&lt;br&gt;
     *
     *  &lt;b&gt;Order Considerations:&lt;/b&gt;
     *  &lt;ul&gt;
     *    &lt;li&gt;For regular value sets, the order is undefined but consistent&lt;/li&gt;
     *    &lt;li&gt;For linked value sets, elements are joined in insertion order&lt;/li&gt;
     *    &lt;li&gt;For sorted value sets, elements are joined in sorted order&lt;/li&gt;
     *  &lt;/ul&gt;&lt;br&gt;
     *
     *  &lt;b&gt;Empty Set:&lt;/b&gt;
     *  If this value set is empty, an empty string is returned.&lt;br&gt;
     *  &lt;br&gt;
     *  &lt;b&gt;Single Element:&lt;/b&gt;
     *  If this value set contains only one element, that element's string
     *  representation is returned without any delimiter.
     *
     * @param delimiter The delimiter to be used between each element.
     *                 Must not be null, but can be an empty string.
     * @return A string representation of this value set's elements
     *         joined by the specified delimiter.
     * @throws NullPointerException if the provided delimiter is {@code null}.
     */
    default String join( String delimiter ) {
<span class="fc" id="L1314">        return this.stream().map(String::valueOf).collect(Collectors.joining(delimiter));</span>
    }

    /**
     * Compares the specified object with this set for value equality.
     * Returns {@code true} if the specified object is also a value set with the
     * same {@link #size()}, {@link #type()}, and where every member of the specified
     * set is contained in this set (or equivalently, every member of this set is contained in the specified set).
     * Additionally, two sets must also report the same values for {@link #isLinked()} and {@link #isSorted()}.
     * So an unordered set is never equal to a sorted set, a linked set is never equal to a sorted set, etc...&lt;br&gt;
     * This definition ensures that the equals method works properly across
     * different implementations of the set interface.&lt;br&gt;
     *
     * @param o object to be compared for equality with this set
     * @return {@code true} if the specified object is equal to this set
     */
    @Override
    boolean equals( Object o );

    /**
     * Returns the hash code value for this set. The hash code of a set is
     * defined to be the sum of the hash codes of the elements in the set.
     * This ensures that {@code s1.equals(s2)} implies that
     * {@code s1.hashCode()==s2.hashCode()} for any two sets {@code s1}
     * and {@code s2}, as required by the general contract of
     * {@link Object#hashCode}.
     *
     * @return The hash code value for this set as a 32-bit integer,
     *         based on the sum of the hash codes of all elements in this set.
     * @see Object#equals(Object)
     * @see Set#equals(Object)
     */
    @Override
    int hashCode();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>