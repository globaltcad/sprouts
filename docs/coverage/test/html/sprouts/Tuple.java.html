<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tuple.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">Tuple.java</span></div><h1>Tuple.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.Nullable;
import sprouts.impl.Sprouts;
import sprouts.impl.SequenceDiff;
import sprouts.impl.TupleImpl;

import java.lang.reflect.Array;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * An immutable collection of ordered items of the same type {@code T} (see {@link #type()}),
 * whose items can be iterated over and accessed through their indices.&lt;br&gt;
 * This class can be thought of as an immutable array with an API designed for functional programming
 * and robust handling of {@code null} values.&lt;br&gt;
 * &lt;br&gt;
 * &lt;p&gt;
 * The name of this class is short for &quot;tuple&quot;. This name was deliberately chosen because
 * as a mathematical object, a tuple is not a place in memory where items are stored,
 * but a factual value object with a size and a sequence of items.&lt;br&gt;
 * So two {@link Tuple} instances with the same items and the same order are considered equal,
 * even if they are not the same object in memory.&lt;br&gt;
 * &lt;p&gt;
 * &lt;b&gt;Take a look at the &lt;a href=&quot;https://globaltcad.github.io/sprouts/&quot;&gt;living sprouts documentation&lt;/a&gt;
 * for a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *
 * @param &lt;T&gt; The type of the items in the immutable tuple.
 */
public interface Tuple&lt;T extends @Nullable Object&gt; extends Iterable&lt;T&gt;
{
    /**
     *  Creates a {@link Collector} that can be used
     *  to collect a stream of items into a new tuple of non-nullable items.
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var tuple = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map(String::toUpperCase)
     *                .collect(Tuple.collectorOf(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new tuple of strings with the items &quot;A&quot;, &quot;B&quot; and &quot;C&quot;.
     *  If there are null values in the stream, an exception will be thrown.
     *
     * @param type The common type of the items in the tuple to be created.
     * @return A collector that collects a stream of items into a new tuple of non-nullable items.
     * @param &lt;T&gt; The type of the items in the tuple.
     */
    static &lt;T&gt; Collector&lt;T, ?, Tuple&lt;T&gt;&gt; collectorOf( Class&lt;T&gt; type ) {
<span class="fc" id="L55">        return Collector.of(</span>
                (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L58">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">                list -&gt; list.isEmpty() ? Tuple.of(type) : Tuple.of(type, list)</span>
        );
    }

    /**
     *  Use this to collect a stream of items into a new tuple of nullable items.
     *  Here is an example of how to use this method:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var tuple = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map(String::toUpperCase)
     *                .collect(Tuple.collectorOfNullable(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new tuple of strings with the items &quot;A&quot;, &quot;B&quot; and &quot;C&quot;.
     *  Null values in the stream will not lead to an exception when using this collector.
     *
     * @param type The type of the items in the tuple.
     * @return A collector that collects a stream of items into a new tuple of nullable items.
     * @param &lt;T&gt; The type of the items in the tuple.
     */
    static &lt;T&gt; Collector&lt;T, ?, Tuple&lt;@Nullable T&gt;&gt; collectorOfNullable( Class&lt;T&gt; type ) {
<span class="fc" id="L79">        return Collector.of(</span>
                (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L82">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">                list -&gt; list.isEmpty() ? Tuple.ofNullable(type) : Tuple.ofNullable(type, list)</span>
        );
    }

    /**
     * Creates an immutable tuple of non-nullable items from the supplied type and vararg values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty vararg array.
     *
     * @param type the type of the items in the tuple.
     * @param vec the items to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException     if {@code type} is {@code null}, or {@code vec} is {@code null}.
     * @throws IllegalArgumentException if any {@link Maybe} allows {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type, Maybe&lt;T&gt;... vec ) {
<span class="fc" id="L101">        Objects.requireNonNull(type);</span>
<span class="fc" id="L102">        Objects.requireNonNull(vec);</span>
<span class="fc" id="L103">        return Sprouts.factory().tupleOf( type, vec );</span>
    }

    /**
     * Creates an empty tuple of non-nullable items from the supplied type.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty vararg array.
     *
     * @param type the type of the items in the tuple.
     *             This is used to check if the item is of the correct type.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException if {@code type} is {@code null}.
     */
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type ) {
<span class="fc" id="L118">        Objects.requireNonNull(type);</span>
<span class="fc" id="L119">        return Sprouts.factory().tupleOf( type );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from one or more non-nullable items
     * wrapped by {@link Maybe} properties.
     *
     * @param first the first {@link Maybe} to add to the new {@code Tuple} instance.
     * @param rest  the remaining items to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;   the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException     if {@code first} is {@code null}, or {@code rest} is {@code null}.
     * @throws IllegalArgumentException if any {@link Maybe} allows {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( Maybe&lt;T&gt; first, Maybe&lt;T&gt;... rest ) {
<span class="nc" id="L135">        Objects.requireNonNull(first);</span>
<span class="nc" id="L136">        Objects.requireNonNull(rest);</span>
<span class="nc" id="L137">        return Sprouts.factory().tupleOf( first, rest );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from one or more non-null items.
     * At least one non-null item must be provided to this factory method.
     *
     * @param first the first value to add to the new {@code Tuple} instance.
     * @param rest  the remaining values to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;   the type of the values.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException     if {@code first} is {@code null}, or {@code rest} is {@code null}.
     * @throws IllegalArgumentException if any value in {@code rest} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( T first, T... rest ) {
<span class="fc" id="L153">        Objects.requireNonNull(first);</span>
<span class="fc" id="L154">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L155">        return Sprouts.factory().tupleOf( first, rest );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from the supplied type and values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from the values.
     *
     * @param type  the type of the items in the tuple.
     * @param items the values to be wrapped by items and then added to the new {@code Tuple} instance.
     *              The values may not be null.
     * @param &lt;T&gt;   the type of the values.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException if {@code type} is {@code null}, or {@code items} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type, T... items ) {
<span class="fc" id="L172">        Objects.requireNonNull(type);</span>
<span class="fc" id="L173">        Objects.requireNonNull(items);</span>
<span class="fc" id="L174">        return Sprouts.factory().tupleOf( type, items );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from the supplied type and iterable of values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty iterable.
     *
     * @param type the type of the items in the tuple.
     * @param iterable the iterable of values.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException     if {@code type} is {@code null}, or {@code vec} is {@code null}.
     * @throws IllegalArgumentException if any {@link Maybe} in {@code vec} allows {@code null}.
     */
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type, Iterable&lt;T&gt; iterable ) {
<span class="fc" id="L190">        Objects.requireNonNull(type);</span>
<span class="fc" id="L191">        Objects.requireNonNull(iterable);</span>
<span class="fc" id="L192">        return Sprouts.factory().tupleOf( type, iterable );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied type and varargs items.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from the null values.
     *
     * @param type the type of the items in the tuple.
     * @param maybeItems the items to add to the new {@code Tuple} instance.
     *             The items may be nullable items, but they may not be null themselves.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException if {@code type} is {@code null}, or {@code vec} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, Maybe&lt;@Nullable T&gt;... maybeItems ) {
<span class="nc" id="L209">        Objects.requireNonNull(type);</span>
<span class="nc" id="L210">        Objects.requireNonNull(maybeItems);</span>
<span class="nc" id="L211">        return Sprouts.factory().tupleOfNullable( type, maybeItems );</span>
    }

    /**
     * Creates an empty tuple of nullable items from the supplied type.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty vararg array.
     *
     * @param type the type of the items in the tuple.
     *             This is used to check if the item is of the correct type.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     * @throws NullPointerException if {@code type} is {@code null}.
     */
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type ) {
<span class="fc" id="L226">        Objects.requireNonNull(type);</span>
<span class="fc" id="L227">        return Sprouts.factory().tupleOfNullable( type );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied type and values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from the null values.
     *
     * @param type   the type of the items in the tuple.
     * @param items The items to be stored by the new {@code Tuple} instance.
     *               The values may be null.
     * @param &lt;T&gt;    the type of the values.
     * @return a new {@code Vec} instance.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, @Nullable T... items ) {
<span class="fc" id="L243">        Objects.requireNonNull(type);</span>
<span class="fc" id="L244">        return Sprouts.factory().tupleOfNullable( type, items );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied items.
     *
     * @param first the first {@link Maybe} to add to the new {@code Tuple} instance.
     * @param rest  the remaining items to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;   the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Maybe&lt;@Nullable T&gt; first, Maybe&lt;@Nullable T&gt;... rest ) {
<span class="nc" id="L257">        Objects.requireNonNull(first);</span>
<span class="nc" id="L258">        Objects.requireNonNull(rest);</span>
<span class="nc" id="L259">        return Sprouts.factory().tupleOfNullable( first, rest );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied type and iterable of values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty iterable.
     *
     * @param type the type of the items in the tuple.
     * @param iterable the iterable of values.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Vec} instance.
     */
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, Iterable&lt;@Nullable T&gt; iterable ) {
<span class="fc" id="L273">        Objects.requireNonNull(type);</span>
<span class="fc" id="L274">        return Sprouts.factory().tupleOfNullable( type, iterable );</span>
    }

    /**
     *  Exposes the common type of the items in this tuple.&lt;br&gt;
     *  The type of the items in this tuple is retrieved from the first {@link Maybe} in the tuple.
     *  See {@link Val#type()} for more information.&lt;br&gt;
     * @return The type of the items in the tuple.
     */
    Class&lt;T&gt; type();

    /**
     *  The boolean flag that indicates if the tuple of items is empty,
     *  which means that it has no items.
     *
     * @return True if the tuple of items is empty.
     */
<span class="fc bfc" id="L291" title="All 2 branches covered.">    default boolean isEmpty() { return size() == 0; }</span>

    /**
     *  The boolean flag that indicates if the tuple of items is not empty,
     *  which means that it has at least one {@link Maybe}.
     *  This is the opposite of {@link #isEmpty()}
     *  and it may also be expressed as &lt;code&gt;!isEmpty()&lt;/code&gt;.
     *
     * @return True if the tuple of items is not empty.
     */
<span class="fc bfc" id="L301" title="All 2 branches covered.">    default boolean isNotEmpty() { return !isEmpty(); }</span>

    /**
     *  Checks weather the supplied item is in this tuple of items.
     *  This is functionally equivalent to {@code indexOf(value) != -1}.
     *
     * @param value The value to search for.
     * @return True if any of the items of this tuple wraps the given value.
     */
    default boolean contains( @Nullable T value ) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        return indexOf(value) != -1;</span>
    }

    /**
     *  Use this to find the index of an item.
     *  If the item is not found, -1 will be returned and in case
     *  of the item having multiple occurrences, the index of the first occurrence will be returned.
     *
     * @param value The value to search for.
     * @return The index of the {@link Maybe} that wraps the given value, or -1 if not found.
     */
    default int indexOf( @Nullable T value )
    {
<span class="fc" id="L324">        int index = 0;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">            if ( Val.equals(v,value) )</span>
<span class="fc" id="L327">                return index;</span>
<span class="fc" id="L328">            index++;</span>
<span class="fc" id="L329">        }</span>
<span class="fc" id="L330">        return -1;</span>
    }

    /**
     *  Uses the item of the supplied {@link Maybe} to find the index of
     *  the item in this tuple of items.
     *  So if any of the items in this tuple wraps the same item as the given {@link Maybe},
     *  the index of that {@link Maybe} will be returned.
     *  Note that if there are multiple occurrences of the same item in this tuple,
     *  the index of the first occurrence will be returned.
     *
     * @param value The {@link Maybe} to search for in this tuple.
     * @return The index of the given {@link Maybe} in this tuple, or -1 if not found.
     */
    default int indexOf( Maybe&lt;T&gt; value ) {
<span class="fc" id="L345">        return indexOf(value.orElseNull());</span>
    }

    /**
     *  Check if the value of the supplied {@link Maybe} is wrapped by any of the items in this tuple.
     *  This is functionally equivalent to {@code indexOf({@link Maybe}) != -1}.
     *
     * @param value The value {@link Maybe} to search for.
     * @return True if the given {@link Maybe} is in this tuple.
     */
    default boolean contains( Maybe&lt;T&gt; value ) {
<span class="nc" id="L356">        return contains(value.orElseNull());</span>
    }

    /**
     *  Exposes the size of the tuple of items, which is the number of items in the tuple.
     *  This number may never be negative.
     * @return The number of items in the tuple, which may never be negative.
     */
    int size();

    /**
     *  Exposes the {@link Maybe} at the specified index.
     *  If the index is out of bounds, an {@link IndexOutOfBoundsException} will be thrown.
     *
     * @param index The index of the {@link Maybe} to get in the range from 0 to {@link #size()} - 1.
     * @return The {@link Maybe} at the specified index.
     * @throws IndexOutOfBoundsException if the index is negative, or greater than or equal to the size of the tuple.
     */
    T get( int index );

    /**
     *  Exposes the first item in the tuple of items.
     * @return The first item in the tuple.
     */
    default T first() {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L382">            throw new NoSuchElementException(&quot;There is no such item in the tuple. The tuple is empty.&quot;);</span>
<span class="fc" id="L383">        return get(0);</span>
    }

    /**
     *  Exposes the last item in the tuple of items.
     * @return The last item in the tuple.
     */
    default T last() {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L392">            throw new NoSuchElementException(&quot;There is no such item in the tuple. The tuple is empty.&quot;);</span>
<span class="nc" id="L393">        return get(size() - 1);</span>
    }

    /**
     *  Check if any of the items in this tuple match the given predicate.
     *  @param predicate The predicate to check.
     *  @return True if any of the items in this tuple of items match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean any( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L403">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L404">        return stream().anyMatch( predicate );</span>
    }

    /**
     *  Check if all the items in this tuple match the given predicate.
     *  @param predicate The predicate to check.
     *  @return True if all the items in this tuple of items match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean all( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L414">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L415">        return stream().allMatch( predicate );</span>
    }

    /**
     *  Check if none of the items in this tuple match the given predicate.
     *  @param predicate The predicate to check.
     *  @return True if none of the items in this tuple of items match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean none( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L425">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L426">        return stream().noneMatch( predicate );</span>
    }

    /**
     *  Check if any of the items in this tuple is null.
     *  @return True if any of the items in this tuple of items is null.
     */
    default boolean anyNull() {
<span class="fc" id="L434">        return any(Objects::isNull);</span>
    }

    /**
     * A tuple will only allow nullable items if it was constructed with a &quot;ofNullable(..)&quot; factory method.
     * Otherwise, it will throw an {@link IllegalArgumentException} when trying to set a {@code null} reference.
     * This flag cannot be changed after the tuple has been constructed!
     *
     * @return {@code true}, if this tuple can contain null, {@code false} otherwise.
     */
    boolean allowsNull();

    /**
     *  Creates a new tuple of items
     *  where the supplied item is appended to the end of the tuple.
     *
     * @param item The item to add at the end of the new tuple.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; add( T item ) {
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">        if (allowsNull())</span>
<span class="nc" id="L456">            return add(Maybe.ofNullable(type(), item));</span>
<span class="fc" id="L457">        Objects.requireNonNull(item);</span>
<span class="fc" id="L458">        return add(Maybe.of(item));</span>
    }

    /**
     *  Adds the supplied item to the new tuple, if and only if the item is not null.
     *  If the item is null, the returned tuple remains unchanged.
     *
     * @param item The non-null item to add or {@code null} if the item should not be added.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; addIfNonNull( @Nullable T item ) {
<span class="fc bfc" id="L469" title="All 2 branches covered.">        return ( item == null ? this : add(item) );</span>
    }

    /**
     * Creates and returns a new tuple with the item of the supplied {@link Maybe}
     * appended to the end of the tuple of items. If this tuple does not allow null,
     * and the {@link Maybe} is empty, the tuple will remain unchanged.
     *
     * @param item the {@link Maybe} whose item to add.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and the {@link Maybe} does not allow {@code null}.
     * @throws NullPointerException     if the {@code var} is {@code null}.
     */
    default Tuple&lt;T&gt; add( Maybe&lt;T&gt; item ) {
<span class="fc" id="L483">        Objects.requireNonNull(item);</span>
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; item.isEmpty() )</span>
<span class="fc" id="L485">            return this;</span>
<span class="fc" id="L486">        return addAt( size(), item );</span>
    }

    /**
     * Removes the item at the specified index.
     *
     * @param index The index of the item to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                   size of this {@code Vec} object.
     */
    default Tuple&lt;T&gt; removeAt( int index ) {
<span class="fc" id="L498">        return removeRange(index, index + 1);</span>
    }

    /**
     * Removes the sequence of items at the specified index.
     *
     * @param index the index of the sequence to remove.
     * @param size  the size of the sequence to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of this {@code Vec}
     *                                   object.
     */
    default Tuple&lt;T&gt; removeAt( int index, int size ) {
<span class="fc" id="L512">        return removeRange( index, index + size );</span>
    }

    /**
     *  Returns the sequence of items at the specified index
     *  with the specified size in a new tuple.
     *
     * @param index the index of the sequence to slice away into a new tuple.
     * @param size  the size of the slice to remove and return.
     * @return The removed tuple of items.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of this {@code Vec}
     *                                   object.
     */
    default Tuple&lt;T&gt; sliceAt( int index, int size ) {
<span class="fc" id="L527">        return slice( index, index + size );</span>
    }

    /**
     * Returns a new tuple of items consisting of the items in the
     * range {@code from} inclusive and {@code to} exclusive.
     *
     * @param from the start index, inclusive.
     * @param to   the end index, exclusive.
     * @return The removed tuple of items.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Vec} object, or {@code from} is greater than {@code to}.
     */
    Tuple&lt;T&gt; slice( int from, int to );

    /**
     *  Removes every occurrence of the supplied item from the tuple.
     * @param item The item to remove from the entire tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; remove( T item ) {
<span class="fc" id="L548">        Tuple&lt;T&gt; result = this;</span>
<span class="fc" id="L549">        int index = result.indexOf(item);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        while ( index &gt;= 0 ) {</span>
<span class="fc" id="L551">            result = result.removeAt(index);</span>
<span class="fc" id="L552">            index = result.indexOf(item);</span>
        }
<span class="fc" id="L554">        return result;</span>
    }

    /**
     *  Removes every occurrence of the supplied item from the tuple,
     *  or does nothing if the supplied item is {@code null}.
     * @param item The item to remove from the entire tuple, 
     *             or {@code null} to indicate that nothing should be removed.
     * @return A new tuple of items with the desired change,
     *          and if the item is {@code null}, this tuple is returned unchanged.
     */
    default Tuple&lt;T&gt; removeIfNonNull( @Nullable T item ) {
<span class="fc bfc" id="L566" title="All 2 branches covered.">        return ( item == null ? this : remove(item) );</span>
    }

    /**
     *  Removes every occurrence of the item of the supplied
     *  {@link Maybe} from the tuple.
     *  If this tuple does not allow null, and the {@link Maybe} is empty,
     *  the new tuple will remain unchanged.
     *
     * @param item The item to remove from the entire tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; remove( Maybe&lt;T&gt; item ) {
<span class="pc bpc" id="L579" title="2 of 4 branches missed.">        if ( !this.allowsNull() &amp;&amp; item.isEmpty() )</span>
<span class="nc" id="L580">            return this;</span>
<span class="fc" id="L581">        Tuple&lt;T&gt; result = this;</span>
<span class="fc" id="L582">        int index = result.indexOf(item);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">        while ( index &gt;= 0 ) {</span>
<span class="fc" id="L584">            result = result.removeAt(index);</span>
<span class="fc" id="L585">            index = result.indexOf(item);</span>
        }
<span class="fc" id="L587">        return result;</span>
    }

    /**
     *  Removes the first found item in the tuple that
     *  is {@link Objects#equals(Object, Object)} to the supplied item.
     *
     * @param item the value to remove.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeFirstFound( T item ) {
<span class="fc" id="L598">        int index = indexOf(item);</span>
<span class="pc bpc" id="L599" title="1 of 2 branches missed.">        return index &lt; 0 ? this : removeRange( index, index + 1 );</span>
    }
    
    /**
     *  Removes the first found item in the tuple that
     *  is {@link Objects#equals(Object, Object)} to the supplied item,
     *  or does nothing if the item is {@code null}.
     *
     * @param item The object to remove at its first occurrence in the tuple.
     * @return A new tuple of items without the first occurrence of the item,
     *         or the same tuple if the item is {@code null}.
     */
    default Tuple&lt;T&gt; removeFirstFoundIfNonNull( @Nullable T item ) {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        return ( item == null ? this : removeFirstFound(item) );</span>
    }

    /**
     * Removes the tem of the provided {@link Maybe} from the tuple.
     * If the item is not found, the tuple is unchanged.
     * If this tuple does not allow null, and the {@link Maybe} is empty,
     * the new tuple will remain unchanged.
     *
     * @param maybeItem the potential to remove.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code maybeItem} is {@code null}.
     */
    default Tuple&lt;T&gt; removeFirstFound( Maybe&lt;T&gt; maybeItem ) {
<span class="nc" id="L626">        Objects.requireNonNull(maybeItem);</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="nc" id="L628">            return this;</span>
<span class="nc" id="L629">        int index = indexOf(maybeItem);</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">        return index &lt; 0 ? this : removeRange( index, index + 1 );</span>
    }

    /**
     * Removes the first found item in the tuple that is {@link Objects#equals(Object, Object)}
     * to the supplied item, or throws a {@link NoSuchElementException} if the item is not found.
     *
     * @param item The item to remove from its first occurrence in the tuple.
     * @return A new tuple of items with the desired change.
     * @throws NoSuchElementException if the value is not found.
     */
    default Tuple&lt;T&gt; removeFirstFoundOrThrow( T item ) {
<span class="fc" id="L642">        int index = indexOf(item);</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        if ( index &lt; 0 )</span>
<span class="fc" id="L644">            throw new NoSuchElementException(&quot;No such element: &quot; + item);</span>
<span class="fc" id="L645">        return removeRange( index, index + 1 );</span>
    }

    /**
     * Removes the item of the provided {@link Maybe} from the tuple.
     * If the item is not found, a {@link NoSuchElementException} is thrown.
     *
     * @param item the potential item to remove.
     * @return A new tuple of items with the desired change.
     * @throws NoSuchElementException if the item is not found.
     * @throws NullPointerException  if the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; removeFirstFoundOrThrow( Maybe&lt;T&gt; item ) {
<span class="fc" id="L658">        Objects.requireNonNull(item);</span>
<span class="fc" id="L659">        int index = indexOf(item);</span>
<span class="fc bfc" id="L660" title="All 2 branches covered.">        if ( index &lt; 0 )</span>
<span class="fc" id="L661">            throw new NoSuchElementException(&quot;No such element: &quot; + item);</span>
<span class="fc" id="L662">        return removeRange( index, index + 1 );</span>
    }

    /**
     * Removes the first item from the tuple,
     * or does nothing if the tuple is empty.
     *
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeFirst() {
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        return size() &gt; 0 ? removeRange( 0, 1 ) : this;</span>
    }

    /**
     * Removes the last item from the tuple,
     * or does nothing if the tuple is empty.
     *
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeLast() {
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">        return size() &gt; 0 ? removeRange( size() - 1, size() ) : this;</span>
    }

    /**
     * Remove all elements within the range {@code from} inclusive and {@code to} exclusive.
     *
     * @param from the start index, inclusive.
     * @param to   the end index, exclusive.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Vec} object, or {@code from} is greater than {@code to}.
     */
    Tuple&lt;T&gt; removeRange( int from, int to );

    /**
     * Removes {@code count} number of items from the end of the tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be removed.
     *
     * @param count the number of items to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; removeLast( int count ) {
<span class="nc" id="L706">        return removeRange(size() - count, size());</span>
    }

    /**
     * Removes {@code count} number of items from the end of the tuple and returns them in a new tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be popped.
     *
     * @param count the number of items to remove.
     * @return a new tuple of items.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; sliceLast( int count ) {
<span class="fc" id="L719">        return slice(size() - count, size());</span>
    }

    /**
     * Removes the first {@code count} number of items from the tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be removed.
     *
     * @param count the number of items to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; removeFirst( int count ) {
<span class="nc" id="L732">        return removeRange(0, count);</span>
    }

    /**
     * Removes the first {@code count} number of items from the tuple and returns them in a new tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be popped.
     *
     * @param count the number of items to remove.
     * @return a new tuple of items.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; sliceFirst( int count ) {
<span class="fc" id="L745">        return slice(0, count);</span>
    }

    /**
     * Removes all items from the tuple for which the provided predicate
     * returns true.
     *
     * @param predicate the predicate to test each item.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeIf( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L756">        List&lt;T&gt; itemsToKeep = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        int singleSequenceIndex = size() &gt; 0 ? -2 : -1;</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="fc" id="L759">            T item = get(i);</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">            if ( !predicate.test(item) ) {</span>
<span class="fc" id="L761">                itemsToKeep.add(item);</span>
            } else {
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                if ( singleSequenceIndex != -1 ) {</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">                    if ( singleSequenceIndex == -2 )</span>
<span class="fc" id="L765">                        singleSequenceIndex = i;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">                    else if ( i &gt; singleSequenceIndex + itemsToKeep.size() )</span>
<span class="fc" id="L767">                        singleSequenceIndex = -1;</span>
                }
            }
        }
<span class="fc" id="L771">        T[] newItems = (T[]) Array.newInstance(type(), itemsToKeep.size());</span>
<span class="fc" id="L772">        itemsToKeep.toArray(newItems);</span>
<span class="fc" id="L773">        return new TupleImpl&lt;&gt;(allowsNull(), type(), newItems, SequenceDiff.of(this, SequenceChange.REMOVE, singleSequenceIndex, size() - newItems.length));</span>
    }

    /**
     *  Creates a new tuple of items where only 
     *  the items that match the predicate are retained.
     *  You can think of this as the opposite of {@link #removeIf(Predicate)},
     *  or the {@code filter} operation in a functional {@code Stream}.
     *
     * @param predicate the predicate to test each item.
     * @return a new tuple of items.
     */
    default Tuple&lt;T&gt; retainIf( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L786">        List&lt;T&gt; filteredItems = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">        int singleSequenceIndex = size() &gt; 0 ? -2 : -1;</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="fc" id="L789">            T item = get(i);</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">            if ( predicate.test(item) ) {</span>
<span class="fc" id="L791">                filteredItems.add(item);</span>
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">                if ( singleSequenceIndex != -1 ) {</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">                    if ( singleSequenceIndex == -2 )</span>
<span class="fc" id="L794">                        singleSequenceIndex = i;</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">                    else if ( i &gt; singleSequenceIndex + filteredItems.size() )</span>
<span class="fc" id="L796">                        singleSequenceIndex = -1;</span>
                }
            }
        }
<span class="fc" id="L800">        T[] newItems = (T[]) Array.newInstance(type(), filteredItems.size());</span>
<span class="fc" id="L801">        filteredItems.toArray(newItems);</span>
<span class="fc" id="L802">        return new TupleImpl&lt;&gt;(allowsNull(), type(), newItems, SequenceDiff.of(this, SequenceChange.RETAIN, singleSequenceIndex, newItems.length));</span>
    }

    /**
     * Creates a new tuple of items without the items of the provided
     * tuple of items. This is also true for duplicate items.
     *
     * @param items the tuple of items to have removed in the new tuple.
     * @return A new tuple of items with the desired change.
     */
    Tuple&lt;T&gt; removeAll( Tuple&lt;T&gt; items );

    /**
     *  Removes all the items of the provided array from the tuple.
     *  This is also true for duplicate items.
     *
     * @param items the tuple of items to have removed in the new tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeAll( T... items ) {
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        return removeAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Removes all the items of the provided iterable from the tuple.
     *  This is also true for duplicate items.
     *
     * @param items the tuple of items to have removed in the new tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeAll( Iterable&lt;T&gt; items ) {
<span class="fc" id="L833">        return removeAll( Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates an updated tuple of items where the supplied
     *  item is inserted at the specified index.
     *
     * @param index the index at which to add the item.
     * @param item  the thing to add as an item.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    Tuple&lt;T&gt; addAt( int index, T item );

    /**
     *  Creates a new tuple of items where the supplied item is inserted at
     *  the specified index if, and only if, the item is not null.
     *
     * @param index The index at which to add the item if it is not null.
     * @param item The non-null item to add or {@code null} if the item should not be added.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; addIfNonNullAt( int index, @Nullable T item ) {
<span class="fc bfc" id="L856" title="All 2 branches covered.">        return ( item == null ? this : addAt(index, item) );</span>
    }

    /**
     * Creates a tuple where the item of the supplied {@link Maybe}
     * is inserted to the tuple at the specified index.
     * If this tuple does not allow null, and the {@link Maybe} is empty,
     * the new tuple will remain unchanged. If on the other hand,
     * {@code null} is allowed, and the {@link Maybe} is empty,
     * {@code null} will be appended.
     *
     * @param index The index at which to add the potential item.
     * @param maybeItem The property to add.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; addAt( int index, Maybe&lt;T&gt; maybeItem ) {
<span class="fc" id="L873">        Objects.requireNonNull(maybeItem);</span>
<span class="pc bpc" id="L874" title="2 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="nc" id="L875">            return this;</span>

<span class="fc" id="L877">        T newItem = Util.fakeNonNull(maybeItem.orElseNull());</span>
<span class="fc" id="L878">        return addAt(index, newItem);</span>
    }

    /**
     *  Creates a new tuple of items where the item at the specified index
     *  is replaced with the supplied item.
     *
     * @param index The index of the item to replace.
     * @param item  The item to replace the existing item with.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException      if {@code null} is not allowed and the {@code item} is {@code null}.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                   size of this {@code Vec} object.
     */
    Tuple&lt;T&gt; setAt( int index, T item );

    /**
     *  Creates a new tuple of items where the items starting at the specified index
     *  and ending at the specified index plus the size of the sequence are replaced
     *  with the supplied item.
     *
     * @param index the index of the sequence to set the items.
     * @param size  the size of the sequence to set the items.
     * @param item  the value to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of
     *                                   this {@code Vec} object.
     * @throws NullPointerException      if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; setAt( int index, int size, T item ) {
<span class="nc" id="L909">        return setRange( index, index + size, item );</span>
    }

    /**
     * Places the item of the supplied {@link Maybe} at the specified index,
     * effectively replacing the existing item at that index.
     * If this tuple does not allow null, and the property is empty,
     * the new tuple will remain unchanged. If on the other hand,
     * {@code null} is allowed, and the property is empty,
     * {@code null} will be set.
     *
     * @param index The index at which to set the property.
     * @param maybeItem The property to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                   size of this {@code Vec} object.
     * @throws IllegalArgumentException  if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; setAt( int index, Maybe&lt;T&gt; maybeItem ) {
<span class="fc" id="L928">        Objects.requireNonNull(maybeItem);</span>
<span class="pc bpc" id="L929" title="2 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="fc" id="L930">            return this;</span>

<span class="nc" id="L932">        T newItem = Util.fakeNonNull(maybeItem.orElseNull());</span>
<span class="nc" id="L933">        return setAt(index, newItem);</span>
    }

    /**
     * Places the provided property in the specified sequence, effectively replacing the items at the specified
     * sequence with the given property.
     * &lt;p&gt;
     * Note: The provided property will be placed in the provided sequence.
     * This will cause the same property to be placed multiple times in the tuple.
     *
     * @param index the index of the sequence to set the property.
     * @param size  the size of the sequence to set the property.
     * @param value the property to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of
     *                                   this {@code Vec} object.
     * @throws IllegalArgumentException  if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; setAt( int index, int size, Maybe&lt;T&gt; value ) {
<span class="fc" id="L953">        return setRange(index, index + size, value);</span>
    }

    /**
     * Wraps the specified value in distinct items and sets them in the specified range,
     * effectively replacing the items in the specified range.
     *
     * @param from  the start index, inclusive.
     * @param to    the end index, exclusive.
     * @param value the value to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Vec} object, or {@code from} is greater than {@code to}.
     * @throws NullPointerException      if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; setRange( int from, int to, T value ) {
<span class="nc bnc" id="L969" title="All 6 branches missed.">        if ( from &lt; 0 || to &gt; size() || from &gt; to )</span>
<span class="nc" id="L970">            throw new IndexOutOfBoundsException(&quot;From: &quot; + from + &quot;, To: &quot; + to + &quot;, Size: &quot; + size());</span>

<span class="nc bnc" id="L972" title="All 2 branches missed.">        if ( !allowsNull() )</span>
<span class="nc" id="L973">            Objects.requireNonNull(value);</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">        if ( from == to )</span>
<span class="nc" id="L976">            return this;</span>

<span class="nc bnc" id="L978" title="All 2 branches missed.">        Tuple&lt;T&gt; toBeSet = (Tuple&lt;T&gt;) (allowsNull() ? Tuple.ofNullable(type()) : Tuple.of(type()));</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">        for ( int i = from; i &lt; to; i++ ) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            Maybe&lt;T&gt; newProperty = allowsNull() ? Maybe.ofNullable(type(), value) : Maybe.of(value);</span>
<span class="nc" id="L981">            toBeSet = toBeSet.add(newProperty);</span>
        }

<span class="nc" id="L984">        return setAllAt( from, toBeSet );</span>
    }

    /**
     * Places the provided property in the specified range, effectively replacing the items in the specified range
     * with the given property.
     * &lt;p&gt;
     * Note: The provided property will be placed in the provided range.
     * This will cause the same property to be placed multiple times in the tuple.
     *
     * @param from  the start index, inclusive.
     * @param to    the end index, exclusive.
     * @param maybeItem the value to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Tuple} object, or {@code from} is greater than {@code to}.
     * @throws IllegalArgumentException  if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; setRange( int from, int to, Maybe&lt;T&gt; maybeItem )  {
<span class="pc bpc" id="L1003" title="3 of 6 branches missed.">        if ( from &lt; 0 || to &gt; size() || from &gt; to )</span>
<span class="nc" id="L1004">            throw new IndexOutOfBoundsException(&quot;From: &quot; + from + &quot;, To: &quot; + to + &quot;, Size: &quot; + size());</span>

<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">        if ( from == to )</span>
<span class="nc" id="L1007">            return this;</span>

<span class="pc bpc" id="L1009" title="2 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="fc" id="L1010">            return this;</span>

<span class="nc" id="L1012">        Maybe&lt;T&gt;[] items = new Maybe[to - from];</span>
<span class="nc" id="L1013">        Arrays.fill(items, maybeItem);</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">        Tuple&lt;T&gt; toBeSet = (Tuple&lt;T&gt;) (allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
<span class="nc" id="L1016">        return setAllAt(from, toBeSet);</span>
    }

    /**
     * Wraps each provided item in a property and appends it to this
     * tuple of items.
     *
     * @param items The array of values to add as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Tuple&lt;T&gt; addAll( T... items ) {
<span class="fc bfc" id="L1029" title="All 2 branches covered.">        return addAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates and returns an updated tuple of items where the items of the provided
     *  {@link Maybe} are appended at the end of the new item sequence.
     *  If this tuple does not allow null, then only the items of the
     *  non-empty {@link Maybe} will be appended.
     *  So if all {@link Maybe} items are empty, the tuple will remain unchanged.
     *
     * @param items The {@link Maybe} of items to append.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; addAll( Maybe&lt;T&gt;... items ) {
<span class="fc" id="L1044">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        if ( !allowsNull() ) {</span>
<span class="fc" id="L1046">            List&lt;Maybe&lt;T&gt;&gt; onlyPresent = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">            for ( Maybe&lt;T&gt; item : items ) {</span>
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">                if ( item.isPresent() )</span>
<span class="nc" id="L1049">                    onlyPresent.add(item);</span>
            }
<span class="fc" id="L1051">            items = onlyPresent.toArray(new Maybe[0]);</span>
        }
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">        return addAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates and returns a new tuple from this one where the
     *  items of the supplied {@link Iterable} are appended
     *  at the end of the new item sequence.
     *
     * @param items The values to append to the new tuple.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; addAll( Iterable&lt;T&gt; items ) {
<span class="fc" id="L1066">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">        return addAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates a merged tuple of items where the
     *  first sequence is based on the items of this tuple
     *  and the second sequence is based on the items of the provided tuple.
     *  The items of the provided tuple are effectively appended
     *  at the end of the new item sequence.
     *
     * @param tuple The tuple of items to append to the new tuple.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and at least one
     *                                  property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; addAll( Tuple&lt;T&gt; tuple ) {
<span class="fc" id="L1083">        return addAllAt(size(), tuple);</span>
    }

    /**
     * Wraps each provided item in a property and adds them
     * to this tuple of items at the specified index.
     *
     * @param index The index at which to add the items.
     * @param items The array of values to add as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Tuple&lt;T&gt; addAllAt( int index, T... items ) {
<span class="pc bpc" id="L1097" title="1 of 2 branches missed.">        return addAllAt( index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates an updated tuple of items where the items of the provided
     *  {@link Maybe} are all inserted at the specified index.
     *  If this tuple does not allow null, then only the items of the
     *  non-empty {@link Maybe} will be inserted.
     *  So if all {@link Maybe} items are empty, the tuple will remain unchanged.
     *
     * @param index The index at which to add the items.
     * @param items The {@link Maybe} of items to add.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; addAllAt( int index, Maybe&lt;T&gt;... items ) {
<span class="fc" id="L1113">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">        if ( !allowsNull() ) {</span>
<span class="fc" id="L1115">            List&lt;Maybe&lt;T&gt;&gt; onlyPresent = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">            for ( Maybe&lt;T&gt; item : items ) {</span>
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">                if ( item.isPresent() )</span>
<span class="nc" id="L1118">                    onlyPresent.add(item);</span>
            }
<span class="fc" id="L1120">            items = onlyPresent.toArray(new Maybe[0]);</span>
        }
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">        return addAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Iterates over the supplied values, and adds
     * them to {@code this} tuple as items at the specified index.
     *
     * @param index The index at which to add the items.
     * @param items The values to add as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; addAllAt( int index, Iterable&lt;T&gt; items ) {
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">        return addAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Adds all items from the provided tuple of items to {@code this} tuple
     * at a specified index.
     *
     * @param index The index at which to add the items.
     * @param tuple The tuple of items to add.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and at least one
     *                                  property does not allow {@code null}.
     */
    Tuple&lt;T&gt; addAllAt( int index, Tuple&lt;T&gt; tuple );

    /**
     * Wraps each provided item in a property and
     * overwrites the existing items in this
     * tuple, starting at the specified index.
     *
     * @param index The index at which to replace the current items
     *              with new items created from the array of items.
     * @param items The array of values to set as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                  size of this {@code Vec} object.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Tuple&lt;T&gt; setAllAt( int index, T... items ) {
<span class="nc bnc" id="L1165" title="All 2 branches missed.">        return setAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     *  Creates an updated tuple of items where the items of the provided
     *  {@link Maybe} objects are replacing the items in this tuple,
     *  starting at the specified index.
     *  If this tuple does not allow null, then only the items of the
     *  non-empty {@link Maybe} will be inserted.
     *  So if all {@link Maybe} items are empty, the tuple will remain unchanged.
     *
     * @param index The index at which to add the items.
     * @param items The {@link Maybe} of items to add.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; setAllAt( int index, Maybe&lt;T&gt;... items ) {
<span class="fc" id="L1182">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">        if ( !allowsNull() ) {</span>
<span class="fc" id="L1184">            List&lt;Maybe&lt;T&gt;&gt; onlyPresent = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1185" title="All 2 branches covered.">            for ( Maybe&lt;T&gt; item : items ) {</span>
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">                if ( item.isPresent() )</span>
<span class="nc" id="L1187">                    onlyPresent.add(item);</span>
            }
<span class="fc" id="L1189">            items = onlyPresent.toArray(new Maybe[0]);</span>
        }
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">        return setAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Iterates over the supplied values, and sets
     * them in this tuple as items starting at the specified index.
     * This method will replace the items in the specified range.
     *
     * @param index The index at which to set the items.
     * @param items The values to set as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                  size of this {@code Vec} object.
     */
    default Tuple&lt;T&gt; setAllAt( int index, Iterable&lt;T&gt; items ) {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        return setAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Creates and returns a new tuple from this one where all items from the provided tuple of items,
     * are set starting at the specified index, effectively replacing the items in the specified range
     * of this tuple in the new tuple.
     *
     * @param index The index at which to set the items.
     * @param tuple The tuple of items to set.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and at least one
     *                                  property does not allow {@code null}.
     */
    Tuple&lt;T&gt; setAllAt( int index, Tuple&lt;T&gt; tuple );

    /**
     *  Retains only the items in this tuple that are contained in the provided tuple of items.
     *  This is also true for duplicate items.
     *
     * @param tuple The tuple of items to retain. All other items will be removed.
     * @return A new tuple of items with the desired change.
     */
    Tuple&lt;T&gt; retainAll( Tuple&lt;T&gt; tuple );

    /**
     * Removes all items from {@code this} tuple that are not contained in the provided iterable of items.
     *
     * @param items The iterable of items to retain. All other items will be removed.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; retainAll( Iterable&lt;T&gt; items ) {
<span class="pc bpc" id="L1239" title="1 of 2 branches missed.">        return retainAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     * Removes all items from {@code this} tuple whose items are not contained in the provided array of items.
     *
     * @param items The array of items, whose items to retain. All other items will be removed.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; retainAll( T... items ) {
<span class="pc bpc" id="L1249" title="1 of 2 branches missed.">        return retainAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     * Creates a new tuple of this one without any items but the same nullability (see {@link #allowsNull()}).
     * This is conceptually equivalent to calling {@link List#clear()},
     * but instead of returning {@code void}, it returns a new tuple with the desired change.
     * This instance remains completely unchanged.
     *
     * @return An empty tuple of items (which may remember internally that it was produced by a clear operation),
     *         with the same nullability as this tuple.
     */
    Tuple&lt;T&gt; clear();

    /**
     *  Returns a new tuple of items where each item is the result of applying the
     *  supplied mapper {@link Function} to the corresponding item in this tuple.
     *  The returned tuple has the same nullability as this tuple (see {@link #allowsNull()}).
     *
     * @return A new tuple where each item is the result of applying the
     *         supplied mapper function to the corresponding item in this tuple.
     * @throws NullPointerException if the mapper is {@code null}.
     */
    default Tuple&lt;T&gt; map( Function&lt;T,T&gt; mapper ) {
<span class="fc" id="L1273">        Objects.requireNonNull(mapper);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1275">        T[] mappedItems = (T[]) Array.newInstance(type(), size());</span>
<span class="fc" id="L1276">        int i = 0;</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc" id="L1278">            mappedItems[i++] = mapper.apply( v );</span>
<span class="fc" id="L1279">        }</span>
<span class="fc" id="L1280">        return new TupleImpl&lt;&gt;( allowsNull(), type(), mappedItems, SequenceDiff.of(this, SequenceChange.SET, 0, size()) );</span>
    }

    /**
     *  Returns a new tuple of items where each item is mapped to a new item
     *  of the specified type using the supplied mapper function.
     *  The returned tuple has the same nullability as this tuple (see {@link #allowsNull()}).
     *
     * @return A new tuple where each item is the result of applying the
     *        supplied mapper function to the corresponding item in this tuple.
     * @throws NullPointerException if the type or the mapper is {@code null}.
     */
    default &lt;U extends @Nullable Object&gt; Tuple&lt;U&gt; mapTo(
        Class&lt;U&gt;      type,
        Function&lt;T,U&gt; mapper
    ) {
<span class="fc" id="L1296">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1297">        Objects.requireNonNull(mapper);</span>
<span class="fc" id="L1298">        U[] array = (U[]) Array.newInstance(type, size());</span>
<span class="fc" id="L1299">        int i = 0;</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc" id="L1301">            U m = mapper.apply( v );</span>
<span class="fc" id="L1302">            array[i++] = m;</span>
<span class="fc" id="L1303">        }</span>
<span class="fc" id="L1304">        return new TupleImpl&lt;&gt;( allowsNull(), type, array, SequenceDiff.of(this, SequenceChange.SET, 0, size()) );</span>
    }

    /**
     *  Converts this tuple of items to a JDK {@link List} of items
     *  and then returns the resulting list.
     *  Note that the returned list is immutable.
     *
     * @return An immutable {@link List} of items in this {@link Tuple} instance.
     */
    default List&lt;T&gt; toList() {
<span class="fc" id="L1315">        return Collections.unmodifiableList(stream().collect(Collectors.toList()));</span>
    }

    /**
     *  Turns this tuple of items into a stream of items
     *  which can be used for further functional processing.
     *  Note that the returned stream is not parallel.
     *
     * @return A stream of the items in this tuple of items.
     */
    default Stream&lt;T&gt; stream() {
<span class="fc" id="L1326">        return StreamSupport.stream(spliterator(), false);</span>
    }

    /**
     * Use this for sorting the tuple of items.
     *
     * @param comparator The comparator to use for sorting.
     */
    Tuple&lt;T&gt; sort( Comparator&lt;T&gt; comparator );

    /**
     * Sorts the tuple of items using the natural ordering of the items.
     * Note that this method expected the wrapped values to be {@link Comparable}.
     *
     * @throws UnsupportedOperationException if the values are not {@link Comparable}.
     */
    default Tuple&lt;T&gt; sort() {
        // First we have to check if the type is comparable:
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (Comparable.class.isAssignableFrom(type())) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1346">            Comparator&lt;T&gt; comparator = (Comparator&lt;T&gt;) Comparator.naturalOrder();</span>
<span class="nc" id="L1347">            return sort(comparator);</span>
        } else {
<span class="nc" id="L1349">            throw new UnsupportedOperationException(&quot;Cannot sort an immutable tuple of non-comparable types.&quot;);</span>
        }
    }

    /**
     *  Returns a new tuple of unique items, meaning that all duplicates
     *  in the original tuple are absent in the returned tuple.
     *
     * @return A new tuple of items with all duplicates removed.
     */
    Tuple&lt;T&gt; makeDistinct();

    /**
     *  Returns a new tuple with the exact same items as this tuple,
     *  but in reverse order.
     *
     * @return A new tuple of items with the items in reverse order.
     */
    Tuple&lt;T&gt; reversed();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>