<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Tuple.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">Tuple.java</span></div><h1>Tuple.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.Nullable;
import sprouts.impl.*;

import java.lang.reflect.Array;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * An immutable collection of ordered items of the same type {@code T} (see {@link #type()}),
 * whose items can be iterated over and accessed through their indices.&lt;br&gt;
 * This class can be thought of as an immutable array with an API designed for functional programming
 * and robust handling of {@code null} values.&lt;br&gt;
 * &lt;br&gt;
 * &lt;p&gt;
 * The name of this class is short for &quot;tuple&quot;. This name was deliberately chosen because
 * as a mathematical object, a tuple is not a place in memory where items are stored,
 * but a sequence of raw pieces of information with value object semantics.&lt;br&gt;
 * So two {@link Tuple} instances with the same items and the same order are considered equal,
 * even if they are not the same object in memory.&lt;br&gt;
 * &lt;p&gt;
 * &lt;b&gt;Take a look at the &lt;a href=&quot;https://globaltcad.github.io/sprouts/&quot;&gt;living sprouts documentation&lt;/a&gt;
 * for a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *
 * @param &lt;T&gt; The type of the items in the immutable tuple.
 */
public interface Tuple&lt;T extends @Nullable Object&gt; extends Iterable&lt;T&gt;
{
    /**
     *  An alternative to {@code Tuple.class} which also includes the parameter
     *  type in the type signature of the returned tuple class.
     *  This is useful when you want to use tuple as items in collection
     *  types or in properties...
     *
     * @param itemType The item type {@code T} in the returned {@code Class&lt;Tuple&lt;T&gt;&gt;}.
     * @return The {@code Tuple.class} but with the parameter type included as {@code Class&lt;Tuple&lt;T&gt;&gt;}.
     * @param &lt;T&gt; The type of item in the tuple class parameter signature.
     * @throws NullPointerException If the supplied type parameter is null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Class&lt;Tuple&lt;T&gt;&gt; classTyped(Class&lt;T&gt; itemType) {
<span class="nc" id="L49">        Objects.requireNonNull(itemType);</span>
<span class="nc" id="L50">        return (Class) Tuple.class;</span>
    }

    /**
     *  Creates a {@link Collector} that can be used
     *  to collect a stream of items into a new tuple of non-nullable items.
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var tuple = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map(String::toUpperCase)
     *                .collect(Tuple.collectorOf(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new tuple of strings with the items &quot;A&quot;, &quot;B&quot; and &quot;C&quot;.
     *  If there are null values in the stream, an exception will be thrown.
     *  Use {@link #collectorOfNullable(Class)} if you want to allow nulls.
     *
     * @param type The common type of the items in the tuple to be created.
     * @return A collector that collects a stream of items into a new tuple of non-nullable items.
     * @param &lt;T&gt; The type of the items in the tuple.
     * @throws NullPointerException If the supplied type is null.
     */
    static &lt;T&gt; Collector&lt;T, ?, Tuple&lt;T&gt;&gt; collectorOf( Class&lt;T&gt; type ) {
<span class="fc" id="L72">        Objects.requireNonNull(type);</span>
<span class="fc" id="L73">        return Collector.of(</span>
                (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new,
                List::add,
<span class="fc" id="L76">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                list -&gt; list.isEmpty() ? Tuple.of(type) : Tuple.of(type, list)</span>
        );
    }

    /**
     *  Use this to collect a stream of items into a new tuple of nullable items.
     *  Here is an example of how to use this method:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var tuple = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map(String::toUpperCase)
     *                .collect(Tuple.collectorOfNullable(String.class));
     *  }&lt;/pre&gt;
     *  This will create a new tuple of strings with the items &quot;A&quot;, &quot;B&quot; and &quot;C&quot;.
     *  Null values in the stream will not lead to an exception when using this collector.
     *
     * @param type The type of the items in the tuple.
     * @return A collector that collects a stream of items into a new tuple of nullable items.
     * @param &lt;T&gt; The type of the items in the tuple.
     */
    static &lt;T&gt; Collector&lt;T, ?, Tuple&lt;@Nullable T&gt;&gt; collectorOfNullable( Class&lt;T&gt; type ) {
<span class="fc" id="L97">        return Collector.of(</span>
                (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L100">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">                list -&gt; list.isEmpty() ? Tuple.ofNullable(type) : Tuple.ofNullable(type, list)</span>
        );
    }

    /**
     * Creates an immutable tuple of non-nullable items from the supplied type and vararg values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty vararg array.
     *
     * @param type the type of the items in the tuple.
     * @param vec the items to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException     if {@code type} is {@code null}, or {@code vec} is {@code null}.
     * @throws IllegalArgumentException if any {@link Maybe} allows {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type, Maybe&lt;T&gt;... vec ) {
<span class="fc" id="L119">        Objects.requireNonNull(type);</span>
<span class="fc" id="L120">        Objects.requireNonNull(vec);</span>
<span class="fc" id="L121">        return Sprouts.factory().tupleOf( type, vec );</span>
    }

    /**
     * Creates an empty tuple of non-nullable items from the supplied type.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty vararg array.
     *
     * @param type the type of the items in the tuple.
     *             This is used to check if the item is of the correct type.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException if {@code type} is {@code null}.
     */
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type ) {
<span class="fc" id="L136">        Objects.requireNonNull(type);</span>
<span class="fc" id="L137">        return Sprouts.factory().tupleOf( type );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from one or more non-nullable items
     * wrapped by {@link Maybe} properties.
     *
     * @param first the first {@link Maybe} to add to the new {@code Tuple} instance.
     * @param rest  the remaining items to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;   the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException     if {@code first} is {@code null}, or {@code rest} is {@code null}.
     * @throws IllegalArgumentException if any {@link Maybe} allows {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( Maybe&lt;T&gt; first, Maybe&lt;T&gt;... rest ) {
<span class="nc" id="L153">        Objects.requireNonNull(first);</span>
<span class="nc" id="L154">        Objects.requireNonNull(rest);</span>
<span class="nc" id="L155">        return Sprouts.factory().tupleOf( first, rest );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from one or more non-null items.
     * At least one non-null item must be provided to this factory method.
     *
     * @param first the first value to add to the new {@code Tuple} instance.
     * @param rest  the remaining values to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;   the type of the values.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException     if {@code first} is {@code null}, or {@code rest} is {@code null}.
     * @throws IllegalArgumentException if any value in {@code rest} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( T first, T... rest ) {
<span class="fc" id="L171">        Objects.requireNonNull(first);</span>
<span class="fc" id="L172">        Objects.requireNonNull(rest);</span>
<span class="fc" id="L173">        return Sprouts.factory().tupleOf( first, rest );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from the supplied type and values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from the values.
     *
     * @param type  the type of the items in the tuple.
     * @param items the values to be wrapped by items and then added to the new {@code Tuple} instance.
     *              The values may not be null.
     * @param &lt;T&gt;   the type of the values.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException if {@code type} is {@code null}, or {@code items} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type, T... items ) {
<span class="fc" id="L190">        Objects.requireNonNull(type);</span>
<span class="fc" id="L191">        Objects.requireNonNull(items);</span>
<span class="fc" id="L192">        return Sprouts.factory().tupleOf( type, items );</span>
    }

    /**
     * Creates an immutable, non-nullable {@code Tuple&lt;Float&gt;} from a
     * primitive array of floats. The returned tuple will contain
     * the floats as a single dense array of primitives.&lt;br&gt;
     * Note that in order to guarantee immutability,
     * the array of floats is copied.
     *
     * @param floats The floats to use as a basis for the new tuple.
     * @return a new {@code Tuple} instance backed by a single primitive array of floats.
     * @throws NullPointerException if {@code floats} is {@code null}.
     */
    static Tuple&lt;Float&gt; of( float[] floats ) {
<span class="fc" id="L207">        Objects.requireNonNull(floats);</span>
<span class="fc" id="L208">        return Sprouts.factory().tupleOf( floats );</span>
    }

    /**
     * Creates an immutable, non-nullable {@code Tuple&lt;Double&gt;} from a
     * primitive array of doubles. The returned tuple will contain
     * the doubles as a single dense array of primitives.&lt;br&gt;
     * Note that in order to guarantee immutability,
     * the array of doubles is copied.
     *
     * @param doubles The doubles to use as a basis for the new tuple.
     * @return a new {@code Tuple} instance backed by a single primitive array of doubles.
     * @throws NullPointerException if {@code doubles} is {@code null}.
     */
    static Tuple&lt;Double&gt; of( double[] doubles ) {
<span class="fc" id="L223">        Objects.requireNonNull(doubles);</span>
<span class="fc" id="L224">        return Sprouts.factory().tupleOf( doubles );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from a primitive array of integers.
     * The returned tuple will contain the integers as a single dense array of primitives.&lt;br&gt;
     * Note that in order to guarantee immutability,
     * the array of integers is copied.
     *
     * @param ints The integers to use as a basis for the new tuple.
     * @return a new {@code Tuple} instance backed by a single primitive array of integers.
     * @throws NullPointerException if {@code ints} is {@code null}.
     */
    static Tuple&lt;Integer&gt; of( int[] ints ) {
<span class="fc" id="L238">        Objects.requireNonNull(ints);</span>
<span class="fc" id="L239">        return Sprouts.factory().tupleOf( ints );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from a primitive array of longs.
     * The returned tuple will contain the longs as a single dense array of primitives.&lt;br&gt;
     * Note that in order to guarantee immutability,
     * the array of longs is copied.
     *
     * @param longs The longs to use as a basis for the new tuple.
     * @return a new {@code Tuple} instance backed by a single primitive array of longs.
     * @throws NullPointerException if {@code longs} is {@code null}.
     */
    static Tuple&lt;Long&gt; of( long[] longs ) {
<span class="fc" id="L253">        Objects.requireNonNull(longs);</span>
<span class="fc" id="L254">        return Sprouts.factory().tupleOf( longs );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from a primitive array of bytes.
     * The returned tuple will contain the bytes as a single dense array of primitives.&lt;br&gt;
     * Note that in order to guarantee immutability,
     * the array of bytes is copied.
     *
     * @param bytes The bytes to use as a basis for the new tuple.
     * @return a new {@code Tuple} instance backed by a single primitive array of bytes.
     * @throws NullPointerException if {@code bytes} is {@code null}.
     */
    static Tuple&lt;Byte&gt; of( byte[] bytes ) {
<span class="fc" id="L268">        Objects.requireNonNull(bytes);</span>
<span class="fc" id="L269">        return Sprouts.factory().tupleOf( bytes );</span>
    }

    /**
     * Creates an immutable tuple of non-nullable items from the supplied type and iterable of values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty iterable.
     *
     * @param type the type of the items in the tuple.
     * @param iterable the iterable of values.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException     if {@code type} is {@code null}, or {@code vec} is {@code null}.
     * @throws IllegalArgumentException if any {@link Maybe} in {@code vec} allows {@code null}.
     */
    static &lt;T&gt; Tuple&lt;T&gt; of( Class&lt;T&gt; type, Iterable&lt;T&gt; iterable ) {
<span class="fc" id="L285">        Objects.requireNonNull(type);</span>
<span class="fc" id="L286">        Objects.requireNonNull(iterable);</span>
<span class="fc" id="L287">        return Sprouts.factory().tupleOf( type, iterable );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied type and varargs items.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from the null values.
     *
     * @param type the type of the items in the tuple.
     * @param maybeItems the items to add to the new {@code Tuple} instance.
     *             The items may be nullable items, but they may not be null themselves.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException if {@code type} is {@code null}, or {@code vec} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, Maybe&lt;@Nullable T&gt;... maybeItems ) {
<span class="nc" id="L304">        Objects.requireNonNull(type);</span>
<span class="nc" id="L305">        Objects.requireNonNull(maybeItems);</span>
<span class="nc" id="L306">        return Sprouts.factory().tupleOfNullable( type, maybeItems );</span>
    }

    /**
     * Creates an empty tuple of nullable items from the supplied type.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty vararg array.
     *
     * @param type the type of the items in the tuple.
     *             This is used to check if the item is of the correct type.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     * @throws NullPointerException if {@code type} is {@code null}.
     */
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type ) {
<span class="fc" id="L321">        Objects.requireNonNull(type);</span>
<span class="fc" id="L322">        return Sprouts.factory().tupleOfNullable( type );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied type and values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from the null values.
     *
     * @param type   the type of the items in the tuple.
     * @param items The items to be stored by the new {@code Tuple} instance.
     *               The values may be null.
     * @param &lt;T&gt;    the type of the values.
     * @return a new {@code Tuple} instance.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, @Nullable T... items ) {
<span class="fc" id="L338">        Objects.requireNonNull(type);</span>
<span class="fc" id="L339">        return Sprouts.factory().tupleOfNullable( type, items );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied items.
     *
     * @param first the first {@link Maybe} to add to the new {@code Tuple} instance.
     * @param rest  the remaining items to add to the new {@code Tuple} instance.
     * @param &lt;T&gt;   the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Maybe&lt;@Nullable T&gt; first, Maybe&lt;@Nullable T&gt;... rest ) {
<span class="nc" id="L352">        Objects.requireNonNull(first);</span>
<span class="nc" id="L353">        Objects.requireNonNull(rest);</span>
<span class="nc" id="L354">        return Sprouts.factory().tupleOfNullable( first, rest );</span>
    }

    /**
     * Creates an immutable tuple of nullable items from the supplied type and iterable of values.
     * This factory method requires the type to be specified, because the
     * compiler cannot infer the type from a potentially empty iterable.
     *
     * @param type the type of the items in the tuple.
     * @param iterable the iterable of values.
     * @param &lt;T&gt;  the type of the items in the tuple.
     * @return a new {@code Tuple} instance.
     */
    static &lt;T&gt; Tuple&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, Iterable&lt;@Nullable T&gt; iterable ) {
<span class="fc" id="L368">        Objects.requireNonNull(type);</span>
<span class="fc" id="L369">        Objects.requireNonNull(iterable);</span>
<span class="fc" id="L370">        return Sprouts.factory().tupleOfNullable( type, iterable );</span>
    }

    /**
     *  Exposes the common type of the items in this tuple.&lt;br&gt;
     *  The type of the items in this tuple is retrieved from the first {@link Maybe} in the tuple.
     *  See {@link Val#type()} for more information.&lt;br&gt;
     * @return The type of the items in the tuple.
     */
    Class&lt;T&gt; type();

    /**
     *  The boolean flag that indicates if the tuple of items is empty,
     *  which means that it has no items.
     *
     * @return True if the tuple of items is empty.
     */
<span class="fc bfc" id="L387" title="All 2 branches covered.">    default boolean isEmpty() { return size() == 0; }</span>

    /**
     *  The boolean flag that indicates if the tuple of items is not empty,
     *  which means that it has at least one {@link Maybe}.
     *  This is the opposite of {@link #isEmpty()}
     *  and it may also be expressed as &lt;code&gt;!isEmpty()&lt;/code&gt;.
     *
     * @return True if the tuple of items is not empty.
     */
<span class="fc bfc" id="L397" title="All 2 branches covered.">    default boolean isNotEmpty() { return !isEmpty(); }</span>

    /**
     *  Checks weather the supplied item is in this tuple of items.
     *  This is functionally equivalent to {@code indexOf(value) != -1}.
     *
     * @param value The value to search for.
     * @return True if any of the items of this tuple wraps the given value.
     */
    default boolean contains( @Nullable T value ) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        return firstIndexOf(value) != -1;</span>
    }

    /**
     *  Use this to find the first index of an item in the tuple sequence.
     *  If the item is not found, -1 will be returned and in case of the item
     *  having multiple occurrences, then only the index of the first
     *  occurrence will be returned.
     *
     * @param value The value to search for.
     * @return The index of the {@link Maybe} that wraps the given value, or -1 if not found.
     */
    default int firstIndexOf( @Nullable T value ) {
<span class="fc" id="L420">        return firstIndexStartingFrom(0, value);</span>
    }

    /**
     *  Use this to find the index of an item after a certain index.
     *  If the item is not found, -1 will be returned and in case
     *  of the item having multiple occurrences, the index of the first occurrence will be returned.
     *
     * @param index The index to start the search from.
     * @param value The value to search for.
     * @return The index of the {@link Maybe} that wraps the given value, or -1 if not found.
     * @throws IndexOutOfBoundsException if the index is negative.
     */
    default int firstIndexStartingFrom(int index, @Nullable T value ) {
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if ( index &lt; 0 )</span>
<span class="nc" id="L435">            throw new IndexOutOfBoundsException(&quot;The index is negative: &quot; + index);</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">        for ( int i = index; i &lt; size(); i++ ) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            if ( Val.equals(get(i), value) )</span>
<span class="fc" id="L438">                return i;</span>
        }
<span class="fc" id="L440">        return -1;</span>
    }

    /**
     *  Use this to find the last index of an item in the tuple sequence.
     *  If the item is not found, -1 will be returned and in case of the item
     *  having multiple occurrences, then only the index of the last
     *  occurrence will be returned.
     *
     * @param value The value to search for.
     * @return The index of the {@link Maybe} that wraps the given value, or -1 if not found.
     */
    default int lastIndexOf( @Nullable T value ) {
<span class="fc" id="L453">        return lastIndexBefore(size(), value);</span>
    }

    /**
     *  Use this to find the index of an item before a certain index.
     *  If the item is not found, -1 will be returned and in case
     *  of the item having multiple occurrences, the index of the last occurrence will be returned.
     *
     * @param index The index to start the search from.
     * @param value The value to search for.
     * @return The index of the {@link Maybe} that wraps the given value, or -1 if not found.
     * @throws IndexOutOfBoundsException if the index is negative.
     */
    default int lastIndexBefore( int index, @Nullable T value ) {
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">        if ( index &lt; 0 )</span>
<span class="nc" id="L468">            throw new IndexOutOfBoundsException(&quot;The index is negative: &quot; + index);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        for ( int i = index - 1; i &gt;= 0; i-- ) {</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if ( Val.equals(get(i), value) )</span>
<span class="fc" id="L471">                return i;</span>
        }
<span class="fc" id="L473">        return -1;</span>
    }

    /**
     *  Finds all indices of the given value in this tuple of items and
     *  returns them as an array of integers.
     *  If the value is not found, an empty array will be returned and
     *  if there are multiple occurrences of the same value, all indices will be returned.
     *
     * @param value The value to search for.
     * @return A tuple of integers representing the indices of the given value in this tuple.
     */
    default Tuple&lt;Integer&gt; indicesOf( T value ) {
<span class="fc" id="L486">        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="fc bfc" id="L488" title="All 2 branches covered.">            if ( Val.equals(get(i), value) )</span>
<span class="fc" id="L489">                indices.add(i);</span>
        }
<span class="fc" id="L491">        return indices.stream().collect(Tuple.collectorOf(Integer.class));</span>
    }

    /**
     *  Uses the item of the supplied {@link Maybe} to find the index of
     *  the item in this tuple of items.
     *  So if any of the items in this tuple wraps the same item as the given {@link Maybe},
     *  the index of that {@link Maybe} will be returned.
     *  Note that if there are multiple occurrences of the same item in this tuple,
     *  the index of the first occurrence will be returned.
     *
     * @param value The {@link Maybe} to search for in this tuple.
     * @return The index of the given {@link Maybe} in this tuple, or -1 if not found.
     */
    default int firstIndexOf( Maybe&lt;T&gt; value ) {
<span class="fc" id="L506">        return firstIndexOf(value.orElseNull());</span>
    }

    /**
     *  Check if the value of the supplied {@link Maybe} is wrapped by any of the items in this tuple.
     *  This is functionally equivalent to {@code indexOf(Maybe) != -1}.
     *
     * @param value The value {@link Maybe} to search for.
     * @return True if the given {@link Maybe} is in this tuple.
     */
    default boolean maybeContains( Maybe&lt;T&gt; value ) {
<span class="nc" id="L517">        return contains(value.orElseNull());</span>
    }

    /**
     *  Exposes the size of the tuple of items, which is the number of items in the tuple.
     *  This number may never be negative.
     * @return The number of items in the tuple, which may never be negative.
     */
    int size();

    /**
     *  Exposes the {@link Maybe} at the specified index.
     *  If the index is out of bounds, an {@link IndexOutOfBoundsException} will be thrown.
     *
     * @param index The index of the {@link Maybe} to get in the range from 0 to {@link #size()} - 1.
     * @return The {@link Maybe} at the specified index.
     * @throws IndexOutOfBoundsException if the index is negative, or greater than or equal to the size of the tuple.
     */
    T get( int index );

    /**
     *  Exposes the first item in the tuple of items.
     * @return The first item in the tuple.
     */
    default T first() {
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L543">            throw new NoSuchElementException(&quot;There is no such item in the tuple. The tuple is empty.&quot;);</span>
<span class="fc" id="L544">        return get(0);</span>
    }

    /**
     *  Exposes the last item in the tuple of items.
     * @return The last item in the tuple.
     */
    default T last() {
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if ( this.isEmpty() )</span>
<span class="nc" id="L553">            throw new NoSuchElementException(&quot;There is no such item in the tuple. The tuple is empty.&quot;);</span>
<span class="nc" id="L554">        return get(size() - 1);</span>
    }

    /**
     *  Check if any of the items in this tuple match the given predicate.
     *  @param predicate The predicate to check.
     *  @return True if any of the items in this tuple of items match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean any( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L564">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L565">        return stream().anyMatch( predicate );</span>
    }

    /**
     *  Check if all the items in this tuple match the given predicate.
     *  @param predicate The predicate to check.
     *  @return True if all the items in this tuple of items match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean all( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L575">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L576">        return stream().allMatch( predicate );</span>
    }

    /**
     *  Check if none of the items in this tuple match the given predicate.
     *  @param predicate The predicate to check.
     *  @return True if none of the items in this tuple of items match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean none( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L586">        Objects.requireNonNull(predicate);</span>
<span class="fc" id="L587">        return stream().noneMatch( predicate );</span>
    }

    /**
     *  Check if any of the items in this tuple is null.
     *  @return True if any of the items in this tuple of items is null.
     */
    default boolean anyNull() {
<span class="fc" id="L595">        return any(Objects::isNull);</span>
    }

    /**
     * A tuple will only allow nullable items if it was constructed with a &quot;ofNullable(..)&quot; factory method.
     * Otherwise, it will throw an {@link IllegalArgumentException} when trying to set a {@code null} reference.
     * This flag cannot be changed after the tuple has been constructed!
     *
     * @return {@code true}, if this tuple can contain null, {@code false} otherwise.
     */
    boolean allowsNull();

    /**
     *  Creates a new tuple of items
     *  where the supplied item is appended to the end of the tuple.
     *
     * @param item The item to add at the end of the new tuple.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; add( T item ) {
<span class="fc" id="L616">        return addAt( size(), item );</span>
    }

    /**
     *  Adds the supplied item to the new tuple, if and only if the item is not null.
     *  If the item is null, the returned tuple remains unchanged.
     *
     * @param item The non-null item to add or {@code null} if the item should not be added.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; addIfNonNull( @Nullable T item ) {
<span class="fc bfc" id="L627" title="All 2 branches covered.">        return ( item == null ? this : add(item) );</span>
    }

    /**
     * Creates and returns a new tuple with the item of the supplied {@link Maybe}
     * appended to the end of the tuple of items. If this tuple does not allow null,
     * and the {@link Maybe} is empty, the tuple will remain unchanged.
     *
     * @param item the {@link Maybe} whose item to add.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and the {@link Maybe} does not allow {@code null}.
     * @throws NullPointerException     if the {@code var} is {@code null}.
     */
    default Tuple&lt;T&gt; maybeAdd( Maybe&lt;T&gt; item ) {
<span class="fc" id="L641">        Objects.requireNonNull(item);</span>
<span class="pc bpc" id="L642" title="1 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; item.isEmpty() )</span>
<span class="fc" id="L643">            return this;</span>
<span class="fc" id="L644">        return maybeAddAt( size(), item );</span>
    }

    /**
     * Removes the item at the specified index.
     *
     * @param index The index of the item to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                   size of this {@code Vec} object.
     */
    default Tuple&lt;T&gt; removeAt( int index ) {
<span class="fc" id="L656">        return removeRange(index, index + 1);</span>
    }

    /**
     * Removes the sequence of items at the specified index.
     *
     * @param index the index of the sequence to remove.
     * @param size  the size of the sequence to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of this {@code Vec}
     *                                   object.
     */
    default Tuple&lt;T&gt; removeAt( int index, int size ) {
<span class="fc" id="L670">        return removeRange( index, index + size );</span>
    }

    /**
     *  Returns the sequence of items at the specified index
     *  with the specified size in a new tuple.
     *
     * @param index the index of the sequence to slice away into a new tuple.
     * @param size  the size of the slice to remove and return.
     * @return The removed tuple of items.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of this {@code Vec}
     *                                   object.
     */
    default Tuple&lt;T&gt; sliceAt( int index, int size ) {
<span class="fc" id="L685">        return slice( index, index + size );</span>
    }

    /**
     * Returns a new tuple of items consisting of the items in the
     * range {@code from} inclusive and {@code to} exclusive.
     *
     * @param from the start index, inclusive.
     * @param to   the end index, exclusive.
     * @return The removed tuple of items.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Vec} object, or {@code from} is greater than {@code to}.
     */
    Tuple&lt;T&gt; slice( int from, int to );

    /**
     *  Removes every occurrence of the supplied item from the tuple.
     * @param item The item to remove from the entire tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; remove( T item ) {
<span class="fc" id="L706">        Tuple&lt;T&gt; result = this;</span>
<span class="fc" id="L707">        int index = result.firstIndexOf(item);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        while ( index &gt;= 0 ) {</span>
<span class="fc" id="L709">            result = result.removeAt(index);</span>
<span class="fc" id="L710">            index = result.firstIndexOf(item);</span>
        }
<span class="fc" id="L712">        return result;</span>
    }

    /**
     *  Removes every occurrence of the supplied item from the tuple,
     *  or does nothing if the supplied item is {@code null}.
     * @param item The item to remove from the entire tuple, 
     *             or {@code null} to indicate that nothing should be removed.
     * @return A new tuple of items with the desired change,
     *          and if the item is {@code null}, this tuple is returned unchanged.
     */
    default Tuple&lt;T&gt; removeIfNonNull( @Nullable T item ) {
<span class="fc bfc" id="L724" title="All 2 branches covered.">        return ( item == null ? this : remove(item) );</span>
    }

    /**
     *  Removes every occurrence of the item of the supplied
     *  {@link Maybe} from the tuple.
     *  If this tuple does not allow null, and the {@link Maybe} is empty,
     *  the new tuple will remain unchanged.
     *
     * @param item The item to remove from the entire tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; maybeRemove( Maybe&lt;T&gt; item ) {
<span class="pc bpc" id="L737" title="2 of 4 branches missed.">        if ( !this.allowsNull() &amp;&amp; item.isEmpty() )</span>
<span class="nc" id="L738">            return this;</span>
<span class="fc" id="L739">        Tuple&lt;T&gt; result = this;</span>
<span class="fc" id="L740">        int index = result.firstIndexOf(item);</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">        while ( index &gt;= 0 ) {</span>
<span class="fc" id="L742">            result = result.removeAt(index);</span>
<span class="fc" id="L743">            index = result.firstIndexOf(item);</span>
        }
<span class="fc" id="L745">        return result;</span>
    }

    /**
     *  Removes the first found item in the tuple that
     *  is {@link Objects#equals(Object, Object)} to the supplied item.
     *
     * @param item the value to remove.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeFirstFound( T item ) {
<span class="fc" id="L756">        int index = firstIndexOf(item);</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        return index &lt; 0 ? this : removeRange( index, index + 1 );</span>
    }
    
    /**
     *  Removes the first found item in the tuple that
     *  is {@link Objects#equals(Object, Object)} to the supplied item,
     *  or does nothing if the item is {@code null}.
     *
     * @param item The object to remove at its first occurrence in the tuple.
     * @return A new tuple of items without the first occurrence of the item,
     *         or the same tuple if the item is {@code null}.
     */
    default Tuple&lt;T&gt; removeFirstFoundIfNonNull( @Nullable T item ) {
<span class="nc bnc" id="L770" title="All 2 branches missed.">        return ( item == null ? this : removeFirstFound(item) );</span>
    }

    /**
     * Removes the tem of the provided {@link Maybe} from the tuple.
     * If the item is not found, the tuple is unchanged.
     * If this tuple does not allow null, and the {@link Maybe} is empty,
     * the new tuple will remain unchanged.
     *
     * @param maybeItem the potential to remove.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code maybeItem} is {@code null}.
     */
    default Tuple&lt;T&gt; maybeRemoveFirstFound( Maybe&lt;T&gt; maybeItem ) {
<span class="nc" id="L784">        Objects.requireNonNull(maybeItem);</span>
<span class="nc bnc" id="L785" title="All 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="nc" id="L786">            return this;</span>
<span class="nc" id="L787">        int index = firstIndexOf(maybeItem);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">        return index &lt; 0 ? this : removeRange( index, index + 1 );</span>
    }

    /**
     * Removes the first found item in the tuple that is {@link Objects#equals(Object, Object)}
     * to the supplied item, or throws a {@link NoSuchElementException} if the item is not found.
     *
     * @param item The item to remove from its first occurrence in the tuple.
     * @return A new tuple of items with the desired change.
     * @throws NoSuchElementException if the value is not found.
     */
    default Tuple&lt;T&gt; removeFirstFoundOrThrow( T item ) {
<span class="fc" id="L800">        int index = firstIndexOf(item);</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">        if ( index &lt; 0 )</span>
<span class="fc" id="L802">            throw new NoSuchElementException(&quot;No such element: &quot; + item);</span>
<span class="fc" id="L803">        return removeRange( index, index + 1 );</span>
    }

    /**
     * Removes the item of the provided {@link Maybe} from the tuple.
     * If the item is not found, a {@link NoSuchElementException} is thrown.
     *
     * @param item the potential item to remove.
     * @return A new tuple of items with the desired change.
     * @throws NoSuchElementException if the item is not found.
     * @throws NullPointerException  if the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; maybeRemoveFirstFoundOrThrow( Maybe&lt;T&gt; item ) {
<span class="fc" id="L816">        Objects.requireNonNull(item);</span>
<span class="fc" id="L817">        int index = firstIndexOf(item);</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">        if ( index &lt; 0 )</span>
<span class="fc" id="L819">            throw new NoSuchElementException(&quot;No such element: &quot; + item);</span>
<span class="fc" id="L820">        return removeRange( index, index + 1 );</span>
    }

    /**
     * Removes the first item from the tuple,
     * or does nothing if the tuple is empty.
     *
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeFirst() {
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        return size() &gt; 0 ? removeRange( 0, 1 ) : this;</span>
    }

    /**
     * Removes the last item from the tuple,
     * or does nothing if the tuple is empty.
     *
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeLast() {
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        return size() &gt; 0 ? removeRange( size() - 1, size() ) : this;</span>
    }

    /**
     * Remove all elements within the range {@code from} inclusive and {@code to} exclusive.
     *
     * @param from the start index, inclusive.
     * @param to   the end index, exclusive.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Vec} object, or {@code from} is greater than {@code to}.
     */
    Tuple&lt;T&gt; removeRange( int from, int to );

    /**
     * Removes {@code count} number of items from the end of the tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be removed.
     *
     * @param count the number of items to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; removeLast( int count ) {
<span class="nc" id="L864">        return removeRange(size() - count, size());</span>
    }

    /**
     * Removes {@code count} number of items from the end of the tuple and returns them in a new tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be popped.
     *
     * @param count the number of items to remove.
     * @return a new tuple of items.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; sliceLast( int count ) {
<span class="fc" id="L877">        return slice(size() - count, size());</span>
    }

    /**
     * Removes the first {@code count} number of items from the tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be removed.
     *
     * @param count the number of items to remove.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; removeFirst( int count ) {
<span class="nc" id="L890">        return removeRange(0, count);</span>
    }

    /**
     * Removes the first {@code count} number of items from the tuple and returns them in a new tuple.
     * If {@code count} is greater than the size of the tuple, only all available items will be popped.
     *
     * @param count the number of items to remove.
     * @return a new tuple of items.
     * @throws IndexOutOfBoundsException if {@code count} is negative, or {@code count} is greater than the size of
     *                                   this {@code Vec} object.
     */
    default Tuple&lt;T&gt; sliceFirst( int count ) {
<span class="fc" id="L903">        return slice(0, count);</span>
    }

    /**
     * Removes all items from the tuple for which the provided predicate
     * returns true.
     *
     * @param predicate the predicate to test each item.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeIf( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L914">        List&lt;T&gt; itemsToKeep = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">        int singleSequenceIndex = size() &gt; 0 ? -2 : -1;</span>
<span class="fc" id="L916">        int removalSequenceSize = 0;</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="fc" id="L918">            T item = get(i);</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">            if ( !predicate.test(item) ) {</span>
<span class="fc" id="L920">                itemsToKeep.add(item);</span>
            } else {
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">                if ( singleSequenceIndex != -1 ) {</span>
<span class="fc bfc" id="L923" title="All 2 branches covered.">                    if ( singleSequenceIndex == -2 )</span>
<span class="fc" id="L924">                        singleSequenceIndex = i;</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">                    else if ( i &gt; singleSequenceIndex + removalSequenceSize )</span>
<span class="fc" id="L926">                        singleSequenceIndex = -1;</span>
                }
<span class="fc bfc" id="L928" title="All 2 branches covered.">                if ( singleSequenceIndex &gt;= 0 )</span>
<span class="fc" id="L929">                    removalSequenceSize++;</span>
            }
        }
<span class="fc bfc" id="L932" title="All 2 branches covered.">        if ( itemsToKeep.size() == this.size() )</span>
<span class="fc" id="L933">            return this;</span>
<span class="fc" id="L934">        T[] newItems = (T[]) Array.newInstance(type(), itemsToKeep.size());</span>
<span class="fc" id="L935">        itemsToKeep.toArray(newItems);</span>
<span class="fc" id="L936">        SequenceDiff diff = SequenceDiff.of(this, SequenceChange.REMOVE, singleSequenceIndex, size() - itemsToKeep.size());</span>
<span class="fc" id="L937">        return new TupleWithDiff&lt;&gt;(TupleTree.of( allowsNull(), type(), newItems), diff);</span>
    }

    /**
     *  Creates a new tuple of items where only 
     *  the items that match the predicate are retained.
     *  You can think of this as the opposite of {@link #removeIf(Predicate)},
     *  or the {@code filter} operation in a functional {@code Stream}.
     *
     * @param predicate the predicate to test each item.
     * @return a new tuple of items.
     */
    default Tuple&lt;T&gt; retainIf( Predicate&lt;T&gt; predicate ) {
<span class="fc" id="L950">        List&lt;T&gt; filteredItems = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">        int singleSequenceIndex = size() &gt; 0 ? -2 : -1;</span>
<span class="fc" id="L952">        int retainSequenceSize = 0;</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="fc" id="L954">            T item = get(i);</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">            if ( predicate.test(item) ) {</span>
<span class="fc" id="L956">                filteredItems.add(item);</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">                if ( singleSequenceIndex != -1 ) {</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">                    if ( singleSequenceIndex == -2 )</span>
<span class="fc" id="L959">                        singleSequenceIndex = i;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">                    else if ( i &gt; singleSequenceIndex + retainSequenceSize )</span>
<span class="fc" id="L961">                        singleSequenceIndex = -1;</span>
                }
<span class="fc bfc" id="L963" title="All 2 branches covered.">                if ( singleSequenceIndex &gt;= 0 )</span>
<span class="fc" id="L964">                    retainSequenceSize++;</span>
            }
        }
<span class="fc bfc" id="L967" title="All 2 branches covered.">        if ( filteredItems.size() == this.size() )</span>
<span class="fc" id="L968">            return this;</span>
<span class="fc" id="L969">        SequenceDiff diff = SequenceDiff.of(this, SequenceChange.RETAIN, singleSequenceIndex, filteredItems.size());</span>
<span class="fc" id="L970">        return new TupleWithDiff&lt;&gt;(TupleTree.of(allowsNull(), type(), filteredItems), diff);</span>
    }

    /**
     * Creates a new tuple of items without the items of the provided
     * tuple of items. This is also true for duplicate items.
     *
     * @param items the tuple of items to have removed in the new tuple.
     * @return A new tuple of items with the desired change.
     */
    Tuple&lt;T&gt; removeAll( Tuple&lt;T&gt; items );

    /**
     *  Removes all the items of the provided array from the tuple.
     *  This is also true for duplicate items.
     *
     * @param items the tuple of items to have removed in the new tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeAll( T... items ) {
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">        return removeAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Removes all the items of the provided iterable from the tuple.
     *  This is also true for duplicate items.
     *
     * @param items the tuple of items to have removed in the new tuple.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; removeAll( Iterable&lt;T&gt; items ) {
<span class="fc" id="L1001">        return removeAll( Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates an updated tuple of items where the supplied
     *  item is inserted at the specified index.
     *
     * @param index the index at which to add the item.
     * @param item  the thing to add as an item.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    Tuple&lt;T&gt; addAt( int index, T item );

    /**
     *  Creates a new tuple of items where the supplied item is inserted at
     *  the specified index if, and only if, the item is not null.
     *
     * @param index The index at which to add the item if it is not null.
     * @param item The non-null item to add or {@code null} if the item should not be added.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; addIfNonNullAt( int index, @Nullable T item ) {
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        return ( item == null ? this : addAt(index, item) );</span>
    }

    /**
     * Creates a tuple where the item of the supplied {@link Maybe}
     * is inserted to the tuple at the specified index.
     * If this tuple does not allow null, and the {@link Maybe} is empty,
     * the new tuple will remain unchanged. If on the other hand,
     * {@code null} is allowed, and the {@link Maybe} is empty,
     * {@code null} will be appended.
     *
     * @param index The index at which to add the potential item.
     * @param maybeItem The property to add.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; maybeAddAt( int index, Maybe&lt;T&gt; maybeItem ) {
<span class="fc" id="L1041">        Objects.requireNonNull(maybeItem);</span>
<span class="pc bpc" id="L1042" title="2 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="nc" id="L1043">            return this;</span>

<span class="fc" id="L1045">        T newItem = Util.fakeNonNull(maybeItem.orElseNull());</span>
<span class="fc" id="L1046">        return addAt(index, newItem);</span>
    }

    /**
     *  Creates a new tuple of items where the item at the specified index
     *  is replaced with the supplied item.
     *
     * @param index The index of the item to replace.
     * @param item  The item to replace the existing item with.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException      if {@code null} is not allowed and the {@code item} is {@code null}.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                   size of this {@code Vec} object.
     */
    Tuple&lt;T&gt; setAt( int index, T item );

    /**
     *  Creates a new tuple of items where the items starting at the specified index
     *  and ending at the specified index plus the size of the sequence are replaced
     *  with the supplied item.
     *
     * @param index the index of the sequence to set the items.
     * @param size  the size of the sequence to set the items.
     * @param item  the value to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of
     *                                   this {@code Vec} object.
     * @throws NullPointerException      if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; setAt( int index, int size, T item ) {
<span class="fc" id="L1077">        return setRange( index, index + size, item );</span>
    }

    /**
     * Places the item of the supplied {@link Maybe} at the specified index,
     * effectively replacing the existing item at that index.
     * If this tuple does not allow null, and the property is empty,
     * the new tuple will remain unchanged. If on the other hand,
     * {@code null} is allowed, and the property is empty,
     * {@code null} will be set.
     *
     * @param index The index at which to set the property.
     * @param maybeItem The property to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                   size of this {@code Vec} object.
     * @throws IllegalArgumentException  if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; maybeSetAt( int index, Maybe&lt;T&gt; maybeItem ) {
<span class="fc" id="L1096">        Objects.requireNonNull(maybeItem);</span>
<span class="pc bpc" id="L1097" title="1 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="fc" id="L1098">            return this;</span>

<span class="fc" id="L1100">        T newItem = Util.fakeNonNull(maybeItem.orElseNull());</span>
<span class="fc" id="L1101">        return setAt(index, newItem);</span>
    }

    /**
     * Places the provided property in the specified sequence, effectively replacing the items at the specified
     * sequence with the given property.
     * &lt;p&gt;
     * Note: The provided property will be placed in the provided sequence.
     * This will cause the same property to be placed multiple times in the tuple.
     *
     * @param index the index of the sequence to set the property.
     * @param size  the size of the sequence to set the property.
     * @param value the property to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code size} is negative,
     *                                   or {@code index} + {@code size} is greater than the size of
     *                                   this {@code Vec} object.
     * @throws IllegalArgumentException  if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; maybeSetAt( int index, int size, Maybe&lt;T&gt; value ) {
<span class="fc" id="L1121">        return maybeSetRange(index, index + size, value);</span>
    }

    /**
     * Wraps the specified value in distinct items and sets them in the specified range,
     * effectively replacing the items in the specified range.
     *
     * @param from  the start index, inclusive.
     * @param to    the end index, exclusive.
     * @param value the value to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Vec} object, or {@code from} is greater than {@code to}.
     * @throws NullPointerException      if {@code null} is not allowed and the {@code item} is {@code null}.
     */
    default Tuple&lt;T&gt; setRange( int from, int to, T value ) {
<span class="pc bpc" id="L1137" title="3 of 6 branches missed.">        if ( from &lt; 0 || to &gt; size() || from &gt; to )</span>
<span class="nc" id="L1138">            throw new IndexOutOfBoundsException(&quot;From: &quot; + from + &quot;, To: &quot; + to + &quot;, Size: &quot; + size());</span>

<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">        if ( !allowsNull() )</span>
<span class="fc" id="L1141">            Objects.requireNonNull(value);</span>

<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">        if ( from == to )</span>
<span class="nc" id="L1144">            return this;</span>

<span class="fc" id="L1146">        T[] toBeSet = (T[]) Array.newInstance(type(), to - from);</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">        for ( int i = from; i &lt; to; i++ ) {</span>
<span class="fc" id="L1148">            toBeSet[i - from] = value;</span>
        }

<span class="fc" id="L1151">        return setAllAt( from, toBeSet );</span>
    }

    /**
     * Places the provided property in the specified range, effectively replacing the items in the specified range
     * with the given property.
     * &lt;p&gt;
     * Note: The provided property will be placed in the provided range.
     * This will cause the same property to be placed multiple times in the tuple.
     *
     * @param from  the start index, inclusive.
     * @param to    the end index, exclusive.
     * @param maybeItem the value to set.
     * @return A new tuple of items with the desired change.
     * @throws IndexOutOfBoundsException if {@code from} is negative, or {@code to} is greater than the size of this
     *                                   {@code Tuple} object, or {@code from} is greater than {@code to}.
     * @throws IllegalArgumentException  if the tuple allows {@code null} and the property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; maybeSetRange( int from, int to, Maybe&lt;T&gt; maybeItem )  {
<span class="pc bpc" id="L1170" title="3 of 6 branches missed.">        if ( from &lt; 0 || to &gt; size() || from &gt; to )</span>
<span class="nc" id="L1171">            throw new IndexOutOfBoundsException(&quot;From: &quot; + from + &quot;, To: &quot; + to + &quot;, Size: &quot; + size());</span>

<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">        if ( from == to )</span>
<span class="nc" id="L1174">            return this;</span>

<span class="pc bpc" id="L1176" title="1 of 4 branches missed.">        if ( !allowsNull() &amp;&amp; maybeItem.isEmpty() )</span>
<span class="fc" id="L1177">            return this;</span>

<span class="fc" id="L1179">        Maybe&lt;T&gt;[] items = new Maybe[to - from];</span>
<span class="fc" id="L1180">        Arrays.fill(items, maybeItem);</span>

<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">        Tuple&lt;T&gt; toBeSet = (Tuple&lt;T&gt;) (allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
<span class="fc" id="L1183">        return setAllAt(from, toBeSet);</span>
    }

    /**
     * Wraps each provided item in a property and appends it to this
     * tuple of items.
     *
     * @param items The array of values to add as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Tuple&lt;T&gt; addAll( T... items ) {
<span class="fc bfc" id="L1196" title="All 2 branches covered.">        return addAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates and returns an updated tuple of items where the items of the provided
     *  {@link Maybe} are appended at the end of the new item sequence.
     *  If this tuple does not allow null, then only the items of the
     *  non-empty {@link Maybe} will be appended.
     *  So if all {@link Maybe} items are empty, the tuple will remain unchanged.
     *
     * @param items The {@link Maybe} of items to append.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; maybeAddAll( Maybe&lt;T&gt;... items ) {
<span class="fc" id="L1211">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1212" title="1 of 2 branches missed.">        if ( !allowsNull() ) {</span>
<span class="fc" id="L1213">            List&lt;Maybe&lt;T&gt;&gt; onlyPresent = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">            for ( Maybe&lt;T&gt; item : items ) {</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">                if ( item.isPresent() )</span>
<span class="fc" id="L1216">                    onlyPresent.add(item);</span>
            }
<span class="fc" id="L1218">            items = onlyPresent.toArray(new Maybe[0]);</span>
        }
<span class="pc bpc" id="L1220" title="1 of 2 branches missed.">        return addAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates and returns a new tuple from this one where the
     *  items of the supplied {@link Iterable} are appended
     *  at the end of the new item sequence.
     *
     * @param items The values to append to the new tuple.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; addAll( Iterable&lt;T&gt; items ) {
<span class="fc" id="L1233">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">        return addAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates a merged tuple of items where the
     *  first sequence is based on the items of this tuple
     *  and the second sequence is based on the items of the provided tuple.
     *  The items of the provided tuple are effectively appended
     *  at the end of the new item sequence.
     *
     * @param tuple The tuple of items to append to the new tuple.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and at least one
     *                                  property does not allow {@code null}.
     */
    default Tuple&lt;T&gt; addAll( Tuple&lt;T&gt; tuple ) {
<span class="fc" id="L1250">        return addAllAt(size(), tuple);</span>
    }

    /**
     * Wraps each provided item in a property and adds them
     * to this tuple of items at the specified index.
     *
     * @param index The index at which to add the items.
     * @param items The array of values to add as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Tuple&lt;T&gt; addAllAt( int index, T... items ) {
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">        return addAllAt( index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     *  Creates an updated tuple of items where the items of the provided
     *  {@link Maybe} are all inserted at the specified index.
     *  If this tuple does not allow null, then only the items of the
     *  non-empty {@link Maybe} will be inserted.
     *  So if all {@link Maybe} items are empty, the tuple will remain unchanged.
     *
     * @param index The index at which to add the items.
     * @param items The {@link Maybe} of items to add.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; maybeAddAllAt( int index, Maybe&lt;T&gt;... items ) {
<span class="fc" id="L1280">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if ( !allowsNull() ) {</span>
<span class="fc" id="L1282">            List&lt;Maybe&lt;T&gt;&gt; onlyPresent = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1283" title="All 2 branches covered.">            for ( Maybe&lt;T&gt; item : items ) {</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">                if ( item.isPresent() )</span>
<span class="fc" id="L1285">                    onlyPresent.add(item);</span>
            }
<span class="fc" id="L1287">            items = onlyPresent.toArray(new Maybe[0]);</span>
        }
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">        return addAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Iterates over the supplied values, and adds
     * them to {@code this} tuple as items at the specified index.
     *
     * @param index The index at which to add the items.
     * @param items The values to add as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; addAllAt( int index, Iterable&lt;T&gt; items ) {
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">        return addAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Adds all items from the provided tuple of items to {@code this} tuple
     * at a specified index.
     *
     * @param index The index at which to add the items.
     * @param tuple The tuple of items to add.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and at least one
     *                                  property does not allow {@code null}.
     */
    Tuple&lt;T&gt; addAllAt( int index, Tuple&lt;T&gt; tuple );

    /**
     * Wraps each provided item in a property and
     * overwrites the existing items in this
     * tuple, starting at the specified index.
     *
     * @param index The index at which to replace the current items
     *              with new items created from the array of items.
     * @param items The array of values to set as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                  size of this {@code Vec} object.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    default Tuple&lt;T&gt; setAllAt( int index, T... items ) {
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">        return setAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     *  Creates an updated tuple of items where the items of the provided
     *  {@link Maybe} objects are replacing the items in this tuple,
     *  starting at the specified index.
     *  If this tuple does not allow null, then only the items of the
     *  non-empty {@link Maybe} will be inserted.
     *  So if all {@link Maybe} items are empty, the tuple will remain unchanged.
     *
     * @param index The index at which to add the items.
     * @param items The {@link Maybe} of items to add.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if the {@code items} is {@code null}.
     */
    default Tuple&lt;T&gt; maybeSetAllAt( int index, Maybe&lt;T&gt;... items ) {
<span class="fc" id="L1349">        Objects.requireNonNull(items);</span>
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">        if ( !allowsNull() ) {</span>
<span class="fc" id="L1351">            List&lt;Maybe&lt;T&gt;&gt; onlyPresent = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1352" title="All 2 branches covered.">            for ( Maybe&lt;T&gt; item : items ) {</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">                if ( item.isPresent() )</span>
<span class="fc" id="L1354">                    onlyPresent.add(item);</span>
            }
<span class="fc" id="L1356">            items = onlyPresent.toArray(new Maybe[0]);</span>
        }
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">        return setAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Iterates over the supplied values, and sets
     * them in this tuple as items starting at the specified index.
     * This method will replace the items in the specified range.
     *
     * @param index The index at which to set the items.
     * @param items The values to set as property items.
     * @return A new tuple of items with the desired change.
     * @throws NullPointerException if {@code null} is not allowed and one of the {@code items} is {@code null}.
     * @throws IndexOutOfBoundsException if {@code index} is negative, or {@code index} is greater than or equal to the
     *                                  size of this {@code Vec} object.
     */
    default Tuple&lt;T&gt; setAllAt( int index, Iterable&lt;T&gt; items ) {
<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">        return setAllAt(index, allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items));</span>
    }

    /**
     * Creates and returns a new tuple from this one where all items from the provided tuple of items,
     * are set starting at the specified index, effectively replacing the items in the specified range
     * of this tuple in the new tuple.
     *
     * @param index The index at which to set the items.
     * @param tuple The tuple of items to set.
     * @return A new tuple of items with the desired change.
     * @throws IllegalArgumentException if the tuple allows {@code null} and at least one
     *                                  property does not allow {@code null}.
     */
    Tuple&lt;T&gt; setAllAt( int index, Tuple&lt;T&gt; tuple );

    /**
     *  Retains only the items in this tuple that are contained in the provided tuple of items.
     *  This is also true for duplicate items.
     *
     * @param tuple The tuple of items to retain. All other items will be removed.
     * @return A new tuple of items with the desired change.
     */
    Tuple&lt;T&gt; retainAll( Tuple&lt;T&gt; tuple );

    /**
     * Removes all items from {@code this} tuple that are not contained in the provided iterable of items.
     *
     * @param items The iterable of items to retain. All other items will be removed.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; retainAll( Iterable&lt;T&gt; items ) {
<span class="pc bpc" id="L1406" title="1 of 2 branches missed.">        return retainAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     * Removes all items from {@code this} tuple whose items are not contained in the provided array of items.
     *
     * @param items The array of items, whose items to retain. All other items will be removed.
     * @return A new tuple of items with the desired change.
     */
    default Tuple&lt;T&gt; retainAll( T... items ) {
<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">        return retainAll( allowsNull() ? Tuple.ofNullable(type(), items) : Tuple.of(type(), items) );</span>
    }

    /**
     * Creates a new tuple of this one without any items but the same nullability (see {@link #allowsNull()}).
     * This is conceptually equivalent to calling {@link List#clear()},
     * but instead of returning {@code void}, it returns a new tuple with the desired change.
     * This instance remains completely unchanged.
     *
     * @return An empty tuple of items (which may remember internally that it was produced by a clear operation),
     *         with the same nullability as this tuple.
     */
    Tuple&lt;T&gt; clear();

    /**
     *  Returns a new tuple of items where each item is the result of applying the
     *  supplied mapper {@link Function} to the corresponding item in this tuple.
     *  The returned tuple has the same nullability as this tuple (see {@link #allowsNull()}).
     *
     * @param mapper The function to map the items to new items. This mapper function must not be {@code null}.
     * @return A new tuple where each item is the result of applying the
     *         supplied mapper function to the corresponding item in this tuple.
     * @throws NullPointerException if the mapper is {@code null}.
     */
    default Tuple&lt;T&gt; map( Function&lt;T,T&gt; mapper ) {
<span class="fc" id="L1441">        Objects.requireNonNull(mapper);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1443">        T[] mappedItems = (T[]) Array.newInstance(type(), size());</span>
<span class="fc" id="L1444">        int i = 0;</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc" id="L1446">            mappedItems[i++] = mapper.apply( v );</span>
<span class="fc" id="L1447">        }</span>
<span class="fc" id="L1448">        return new TupleWithDiff&lt;&gt;(TupleTree.of( allowsNull(), type(), mappedItems), SequenceDiff.of(this, SequenceChange.SET, 0, size()) );</span>
    }

    /**
     *  Returns a new tuple of items where each item is mapped to a new item
     *  of the specified type using the supplied mapper function.
     *  The returned tuple has the same nullability as this tuple (see {@link #allowsNull()}).
     *
     * @param &lt;U&gt; The type of the new items.
     * @param type The type of the new items to create.
     * @param mapper The function to map the items to the new type.
     * @return A new tuple where each item is the result of applying the
     *        supplied mapper function to the corresponding item in this tuple.
     * @throws NullPointerException if the type or the mapper is {@code null}.
     */
    default &lt;U extends @Nullable Object&gt; Tuple&lt;U&gt; mapTo(
        Class&lt;U&gt;      type,
        Function&lt;T,U&gt; mapper
    ) {
<span class="fc" id="L1467">        Objects.requireNonNull(type);</span>
<span class="fc" id="L1468">        Objects.requireNonNull(mapper);</span>
<span class="fc" id="L1469">        U[] array = (U[]) Array.newInstance(type, size());</span>
<span class="fc" id="L1470">        int i = 0;</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc" id="L1472">            U m = mapper.apply( v );</span>
<span class="fc" id="L1473">            array[i++] = m;</span>
<span class="fc" id="L1474">        }</span>
<span class="fc" id="L1475">        return new TupleWithDiff&lt;&gt;(TupleTree.of( allowsNull(), type, array), SequenceDiff.of(this, SequenceChange.SET, 0, size()) );</span>
    }

    /**
     *  Converts this tuple of items to a JDK {@link List} of items
     *  and then returns the resulting list.
     *  Note that the returned list is immutable.
     *
     * @return An immutable {@link List} of items in this {@link Tuple} instance.
     */
    default List&lt;T&gt; toList() {
<span class="fc" id="L1486">        return new AbstractList&lt;T&gt;() {</span>
            @Override
            public T get( int index ) {
<span class="nc" id="L1489">                return Tuple.this.get(index);</span>
            }
            @Override
            public int size() {
<span class="fc" id="L1493">                return Tuple.this.size();</span>
            }
            @Override
            public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L1497">                return Tuple.this.iterator();</span>
            }
            @Override
            public boolean contains( @Nullable Object o ) {
<span class="nc bnc" id="L1501" title="All 4 branches missed.">                if ( o != null &amp;&amp; !type().isAssignableFrom(o.getClass()) )</span>
<span class="nc" id="L1502">                    return false;</span>
<span class="nc" id="L1503">                return Tuple.this.contains(type().cast(o));</span>
            }
        };
    }

    /**
     *  Converts this tuple of items to a JDK {@link Set} of items
     *  and then returns the resulting set.
     *  Note that the returned set is immutable.
     *
     * @return An immutable {@link Set} of items in this {@link Tuple} instance.
     */
    default Set&lt;T&gt; toSet() {
<span class="fc" id="L1516">        return Collections.unmodifiableSet(stream().collect(Collectors.toSet()));</span>
    }

    /**
     *  Converts this tuple of items to Sprouts {@link ValueSet} of unique (non-duplicate) items
     *  and then returns the resulting set.
     *  Note that there is no specific order for the items in the resulting set.
     *
     * @return An immutable {@link ValueSet} of items in this {@link Tuple} instance.
     */
    default ValueSet&lt;T&gt; toValueSet() {
<span class="fc" id="L1527">        return ValueSet.of(this.type(), this);</span>
    }

    /**
     *  Converts this tuple of items to a plain array of items
     *
     * @return An array of items in this {@link Tuple} instance.
     */
    default T[] toArray() {
<span class="fc" id="L1536">        return stream().toArray(size -&gt; (T[]) Array.newInstance(type(), size));</span>
    }

    /**
     *  Turns this tuple of items into a stream of items
     *  which can be used for further functional processing.
     *  Note that the returned stream is not parallel.
     *
     * @return A stream of the items in this tuple of items.
     */
    default Stream&lt;T&gt; stream() {
<span class="fc" id="L1547">        return StreamSupport.stream(spliterator(), false);</span>
    }

    /**
     *  Turns this tuple of items into a parallel stream of items
     *  which can be used for further functional processing.
     *
     * @return A parallel stream of the items in this tuple of items.
     */
    default Stream&lt;T&gt; parallelStream() {
<span class="fc" id="L1557">        return StreamSupport.stream(spliterator(), true);</span>
    }

    /**
     * Use this for sorting the tuple of items.
     *
     * @param comparator The comparator to use for sorting (see {@link Comparator}).
     * @return A new tuple of items with the items sorted according to the provided comparator.
     */
    Tuple&lt;T&gt; sort( Comparator&lt;T&gt; comparator );

    /**
     * Sorts the tuple of items using the natural ordering of the items.
     * Note that this method expected the wrapped values to be {@link Comparable}.
     *
     * @return A new tuple of items with the items sorted according to their natural ordering (see {@link Comparable}).
     * @throws UnsupportedOperationException if the values are not {@link Comparable}.
     */
    default Tuple&lt;T&gt; sort() {
        // First we have to check if the type is comparable:
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">        if (Comparable.class.isAssignableFrom(type())) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1579">            Comparator&lt;T&gt; comparator = (Comparator&lt;T&gt;) Comparator.naturalOrder();</span>
<span class="fc" id="L1580">            return sort(comparator);</span>
        } else {
<span class="nc" id="L1582">            throw new UnsupportedOperationException(&quot;Cannot sort an immutable tuple of non-comparable types.&quot;);</span>
        }
    }

    /**
     *  Returns a new tuple of unique items, meaning that all duplicates
     *  in the original tuple are absent in the returned tuple.
     *
     * @return A new tuple of items with all duplicates removed.
     */
    Tuple&lt;T&gt; makeDistinct();

    /**
     *  Returns a new tuple with the exact same items as this tuple,
     *  but in reverse order.
     *
     * @return A new tuple of items with the items in reverse order.
     */
    Tuple&lt;T&gt; reversed();

    @Override
    default Iterator&lt;T&gt; iterator() {
<span class="nc" id="L1604">        return new Iterator&lt;T&gt;() {</span>
<span class="nc" id="L1605">            private final int _size = size();</span>
<span class="nc" id="L1606">            private int _index = 0;</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                return _index &lt; _size;</span>
            }

            @Override
            public T next() {
<span class="nc" id="L1615">                return get(_index++);</span>
            }
        };
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>