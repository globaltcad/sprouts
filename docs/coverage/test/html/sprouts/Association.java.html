<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Association.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">Association.java</span></div><h1>Association.java</h1><pre class="source lang-java linenums">package sprouts;

import sprouts.impl.Sprouts;

import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 *  Defines an association between keys and values
 *  as an immutable value object where the values
 *  are accessed by the keys in a map-like fashion.
 *  An association cannot contain duplicate keys,
 *  and each key can map to at most one value.&lt;br&gt;
 *  &lt;br&gt;
 *  You may think of this as a {@link java.util.Map}
 *  but without the ability to modify the association
 *  after it has been created. Instead, you may create
 *  a new association with the desired changes using
 *  methods like {@link #put(Object, Object)} or
 *  {@link #remove(Object)}, which will return a new
 *  association with the changes applied.&lt;br&gt;
 *  &lt;p&gt;&lt;b&gt;
 *      Note: Mutable objects should not be stored in an
 *      association, especially keys, whose hash codes
 *      and equality has to stay constant for the lifetime
 *      of the association, which assumes that their behavior
 *      does not change (key code hash caching for example).
 *      The behavior of this class is uncertain if a key
 *      is changed in a manner that affects equals
 *      or hashCode after it has been added to the association.
 *  &lt;/b&gt;
 *
 * @param &lt;K&gt; The type of the keys in this association, which must be immutable.
 * @param &lt;V&gt; The type of the values in this association, which should be immutable.
 */
public interface Association&lt;K, V&gt; extends Iterable&lt;Pair&lt;K, V&gt;&gt; {

    /**
     *  An alternative to {@code Association.class} which also includes the parameter
     *  types in the type signature of the returned association class.
     *  This is useful when you want to use associations as items in collection
     *  types or properties...
     *
     * @param keyType The key type {@code K} in the returned {@code Class&lt;Association&lt;K,V&gt;&gt;}.
     * @param valueType The value type {@code V} in the returned {@code Class&lt;Association&lt;K,V&gt;&gt;}.
     * @return The {@code Association.class} but with both parameter types included as {@code Class&lt;Association&lt;K,V&gt;&gt;}.
     * @param &lt;K&gt; The type of keys in the association class parameter signature.
     * @param &lt;V&gt; The type of values in the association class parameter signature.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;K,V&gt; Class&lt;Association&lt;K,V&gt;&gt; classTyped( Class&lt;K&gt; keyType, Class&lt;V&gt; valueType ) {
<span class="fc" id="L58">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L59">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L60">        return (Class) Association.class;</span>
    }

    /**
     *  A collector that can be used to collect key-value pairs
     *  from a Java {@link Stream} of {@link Pair} instances into
     *  an association. The types of the keys and values in the
     *  association have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; Pair.of(it.hashCode(), it.toUpperCase()) )
     *                .collect(Association.collectorOf(Integer.class, String.class));
     *  }&lt;/pre&gt;
     *  This will create a new association between integers and strings
     *  where the integers are the hash codes of the strings and the
     *  values are the upper case versions of the strings.&lt;br&gt;
     *  If there are null values in the stream, an exception will be thrown,
     *  because an association cannot contain null keys or values.
     *
     * @param keyType The type of the keys in the association to collect.
     * @param valueType The type of the values in the resulting association.
     * @param &lt;K&gt; The type of the keys in the association,
     *            which must be immutable and have value object semantics.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A collector that can be used to collect key-value pairs into an association.
     * @throws NullPointerException If any of the supplied type parameters is null.
     */
    static &lt;K, V&gt; Collector&lt;Pair&lt;? extends K,? extends V&gt;, ?, Association&lt;K,V&gt;&gt; collectorOf(
            Class&lt;K&gt; keyType,
            Class&lt;V&gt; valueType
    ) {
<span class="fc" id="L92">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L93">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L94">        return Collector.of(</span>
                    (Supplier&lt;Map&lt;K,V&gt;&gt;) HashMap::new,
<span class="fc" id="L96">                    (map, pair) -&gt; map.put(pair.first(), pair.second()),</span>
<span class="fc" id="L97">                    (left, right) -&gt; { left.putAll(right); return left; },</span>
<span class="fc" id="L98">                    map -&gt; Association.between(keyType, valueType).putAll(map)</span>
                );
    }

    /**
     *  A collector that can be used to collect key-value pairs
     *  from a Java {@link Stream} of {@link Pair} instances into
     *  an association with the given key and value types, where
     *  the key-value pairs are always ordered in the order they
     *  are added to the association.&lt;br&gt;
     *  The types of the keys and values in the association have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; Pair.of(it.hashCode(), it.toUpperCase()) )
     *                .collect(Association.collectorOfLinked(Integer.class, String.class));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered association between integers and strings
     *  where the integers are the hash codes of the strings and the
     *  values are the upper case versions of the strings.&lt;br&gt;
     *  If there are null values in the stream, an exception will be thrown,
     *  because an association cannot contain null keys or values.
     *
     * @param keyType The type of the keys in the association to collect.
     * @param valueType The type of the values in the resulting association.
     * @param &lt;K&gt; The type of the keys in the association,
     *            which must be immutable and have value object semantics.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A collector that can be used to collect key-value pairs into an ordered association.
     */
    static &lt;K, V&gt; Collector&lt;Pair&lt;? extends K,? extends V&gt;, ?, Association&lt;K,V&gt;&gt; collectorOfLinked(
            Class&lt;K&gt; keyType,
            Class&lt;V&gt; valueType
    ) {
<span class="fc" id="L132">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L133">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L134">        return Collector.of(</span>
                (Supplier&lt;Map&lt;K,V&gt;&gt;) LinkedHashMap::new,
<span class="fc" id="L136">                (map, pair) -&gt; map.put(pair.first(), pair.second()),</span>
<span class="fc" id="L137">                (left, right) -&gt; { left.putAll(right); return left; },</span>
<span class="fc" id="L138">                map -&gt; Association.betweenLinked(keyType, valueType).putAll(map)</span>
        );
    }

    /**
     *  A collector that can be used to collect key-value pairs
     *  from a Java {@link Stream} of {@link Pair} instances into
     *  an association with the given key and value types, where
     *  the keys are sorted using the provided comparator.
     *  The types of the keys and values in the association have to be defined when using this collector.&lt;br&gt;
     *  Here is an example demonstrating how this method may be used:&lt;br&gt;
     *  &lt;pre&gt;{@code
     *    var assoc = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
     *                .map( it -&gt; Pair.of(it.hashCode(), it.toUpperCase()) )
     *                .collect(Association.collectorOfSorted(Integer.class, String.class, Comparator.naturalOrder()));
     *  }&lt;/pre&gt;
     *  This will create a new-ordered association between integers and strings
     *  where the integers are the hash codes of the strings and the
     *  values are the upper case versions of the strings.&lt;br&gt;
     *  If there are null values in the stream, an exception will be thrown
     *  because an association cannot contain null keys or values.
     *
     * @param keyType The type of the keys in the association to collect.
     * @param valueType The type of the values in the resulting association.
     * @param comparator The comparator to use for sorting the keys in the association.
     * @param &lt;K&gt; The type of the keys in the association,
     *            which must be immutable and have value object semantics.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A collector that can be used to collect key-value pairs into an ordered association.
     */
    static &lt;K, V&gt; Collector&lt;Pair&lt;? extends K,? extends V&gt;, ?, Association&lt;K,V&gt;&gt; collectorOfSorted(
        Class&lt;K&gt; keyType,
        Class&lt;V&gt; valueType,
        Comparator&lt;K&gt; comparator
    ) {
<span class="fc" id="L173">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L174">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L175">        Objects.requireNonNull(comparator);</span>
<span class="fc" id="L176">        return Collector.of(</span>
                (Supplier&lt;List&lt;Pair&lt;? extends K,? extends V&gt;&gt;&gt;) ArrayList::new,
                List::add,
<span class="nc" id="L179">                (left, right) -&gt; { left.addAll(right); return left; },</span>
<span class="fc" id="L180">                list -&gt; Association.betweenSorted(keyType, valueType, comparator).putAll(list)</span>
        );
    }

    /**
     *  Creates a new association between keys and values
     *  with the given key and value types. An association
     *  knows the types of its keys and values, and so
     *  you can only put keys and values of the defined types
     *  into the association. This creates an empty association
     *  primed without any order of their key-value pairs.&lt;br&gt;
     *
     * @param keyType The type of the keys in the association.
     * @param valueType The type of the values in the association.
     * @param &lt;K&gt; The type of the keys in the association, which must be immutable.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A new association between keys and values.
     */
    static &lt;K, V&gt; Association&lt;K, V&gt; between( Class&lt;K&gt; keyType, Class&lt;V&gt; valueType ) {
<span class="fc" id="L199">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L200">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L201">        return Sprouts.factory().associationOf(keyType, valueType);</span>
    }

    /**
     *  Creates a new linked association between keys and values
     *  with the given key and value types, where the order of
     *  key-value pairs in this type of association is based on
     *  the order in which the pairs are added to the association.
     *  An association always knows the types of its keys and values,
     *  and so you can only put keys and values of the defined types
     *  into the association.
     *
     * @param keyType The type of the keys in the association.
     * @param valueType The type of the values in the association.
     * @param &lt;K&gt; The type of the keys in the association, which must be immutable.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A new linked association between keys and values, where
     *         the order of key-value pairs is preserved in the order they are added.
     */
    static &lt;K, V&gt; Association&lt;K, V&gt; betweenLinked( Class&lt;K&gt; keyType, Class&lt;V&gt; valueType ) {
<span class="fc" id="L221">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L222">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L223">        return Sprouts.factory().associationOfLinked(keyType, valueType);</span>
    }

    /**
     *  Creates a new association between keys and values
     *  with the given key and value types, where the key-value pairs
     *  are sorted using the supplied comparator.
     *  An association knows the types of its keys and values,
     *  and so you can only put keys and values of the defined types
     *  into the association.
     *
     * @param keyType The type of the keys in the association.
     * @param valueType The type of the values in the association.
     * @param comparator The comparator to use for sorting the keys in the association.
     * @param &lt;K&gt; The type of the keys in the association, which must be immutable.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A new sorted association between keys and values.
     */
    static &lt;K, V&gt; Association&lt;K, V&gt; betweenSorted( Class&lt;K&gt; keyType, Class&lt;V&gt; valueType, Comparator&lt;K&gt; comparator ) {
<span class="fc" id="L242">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L243">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L244">        Objects.requireNonNull(comparator);</span>
<span class="fc" id="L245">        return Sprouts.factory().associationOfSorted(keyType, valueType, comparator);</span>
    }

    /**
     *  Creates a new association between keys and values
     *  with the given key and value types, where the keys
     *  are sorted in natural order.
     *  An association knows the types of its keys and values,
     *  and so you can only put keys and values of the defined types
     *  into the association.
     *
     * @param keyType The type of the keys in the association.
     * @param valueType The type of the values in the association.
     * @param &lt;K&gt; The type of the keys in the association, which must be immutable.
     * @param &lt;V&gt; The type of the values in the association, which should be immutable.
     * @return A new sorted association between keys and values.
     */
    static &lt;K extends Comparable&lt;K&gt;, V&gt; Association&lt;K, V&gt; betweenSorted( Class&lt;K&gt; keyType, Class&lt;V&gt; valueType ) {
<span class="fc" id="L263">        Objects.requireNonNull(keyType);</span>
<span class="fc" id="L264">        Objects.requireNonNull(valueType);</span>
<span class="fc" id="L265">        return Sprouts.factory().associationOfSorted(keyType, valueType);</span>
    }

    /**
     *  Creates a new association from the given key-value pair.
     *  The types of the key and value are inferred from the
     *  types of the given key and value objects.
     *
     * @param key The key to associate with the given value.
     * @param value The value to associate with the given key.
     * @param &lt;K&gt; The type of the key in the association, this must be an immutable type.
     * @param &lt;V&gt; The type of the value, which should be an immutable type.
     * @return A new association with the given key-value pair
     *         and a size of 1.
     */
    static &lt;K, V&gt; Association&lt;K, V&gt; of( K key, V value ) {
<span class="fc" id="L281">        Objects.requireNonNull(key);</span>
<span class="fc" id="L282">        Objects.requireNonNull(value);</span>
<span class="fc" id="L283">        return between((Class&lt;K&gt;) key.getClass(), (Class&lt;V&gt;) value.getClass()).put(key, value);</span>
    }

    /**
     *  Creates a linked association from a single key-value pair
     *  where the types of the key and value are inferred from the
     *  two supplied objects.&lt;br&gt;
     *  A linked association is an association where the order of the
     *  key-value pairs is preserved in the order they are added to the association.
     *
     * @param key The key to associate with the given value.
     * @param value The value to associate with the given key.
     * @param &lt;K&gt; The type of the key in the association, this must be an immutable type.
     * @param &lt;V&gt; The type of the value, which should be an immutable type.
     * @return A new linked association with the given key-value pair
     *         and a size of 1.
     */
    static &lt;K, V&gt; Association&lt;K, V&gt; ofLinked( K key, V value ) {
<span class="fc" id="L301">        Objects.requireNonNull(key);</span>
<span class="fc" id="L302">        Objects.requireNonNull(value);</span>
<span class="fc" id="L303">        return betweenLinked((Class&lt;K&gt;) key.getClass(), (Class&lt;V&gt;) value.getClass()).put(key, value);</span>
    }

    /**
     *  Creates a sorted association from a single key-value pair
     *  and a comparator for sorting the keys.
     *  The types of the key and value are inferred from the
     *  types of the given key and value objects.&lt;br&gt;
     *  A sorted association is an association where the order of the
     *  key-value pairs is based on a {@link Comparator} used for sorting.
     *
     * @param key The key to associate with the given value.
     * @param value The value to associate with the given key.
     * @param comparator The comparator to use for sorting the keys in the association.
     * @param &lt;K&gt; The type of the key in the association, this must be an immutable type.
     * @param &lt;V&gt; The type of the value, which should be an immutable type.
     * @return A new sorted association with the given key-value pair
     *         and a size of 1.
     */
    static &lt;K, V&gt; Association&lt;K, V&gt; ofSorted( K key, V value, Comparator&lt;K&gt; comparator ) {
<span class="fc" id="L323">        Objects.requireNonNull(key);</span>
<span class="fc" id="L324">        Objects.requireNonNull(value);</span>
<span class="fc" id="L325">        return betweenSorted((Class&lt;K&gt;) key.getClass(), (Class&lt;V&gt;) value.getClass(), comparator).put(key, value);</span>
    }

    /**
     *  Returns the number of key-value pairs in this association.
     *
     * @return The number of key-value pairs in this association.
     */
    int size();

    /**
     *  Checks if this association is empty and returns
     *  {@code true} if it is, otherwise {@code false}.
     *
     * @return {@code true} if this association is empty, otherwise {@code false}.
     */
    default boolean isEmpty() {
<span class="fc bfc" id="L342" title="All 2 branches covered.">        return size() == 0;</span>
    }

    /**
     *  Checks if this association is not empty and returns
     *  {@code true} if it is not, otherwise {@code false}.
     *
     * @return {@code true} if this association is not empty, otherwise {@code false}.
     */
    default boolean isNotEmpty() {
<span class="fc bfc" id="L352" title="All 2 branches covered.">        return !isEmpty();</span>
    }

    /**
     *  Checks if this association is linked and returns
     *  {@code true} if it is, otherwise {@code false}.
     *  An association is linked if the order of the key-value pairs
     *  is preserved in the order they are added to the association.
     *  You can create a linked association using factory methods
     *  like {@link #betweenLinked(Class, Class)}.
     *
     * @return {@code true} if this association is linked, otherwise {@code false}.
     */
    boolean isLinked();

    /**
     *  Checks if this association is sorted and returns
     *  {@code true} if it is, otherwise {@code false}.
     *  An association is sorted if the keys are sorted in
     *  natural order or according to a supplied comparator
     *  when the association was created.&lt;br&gt;
     *  You can create a sorted association using factory methods
     *  like {@link #betweenSorted(Class, Class, Comparator)}, or
     *  by converting an existing association to a sorted one
     *  using the {@link #sort(Comparator)} method.
     *
     * @return {@code true} if this association is sorted, otherwise {@code false}.
     */
    boolean isSorted();

    /**
     *  Returns the type of the keys in this association.
     *
     * @return The type of the keys in this association.
     */
    Class&lt;K&gt; keyType();

    /**
     *  Returns the type of the values in this association.
     *
     * @return The type of the values in this association.
     */
    Class&lt;V&gt; valueType();

    /**
     *  Returns a {@link Set} of all the keys in this association.
     *  The returned set is immutable and cannot be modified.
     *
     * @return A set of all the keys in this association.
     */
    ValueSet&lt;K&gt; keySet();

    /**
     *  Returns a tuple of all the values in this association.
     * @return A tuple of all the values in this association.
     */
    Tuple&lt;V&gt; values();

    /**
     *  Returns a {@link Set} of all the key-value pairs in this association
     *  as {@link Pair} instances, where the first value of the pair is the key
     *  and the second value is the value associated with that key.
     *  The returned set is immutable and cannot be modified.
     *
     * @return A set of all the key-value pairs in this association
     *        as simple {@link Pair}s.
     */
    default ValueSet&lt;Pair&lt;K,V&gt;&gt; entrySet() {
<span class="fc" id="L420">        return new ValueSet&lt;Pair&lt;K, V&gt;&gt;() {</span>
            @Override
            public int size() {
<span class="fc" id="L423">                return Association.this.size();</span>
            }
            @Override
            public boolean isLinked() {
<span class="nc" id="L427">                return Association.this.isLinked();</span>
            }
            @Override
            public boolean isSorted() {
<span class="nc" id="L431">                return Association.this.isSorted();</span>
            }
            @Override
            public Class&lt;Pair&lt;K, V&gt;&gt; type() {
<span class="fc" id="L435">                return Pair.classTyped(Association.this.keyType(), Association.this.valueType());</span>
            }
            @Override
            public boolean contains(Pair&lt;K, V&gt; element) {
<span class="fc" id="L439">                return Association.this.containsKey(element.first());</span>
            }
            @Override
            public ValueSet&lt;Pair&lt;K, V&gt;&gt; add(Pair&lt;K, V&gt; element) {
<span class="nc" id="L443">                return Association.this.put(element).entrySet();</span>
            }
            @Override
            public ValueSet&lt;Pair&lt;K, V&gt;&gt; addAll(Stream&lt;? extends Pair&lt;K, V&gt;&gt; elements) {
<span class="nc" id="L447">                return Association.this.putAll((Stream) elements).entrySet();</span>
            }
            @Override
            public ValueSet&lt;Pair&lt;K, V&gt;&gt; remove(Pair&lt;K, V&gt; element) {
<span class="nc" id="L451">                return Association.this.remove(element.first()).entrySet();</span>
            }
            @Override
            public ValueSet&lt;Pair&lt;K, V&gt;&gt; removeAll(Stream&lt;? extends Pair&lt;K, V&gt;&gt; elements) {
<span class="nc" id="L455">                return Association.this.removeAll(elements.map(Pair::first).collect(Collectors.toSet()))</span>
<span class="nc" id="L456">                        .entrySet();</span>
            }
            @Override
            public ValueSet&lt;Pair&lt;K, V&gt;&gt; retainAll(Set&lt;? extends Pair&lt;K, V&gt;&gt; elements) {
<span class="nc" id="L460">                return Association.this.retainAll(elements.stream().map(Pair::first).collect(Collectors.toSet()))</span>
<span class="nc" id="L461">                        .entrySet();</span>
            }

            @Override
            public &lt;T extends Pair&lt;K, V&gt;&gt; ValueSet&lt;T&gt; retainIf(Class&lt;T&gt; type) {
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if ( !Objects.equals(type, Pair.class) ) {</span>
<span class="nc" id="L467">                    throw new IllegalArgumentException(&quot;Parameter may only be of type Pair!&quot;);</span>
                } else
<span class="nc" id="L469">                    return (ValueSet&lt;T&gt;) this;</span>
            }

            @Override
            public ValueSet&lt;Pair&lt;K, V&gt;&gt; clear() {
<span class="nc" id="L474">                return Sprouts.factory().valueSetOf(this.type());</span>
            }

            @Override
            public Iterator&lt;Pair&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L479">                return Association.this.iterator();</span>
            }
        };
    }

    /**
     *  Checks if the given key is present in this association
     *  and returns {@code true} if it is, otherwise {@code false}.
     * @param key The key to check for in this association.
     * @return {@code true} if the key is present, otherwise {@code false}.
     */
    boolean containsKey(K key);

    /**
     *  Returns the value associated wrapped by an {@link Optional}
     *  with the given key if it is present in this association,
     *  or an empty {@link Optional} if the key is not present.
     *
     * @param key The key to look up in this association.
     * @return An {@link Optional} containing the value associated with the key,
     *        or {@link Optional#empty()} if the key is not present.
     */
    Optional&lt;V&gt; get(K key);

    /**
     *  Returns a new association that is the same as this one
     *  but with the given key associated with the given value.
     *  If the key is already associated with the given value,
     *  then this association is returned.
     *
     * @param key The key to associate with the given value.
     * @param value The value to associate with the given key.
     * @return A new association with the given key-value pair.
     * @see #put(Pair) to add a key-value pair as a {@code Pair} instance.
     */
    Association&lt;K, V&gt; put(K key, V value);

    /**
     *  Returns a new association that is the same as this one
     *  but with the given key-value pair added to it through
     *  a {@link Pair} instance, where the first value of the
     *  pair is the key and the second value is the value.
     *  If the key is already present in this association, then the
     *  value is replaced with the given value.
     *
     * @param entry The key-value pair to add to this association.
     * @return A new association with the given key-value pair.
     * @see #put(Object, Object) to add a key-value pair as separate objects.
     * @throws NullPointerException if the provided pair is {@code null}.
     */
    default Association&lt;K, V&gt; put(Pair&lt;? extends K, ? extends V&gt; entry) {
<span class="nc" id="L530">        Objects.requireNonNull(entry, &quot;The provided pair cannot be null.&quot;);</span>
<span class="nc" id="L531">        return put(entry.first(), entry.second());</span>
    }

    /**
     * If the specified key is not already associated with a value
     * associates it with the given value and returns
     * {@code null}, else returns the current value.
     * &lt;p&gt;
     * This is equivalent to the following code, but is
     * implemented as a single operation that is atomic:
     *
     * &lt;pre&gt; {@code
     * V existing = association.get(key).orElse(null);
     * if (existing == null)
     *     association = association.put(key, aValue);
     * }&lt;/pre&gt;
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return The updated value associated with the specified key, or
     *         this (unchanged) association if the key was already
     *         associated with a value.
     */
    Association&lt;K, V&gt; putIfAbsent(K key, V value);

    /**
     *  Returns a new association that is the same as this one
     *  but with all the key-value pairs from the given association
     *  added to it. If the given association is empty, then this
     *  association is returned.
     *
     * @param other The association to add to this one.
     * @return A new association with the key-value pairs from the given association.
     * @throws NullPointerException if the provided association is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Association&lt;? extends K, ? extends V&gt; other ) {
<span class="fc" id="L567">        Objects.requireNonNull(other, &quot;The provided association cannot be null.&quot;);</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if ( other.isEmpty() )</span>
<span class="nc" id="L569">            return this;</span>
<span class="fc" id="L570">        return putAll( (Stream)other.entrySet().stream() );</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Map} added to it.
     *  If the provided map is empty, then this
     *  association is returned unchanged.
     *
     * @param map The {@link Map} to add to this association.
     * @return A new association with the key-value pairs from the provided map.
     * @throws NullPointerException if the provided map is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Map&lt;? extends K, ? extends V&gt; map ) {
<span class="fc" id="L584">        Objects.requireNonNull(map, &quot;The provided map cannot be null.&quot;);</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if ( map.isEmpty() )</span>
<span class="fc" id="L586">            return this;</span>
<span class="fc" id="L587">        return putAll(map.entrySet().stream().map(Pair::of));</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Set} of {@link Pair} instances added to it.
     *  If the provided set is empty, then this association is
     *  returned unchanged.
     *
     * @param entries The set of key-value pairs to add to this association.
     * @return A new association with the key-value pairs from the provided set.
     * @throws NullPointerException if the provided set is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Set&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L601">        Objects.requireNonNull(entries, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L602">        return putAll((Collection&lt;Pair&lt;? extends K,? extends V&gt;&gt;) entries);</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied array of {@link Pair}s added to it, where the {@link Pair#first()}
     *  is the key and the {@link Pair#second()} is the value.
     *  If the provided array is empty, then this
     *  association is returned unchanged.
     *
     * @param entries The array of key-value pairs to add to this association.
     * @return A new association with the key-value pairs from the provided array.
     * @throws NullPointerException if the provided array is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Pair&lt;? extends K, ? extends V&gt;... entries ) {
<span class="fc" id="L617">        Objects.requireNonNull(entries, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">        if ( entries.length == 0 )</span>
<span class="nc" id="L619">            return this;</span>
<span class="fc" id="L620">        return putAll(Arrays.stream(entries));</span>
    }

    /**
     *  Returns a new association with all the key-value pairs of the
     *  supplied {@link Tuple} of {@link Pair} instances added to it,
     *  where the {@link Pair#first()} object of each pair is the key
     *  and the {@link Pair#second()} object is the value.
     *  If the provided tuple is empty, then this association is returned unchanged.
     *
     * @param entries The tuple of key-value pairs to add to this association.
     * @return A new association with the key-value pairs from the provided tuple.
     * @throws NullPointerException if the provided tuple is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Tuple&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L635">        Objects.requireNonNull(entries, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">        if ( entries.isEmpty() )</span>
<span class="nc" id="L637">            return this;</span>
<span class="fc" id="L638">        return putAll(entries.stream());</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Collection} of {@link Pair} instances added to it.
     *  If the provided collection is empty, then this
     *  association is returned unchanged.
     *
     * @param entries The collection of key-value pairs to add to this association.
     * @return A new association with the key-value pairs from the provided collection.
     * @throws NullPointerException if the provided collection is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Collection&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L652">        Objects.requireNonNull(entries, &quot;The provided collection cannot be null.&quot;);</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">        if ( entries.isEmpty() )</span>
<span class="fc" id="L654">            return this;</span>
<span class="fc" id="L655">        return putAll(entries.stream());</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Stream} of {@link Pair} instances added to it.
     *  If the provided stream is empty, then this
     *  association is returned unchanged.
     *
     * @param entries The stream of key-value pairs to add to this association.
     * @return A new association with the key-value pairs from the provided stream.
     * @throws NullPointerException if the provided stream is {@code null}.
     */
    default Association&lt;K, V&gt; putAll( final Stream&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L669">        Objects.requireNonNull(entries);</span>
        // TODO: implement branching based bulk insert
<span class="fc" id="L671">        Association&lt;K, V&gt; result = this;</span>
        // reduce the stream to a single association
<span class="fc" id="L673">        return entries.reduce(</span>
                result,
                (acc,
<span class="fc" id="L676">                 entry) -&gt; acc.put(entry.first(), entry.second()),</span>
<span class="nc" id="L677">                (a, b) -&gt; a);</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the supplied association
     *  added to it, if, and only if, they are not already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  If the given association is empty, then this
     *  association is returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param other The association to add to this one.
     * @return A new association with all new key-value pairs from the given association.
     * @throws NullPointerException if the provided association is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Association) If you want to add all key-value pairs from an association, even
     *                           if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Association&lt;? extends K, ? extends V&gt; other ) {
<span class="fc" id="L697">        Objects.requireNonNull(other, &quot;The provided association cannot be null.&quot;);</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">        if ( other.isEmpty() )</span>
<span class="nc" id="L699">            return this;</span>
<span class="fc" id="L700">        return putAllIfAbsent( (Stream)other.entrySet().stream() );</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Map} added to it, if, and only if, they are not
     *  already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  If the provided map is empty, then this
     *  association is returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param map The {@link Map} to add to this association.
     * @return A new association with new key-value pairs from the supplied map.
     * @throws NullPointerException if the provided map is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Map) If you want to add all key-value pairs from a map, even
     *                   if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Map&lt;? extends K, ? extends V&gt; map ) {
<span class="fc" id="L721">        Objects.requireNonNull(map, &quot;The provided map cannot be null.&quot;);</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">        if ( map.isEmpty() )</span>
<span class="nc" id="L723">            return this;</span>
<span class="fc" id="L724">        return putAllIfAbsent(map.entrySet().stream().map(Pair::of));</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Set} of {@link Pair} instances added to it,
     *  if, and only if, they are not already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  If the provided set is empty, then this association is
     *  returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param entries The set of key-value pairs to add to this association.
     * @return A new association with the key-value pairs from the provided set.
     * @throws NullPointerException if the provided set is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Set) If you want to add all key-value pairs from a set, even
     *                   if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Set&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L745">        Objects.requireNonNull(entries, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L746">        return putAllIfAbsent((Collection&lt;Pair&lt;? extends K,? extends V&gt;&gt;) entries);</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied array of {@link Pair}s added to it, if, and only if,
     *  they are not already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  In the items of the supplied array, the {@link Pair#first()}
     *  is the key and the {@link Pair#second()} is the value.
     *  If the provided array is empty, then this
     *  association is returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param entries The array of key-value pairs to add to this association.
     * @return A new association with new key-value pairs from the provided array.
     * @throws NullPointerException if the provided array is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Pair[]) If you want to add all key-value pairs from an array, even
     *                      if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Pair&lt;? extends K, ? extends V&gt;... entries ) {
<span class="fc" id="L769">        Objects.requireNonNull(entries, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">        if ( entries.length == 0 )</span>
<span class="nc" id="L771">            return this;</span>
<span class="fc" id="L772">        return putAllIfAbsent(Arrays.stream(entries));</span>
    }

    /**
     *  Returns a new association with all the key-value pairs of the
     *  supplied {@link Tuple} of {@link Pair} instances added to it,
     *  if, and only if, they are not already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  In the items of the supplied tuple, the {@link Pair#first()}
     *  object of each pair is the key and the {@link Pair#second()} object is the value.
     *  If the provided tuple is empty, then this association is returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param entries The tuple of key-value pairs to add to this association if not already present.
     * @return A new association with the new key-value pairs from the provided tuple.
     * @throws NullPointerException if the provided tuple is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Tuple) If you want to add all key-value pairs from a tuple, even
     *                      if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Tuple&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L794">        Objects.requireNonNull(entries, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">        if ( entries.isEmpty() )</span>
<span class="nc" id="L796">            return this;</span>
<span class="fc" id="L797">        return putAllIfAbsent(entries.stream());</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Collection} of {@link Pair}s added to it,
     *  if, and only if, they are not already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  If the provided collection is empty, then this
     *  association is returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param entries The collection of key-value pairs to add to this association.
     * @return A new association with the new key-value pairs from the provided collection.
     * @throws NullPointerException if the provided collection is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Collection) If you want to add all key-value pairs from a collection, even
     *                         if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Collection&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L818">        Objects.requireNonNull(entries, &quot;The provided collection cannot be null.&quot;);</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">        if ( entries.isEmpty() )</span>
<span class="nc" id="L820">            return this;</span>
<span class="fc" id="L821">        return putAllIfAbsent(entries.stream());</span>
    }

    /**
     *  Returns a new association with all the key-value pairs from the
     *  supplied {@link Stream} of {@link Pair} instances added to it,
     *  if, and only if, they are not already present in this association.
     *  This means that existing entry pairs are not overwritten!&lt;br&gt;
     *  If the provided stream is empty, then this
     *  association is returned unchanged.&lt;br&gt;
     *  Note that this method is essentially a batched variant
     *  of {@link #putIfAbsent(Object, Object)}.
     *
     * @param entries The stream of key-value pairs to add to this association.
     * @return A new association with the new key-value pairs from the provided stream.
     * @throws NullPointerException if the provided stream is {@code null}.
     * @see #putIfAbsent(Object, Object)
     * @see #putAll(Stream) If you want to add all key-value pairs from a stream, even
     *                      if they replace existing entries!
     */
    default Association&lt;K, V&gt; putAllIfAbsent( final Stream&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L842">        Objects.requireNonNull(entries);</span>
        // TODO: implement branching based bulk insert
<span class="fc" id="L844">        Association&lt;K, V&gt; result = this;</span>
        // reduce the stream to a single association
<span class="fc" id="L846">        return entries.reduce(</span>
                result,
                (acc,
<span class="fc" id="L849">                 entry) -&gt; acc.putIfAbsent(entry.first(), entry.second()),</span>
<span class="nc" id="L850">                (a, b) -&gt; a);</span>
    }

    /**
     *  Returns a new association where the value associated with the given key
     *  is transformed using the provided update function, but only if the key
     *  exists in this association. If the key is not present, this association
     *  is returned unchanged.&lt;br&gt;
     *  &lt;br&gt;
     *  This method provides a safe and convenient way to modify existing values
     *  without having to manually check for key existence or handle {@link Optional}
     *  values.&lt;br&gt;
     *  &lt;br&gt;
     *  Example usage:
     *  &lt;pre&gt;{@code
     *    var ages = Association.of(&quot;Haruka&quot;, 24)
     *                            .put(&quot;Josh&quot;, 28)
     *                            .put(&quot;Tom&quot;, 20);
     *
     *    var updatedAges = ages.update(&quot;Haruka&quot;, age -&gt; age + 5)
     *                          .update(&quot;Tom&quot;, age -&gt; age * 2);
     *
     *    // The result: Haruka=29, Josh=28, Tom=40
     *  }&lt;/pre&gt;
     *
     * @param key The key whose associated value should be updated. It must not be {@code null}.
     * @param updater A function that takes the current value and returns a new value.
     *               The function will only be called if the key exists. Must not be {@code null}.
     * @return A new association with the updated value if the key existed,
     *         or this association unchanged if the key was not found.
     * @throws NullPointerException if either the key or updater function is {@code null}.
     * @throws NullPointerException if the updater function returns {@code null} (associations cannot contain null values).
     *
     * @see #put(Object, Object) For adding or replacing values regardless of existence
     * @see #replace(Object, Object) For replacing existing values only
     * @see #putIfAbsent(Object, Object) For adding values only when the key is absent
     */
    default Association&lt;K, V&gt; update( K key, Function&lt;V, V&gt; updater ) {
<span class="fc" id="L888">        Objects.requireNonNull(key);</span>
<span class="fc" id="L889">        Objects.requireNonNull(updater);</span>
<span class="fc" id="L890">        return get(key).map(v -&gt; put(key, updater.apply(v))).orElse(this);</span>
    }

    /**
     * Returns a new association where the values associated with all the given keys
     * are transformed using the provided update function, but only for keys that
     * exist in this association. Keys that are not present in the association
     * are silently ignored.&lt;br&gt;
     * &lt;br&gt;
     * This method provides a convenient way to batch-update multiple values
     * in a single operation, making it ideal for scenarios where you need to
     * apply the same transformation to multiple existing entries.&lt;br&gt;
     * &lt;br&gt;
     * Example usage:
     * &lt;pre&gt;{@code
     *   var inventory = Association.of(&quot;apples&quot;, 10)
     *                              .put(&quot;oranges&quot;, 15)
     *                              .put(&quot;bananas&quot;, 20)
     *                              .put(&quot;grapes&quot;, 8);
     *
     *   // A user bought 2 oranges and grapes each.
     *   var inventory = inventory.updateAll(
     *                     Tuple.of(&quot;oranges&quot;, &quot;grapes&quot;),
     *                     quantity -&gt; quantity - 2
     *                   );
     *
     *   // The result: apples=10, oranges=13, bananas=20, grapes=6
     * }&lt;/pre&gt;
     *
     * @param keys A tuple of keys whose associated values should be updated.
     * @param updater A function that takes the current value and returns a new value.
     *               The function will only be called for keys that exist. Must not be {@code null}.
     * @return A new association with the updated values for all existing keys in the provided tuple,
     *         or this association unchanged if none of the keys were found.
     * @throws NullPointerException if either the keys tuple or updater function is {@code null}.
     * @throws NullPointerException if the updater function returns {@code null} for any value.
     *
     * @see #update(Object, Function) For updating a single value
     * @see #updateAll(ValueSet, Function) For updating values using a ValueSet of keys
     * @see #updateAll(Collection, Function) For updating values using any collection of keys
     */
    default Association&lt;K, V&gt; updateAll( Tuple&lt;K&gt; keys, Function&lt;V, V&gt; updater ) {
<span class="fc" id="L932">        Objects.requireNonNull(keys);</span>
<span class="fc" id="L933">        Objects.requireNonNull(updater);</span>
<span class="fc" id="L934">        return updateAll(keys.toValueSet(), updater);</span>
    }

    /**
     * Returns a new association where the values associated with all the given keys
     * in the supplied {@link ValueSet} are transformed using an update function,
     * but only for keys that exist in this association. Keys that are not present
     * in the association are silently ignored.&lt;br&gt;
     * &lt;br&gt;
     * This method is particularly useful when you already have a {@link ValueSet}
     * of keys and want to apply a uniform transformation to their corresponding values.&lt;br&gt;
     *
     * @param keys A ValueSet of keys whose associated values should be updated.
     * @param updater A function that takes the current value and returns a new value.
     *               The function will only be called for keys that exist. Must not be {@code null}.
     * @return A new association with the updated values for all existing keys in the provided ValueSet,
     *         or this association unchanged if none of the keys were found.
     * @throws NullPointerException if either the keys ValueSet or updater function is {@code null}.
     * @throws NullPointerException if the updater function returns {@code null} for any value.
     *
     * @see #update(Object, Function) For updating a single value
     * @see #updateAll(Tuple, Function) For updating values using a Tuple of keys
     * @see #updateAll(Collection, Function) For updating values using any collection of keys
     */
    default Association&lt;K, V&gt; updateAll( ValueSet&lt;K&gt; keys, Function&lt;V, V&gt; updater ) {
<span class="fc" id="L959">        Objects.requireNonNull(keys);</span>
<span class="fc" id="L960">        Objects.requireNonNull(updater);</span>
<span class="fc" id="L961">        return updateAll(keys.stream(), updater);</span>
    }

    /**
     * Returns a new association where the values associated with all the keys
     * in the supplied collection are transformed using the update function,
     * but only for keys that exist in this association. Keys that are not present
     * in the association are silently ignored.&lt;br&gt;
     * &lt;br&gt;
     * This method offers the most flexibility as it accepts any {@link Collection}
     * implementation, making it easy to integrate with existing Java collections.&lt;br&gt;
     * &lt;br&gt;
     * Example usage:
     * &lt;pre&gt;{@code
     *   var productPrices = Association.of(&quot;laptop&quot;, 999.99)
     *                                  .put(&quot;mouse&quot;, 25.50)
     *                                  .put(&quot;keyboard&quot;, 75.00)
     *                                  .put(&quot;monitor&quot;, 299.99);
     *
     *   // List of products going on sale
     *   var saleProducts = List.of(&quot;mouse&quot;, &quot;keyboard&quot;, &quot;headphones&quot;);
     *
     *   // Apply 15% discount to sale products
     *   var salePrices = productPrices.updateAll(
     *       saleProducts,
     *       price -&gt; price * 0.85  // 15% discount
     *   );
     *
     *   // The result: laptop=999.99, mouse=21.675, keyboard=63.75, monitor=299.99
     *   // Note: &quot;headphones&quot; was ignored since it wasn't in the original association
     * }&lt;/pre&gt;
     *
     * @param keys A collection of keys whose associated values should be updated.
     * @param updater A function that takes the current value and returns a new value.
     *               The function will only be called for keys that exist. Must not be {@code null}.
     * @return A new association with the updated values for all existing keys in the provided collection,
     *         or this association unchanged if none of the keys were found.
     * @throws NullPointerException if either the keys collection or updater function is {@code null}.
     * @throws NullPointerException if the updater function returns {@code null} for any value.
     *
     * @see #update(Object, Function) For updating a single value
     * @see #updateAll(Tuple, Function) For updating values using a Tuple of keys
     * @see #updateAll(ValueSet, Function) For updating values using a ValueSet of keys
     */
    default Association&lt;K, V&gt; updateAll( Collection&lt;? extends K&gt; keys, Function&lt;V, V&gt; updater ) {
<span class="fc" id="L1006">        Objects.requireNonNull(keys);</span>
<span class="fc" id="L1007">        Objects.requireNonNull(updater);</span>
<span class="fc" id="L1008">        return updateAll(keys.stream(), updater);</span>
    }

    /**
     * Returns a new association where the values associated with the keys
     * from the supplied stream are transformed using the update function,
     * but only for keys that exist in this association. Keys that are not present
     * in the association are silently ignored.&lt;br&gt;
     * &lt;br&gt;
     * This method is ideal for scenarios where you have a stream of keys,
     * such as when filtering or processing keys from another data source,
     * and want to efficiently apply updates to the corresponding values.&lt;br&gt;
     * &lt;br&gt;
     * Example usage:
     * &lt;pre&gt;{@code
     *   var websiteStats = Association.of(&quot;/home&quot;, 1500)
     *                                 .put(&quot;/about&quot;, 800)
     *                                 .put(&quot;/contact&quot;, 300)
     *                                 .put(&quot;/products&quot;, 1200)
     *                                 .put(&quot;/blog&quot;, 950);
     *
     *   // Update page views for high-traffic pages (over 1000 views)
     *   var updatedStats = websiteStats.updateAll(
     *       websiteStats.entrySet().stream()
     *                   .filter(entry -&gt; entry.second() &gt; 1000)
     *                   .map(Pair::first),  // Stream of high-traffic page keys
     *       views -&gt; views + 100  // Add 100 bonus views for high performers
     *   );
     *
     *   // The result: /home=1600, /about=800, /contact=300, /products=1300, /blog=950
     * }&lt;/pre&gt;
     *
     * @param keys A stream of keys whose associated values should be updated.
     * @param updater A function that takes the current value and returns a new value.
     *               The function will only be called for keys that exist. Must not be {@code null}.
     * @return A new association with the updated values for all existing keys in the provided stream,
     *         or this association unchanged if none of the keys were found.
     * @throws NullPointerException if either the keys stream or updater function is {@code null}.
     * @throws NullPointerException if the updater function returns {@code null} for any value.
     *
     * @see #update(Object, Function) For updating a single value
     * @see #updateAll(Tuple, Function) For updating values using a Tuple of keys
     * @see #updateAll(ValueSet, Function) For updating values using a ValueSet of keys
     * @see #updateAll(Collection, Function) For updating values using any collection of keys
     */
    default Association&lt;K, V&gt; updateAll( Stream&lt;? extends K&gt; keys, Function&lt;V, V&gt; updater ) {
<span class="fc" id="L1054">        Objects.requireNonNull(keys);</span>
<span class="fc" id="L1055">        Objects.requireNonNull(updater);</span>
<span class="pc" id="L1056">        return keys.reduce(this, (acc, key) -&gt; acc.update(key, updater), (a, b) -&gt; a);</span>
    }

    /**
     *  Returns a new association where an existing key-value pair
     *  is replaced with the given key-value pair if the key is
     *  present in this association.
     *  So this will not affect the key set of this association, but may change
     *  the values associated with the keys.
     *  &lt;b&gt;So this means that the returned association will always be of the same type as this one.&lt;/b&gt;
     *  If the key is not present in
     *  this association, then this association is returned unchanged.
     *
     * @param key The key to associate with the given value if it is
     *            already present in this association.
     * @param value The value to associate with the supplied key.
     * @return A new association where the key-value pair matching the
     *         supplied key is replaced with the given key-value pair.
     * @see #replace(Pair) to replace a key-value pair as a {@code Pair} instance.
     */
    default Association&lt;K, V&gt; replace(K key, V value) {
<span class="fc bfc" id="L1077" title="All 2 branches covered.">        if ( this.containsKey(key) ) {</span>
<span class="fc" id="L1078">            return this.put(key, value);</span>
        } else {
<span class="fc" id="L1080">            return this;</span>
        }
    }

    /**
     *  Returns a new association where an existing key-value pair
     *  is replaced with the given key-value pair if the key is
     *  present in this association.
     *  So this will not affect the key set of this association, but may change
     *  the values associated with the keys.
     *  &lt;b&gt;So this means that the returned association will always be of the same type as this one.&lt;/b&gt;
     *  If the key is not present in
     *  this association, then this association is returned unchanged.
     *
     * @param entry The key-value pair to replace the existing key-value pair with.
     * @return A new association where the key-value pair matching the
     *         supplied key is replaced with the given key-value pair.
     * @see #replace(Object, Object) to replace a key-value pair as separate objects.
     */
    default Association&lt;K, V&gt; replace( Pair&lt;? extends K, ? extends V&gt; entry ) {
<span class="nc" id="L1100">        return replace(entry.first(), entry.second());</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied association.
     *  This will &lt;b&gt;not&lt;/b&gt; affect the key set of this association, but may change
     *  the values associated with the keys, &lt;b&gt;which means that the returned association
     *  will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied association is empty, then this association is returned unchanged.
     *
     * @param other The association whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *          of this association are replaced by those in the supplied association.
     * @throws NullPointerException if the supplied association is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Association&lt;? extends K, ? extends V&gt; other ) {
<span class="nc" id="L1117">        Objects.requireNonNull(other, &quot;The provided association cannot be null.&quot;);</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if ( other.isEmpty() )</span>
<span class="nc" id="L1119">            return this;</span>
<span class="nc" id="L1120">        return replaceAll((Stream)other.entrySet().stream());</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied {@link Map}.
     *  This will &lt;b&gt;not&lt;/b&gt; affect the key set of this association, but may change
     *  the values associated with the keys, &lt;b&gt;which means that the returned
     *  association will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied map is empty, then this association is returned unchanged.
     *
     * @param map The map whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *          of this association are replaced by those in the supplied map.
     * @throws NullPointerException if the supplied map is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Map&lt;? extends K, ? extends V&gt; map ) {
<span class="fc" id="L1137">        Objects.requireNonNull(map, &quot;The provided map cannot be null.&quot;);</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">        if (map.isEmpty())</span>
<span class="nc" id="L1139">            return this;</span>
<span class="fc" id="L1140">        return replaceAll(map.entrySet().stream().map(Pair::of));</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied {@link Set}
     *  of {@link Pair} instances. This will &lt;b&gt;not&lt;/b&gt; affect the key set of this
     *  association, but may change the values associated with the keys, &lt;b&gt;which
     *  means that the returned association will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied set is empty, then this association is returned unchanged.
     *
     * @param entries The {@link Set} of key-value pairs whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *         of this association are replaced by those in the supplied set.
     * @throws NullPointerException if the supplied set is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Set&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L1157">        Objects.requireNonNull(entries, &quot;The provided set cannot be null.&quot;);</span>
<span class="fc" id="L1158">        return replaceAll((Collection&lt;Pair&lt;? extends K,? extends V&gt;&gt;) entries);</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied array
     *  of {@link Pair} instances. This will &lt;b&gt;not&lt;/b&gt; affect the key set of this
     *  association, but may change the values associated with the keys, &lt;b&gt;which
     *  means that the returned association will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied array is empty, then this association is returned unchanged.
     *
     * @param entries The array of key-value {@link Pair}s whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *         of this association are replaced by those in the supplied array.
     * @throws NullPointerException if the supplied array is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Pair&lt;? extends K, ? extends V&gt;... entries ) {
<span class="fc" id="L1175">        Objects.requireNonNull(entries, &quot;The provided array cannot be null.&quot;);</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">        if (entries.length == 0)</span>
<span class="nc" id="L1177">            return this;</span>
<span class="fc" id="L1178">        return replaceAll(Arrays.stream(entries));</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied {@link Tuple}
     *  of {@link Pair} instances. This will &lt;b&gt;not&lt;/b&gt; affect the key set of this
     *  association, but may change the values associated with the keys, &lt;b&gt;which
     *  means that the returned association will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied tuple is empty, then this association is returned unchanged.
     *
     * @param entries The tuple of key-value {@link Pair}s whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *         of this association are replaced by those in the supplied tuple.
     * @throws NullPointerException if the supplied tuple is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Tuple&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L1195">        Objects.requireNonNull(entries, &quot;The provided tuple cannot be null.&quot;);</span>
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">        if (entries.isEmpty())</span>
<span class="nc" id="L1197">            return this;</span>
<span class="fc" id="L1198">        return replaceAll(entries.stream());</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied {@link Collection}
     *  of {@link Pair} instances. This will &lt;b&gt;not&lt;/b&gt; affect the key set of this
     *  association, but may change the values associated with the keys, &lt;b&gt;which
     *  means that the returned association will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied collection is empty, then this association is returned unchanged.
     *
     * @param entries The collection of key-value {@link Pair}s whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *         of this association are replaced by those in the supplied collection.
     * @throws NullPointerException if the supplied collection is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Collection&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L1215">        Objects.requireNonNull(entries, &quot;The provided collection cannot be null.&quot;);</span>
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">        if (entries.isEmpty())</span>
<span class="nc" id="L1217">            return this;</span>
<span class="fc" id="L1218">        return replaceAll(entries.stream());</span>
    }

    /**
     *  Returns a new association where all existing key-value pairs
     *  from this association are replaced by those in the supplied {@link Stream}
     *  of {@link Pair} instances. This will &lt;b&gt;not&lt;/b&gt; affect the key set of this
     *  association, but may change the values associated with the keys, &lt;b&gt;which
     *  means that the returned association will always be of the same size as this one.&lt;/b&gt;
     *  If the supplied stream is empty, then this association is returned unchanged.
     *
     * @param entries The stream of key-value {@link Pair}s whose entries should replace the entries in this association.
     * @return A new association with where the existing key-value pairs
     *         of this association are replaced by those in the supplied stream.
     * @throws NullPointerException if the supplied stream is {@code null}.
     */
    default Association&lt;K, V&gt; replaceAll( Stream&lt;Pair&lt;? extends K, ? extends V&gt;&gt; entries ) {
<span class="fc" id="L1235">        Objects.requireNonNull(entries);</span>
<span class="fc" id="L1236">        Association&lt;K, V&gt; result = this;</span>
        // reduce the stream to a single association
<span class="fc" id="L1238">        return entries.reduce(</span>
                result,
<span class="fc" id="L1240">                (acc, entry) -&gt; acc.replace(entry.first(), entry.second()),</span>
<span class="nc" id="L1241">                (a, b) -&gt; a);</span>
    }

    /**
     *  Returns a new association that is the same as this one
     *  but without the given key. If the key is not present
     *  in this association, then this association is returned.
     *
     * @param key The key to remove from this association.
     * @return A new association without the given key.
     */
    Association&lt;K, V&gt; remove( K key );

    /**
     *  Creates and returns a new association in which all entry pairs are
     *  removed whose keys are present in the supplied {@link ValueSet}. If the
     *  supplied set is empty, then this association is returned
     *  unchanged.
     *
     * @param keys The keys to remove from this association.
     * @return A new association without the keys in the given set.
     */
    default Association&lt;K, V&gt; removeAll( ValueSet&lt;? extends K&gt; keys ) {
<span class="pc bpc" id="L1264" title="2 of 4 branches missed.">        if ( this.isEmpty() || keys.isEmpty() )</span>
<span class="nc" id="L1265">            return this;</span>
<span class="fc" id="L1266">        Association&lt;K, V&gt; result = this;</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">        for ( K key : keys ) {</span>
<span class="fc" id="L1268">            result = result.remove(key);</span>
<span class="fc" id="L1269">        }</span>
<span class="fc" id="L1270">        return result;</span>
    }

    /**
     *  Creates and returns a new association in which all entry pairs are
     *  removed whose keys are present in the supplied {@link Set}. If the
     *  supplied set is empty, then this association is returned
     *  unchanged.
     *
     * @param keys The keys to remove from this association.
     * @return A new association without the keys in the given set.
     */
    default Association&lt;K, V&gt; removeAll( Set&lt;? extends K&gt; keys ) {
<span class="pc bpc" id="L1283" title="1 of 4 branches missed.">        if ( this.isEmpty() || keys.isEmpty() )</span>
<span class="fc" id="L1284">            return this;</span>
<span class="fc" id="L1285">        Association&lt;K, V&gt; result = this;</span>
<span class="fc bfc" id="L1286" title="All 2 branches covered.">        for ( K key : keys ) {</span>
<span class="fc" id="L1287">            result = result.remove(key);</span>
<span class="fc" id="L1288">        }</span>
<span class="fc" id="L1289">        return result;</span>
    }

    /**
     *  Creates and returns a new association in which all entry pairs are
     *  removed whose keys are found in the supplied {@link Stream}. If the
     *  supplied stream does not provide any elements, then this association is returned
     *  unchanged.
     *
     * @param keys A stream of keys to remove from this association.
     * @return A new association without any of the keys found in the supplied stream.
     * @throws NullPointerException - if the supplied stream is null
     */
    default Association&lt;K, V&gt; removeAll( Stream&lt;? extends K&gt; keys ) {
<span class="fc" id="L1303">        Objects.requireNonNull(keys);</span>
<span class="fc" id="L1304">        Association&lt;K, V&gt; result = this;</span>
        // reduce the stream to a single association
<span class="pc" id="L1306">        return keys.reduce(result, Association::remove, (a, b) -&gt; a);</span>
    }

    /**
     *  Creates an updates {@link Association} where all key/value pairs satisfying
     *  the given {@link Predicate}, are removed. Or in other words,
     *  if {@link Predicate#test(Object)} yields {@code true} for a particular
     *  entry {@link Pair}, then it will be removed, otherwise, it will remain in the
     *  returned association.&lt;br&gt;
     *  Note that errors or runtime exceptions thrown
     *  during iteration or by the predicate are relayed to the caller.
     *
     * @param filter A function which takes in a key/value {@link Pair}, and returns
     *               {@code true} to trigger its removal and {@code false} to ensure it is kept.
     * @return An updated {@link Association} where elements are removed according to the
     *         supplied predicate test, or this instance if nothing was removed.
     * @throws NullPointerException - if the specified filter is null
     */
    default Association&lt;K,V&gt; removeIf( Predicate&lt;Pair&lt;K,V&gt;&gt; filter ) {
<span class="fc" id="L1325">        Objects.requireNonNull(filter);</span>
<span class="fc" id="L1326">        return removeAll(entrySet().stream().filter(filter).map(Pair::first));</span>
    }

    /**
     *  Returns a new association where only those key-value pairs
     *  are kept that have a key present in the supplied value set.
     *  If the supplied set is empty, then this association is
     *  returned unchanged.
     *
     * @param keys The keys to retain in this association.
     * @return A new association with only the keys in the given set.
     */
    default Association&lt;K, V&gt; retainAll( ValueSet&lt;? extends K&gt; keys ) {
<span class="pc bpc" id="L1339" title="2 of 4 branches missed.">        if ( this.isEmpty() || keys.isEmpty() )</span>
<span class="nc" id="L1340">            return this;</span>
<span class="fc" id="L1341">        Association&lt;K, V&gt; result = this;</span>
<span class="fc bfc" id="L1342" title="All 2 branches covered.">        for ( K key : this.keySet() ) {</span>
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">            if ( !((ValueSet&lt;K&gt;)keys).contains(key) ) {</span>
<span class="nc" id="L1344">                result = result.remove(key);</span>
            }
<span class="fc" id="L1346">        }</span>
<span class="fc" id="L1347">        return result;</span>
    }

    /**
     *  Returns a new association where only those key-value pairs
     *  are kept that have a key present in the supplied set. If the
     *  supplied set is empty, then this association is returned
     *  unchanged.
     *
     * @param keys The keys to retain in this association.
     * @return A new association with only the keys in the given set.
     */
    default Association&lt;K, V&gt; retainAll(Set&lt;? extends K&gt; keys) {
<span class="pc bpc" id="L1360" title="1 of 4 branches missed.">        if ( this.isEmpty() || keys.isEmpty() )</span>
<span class="fc" id="L1361">            return this;</span>
<span class="fc" id="L1362">        Association&lt;K, V&gt; result = this;</span>
<span class="fc bfc" id="L1363" title="All 2 branches covered.">        for ( K key : this.keySet() ) {</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">            if ( !keys.contains(key) ) {</span>
<span class="fc" id="L1365">                result = result.remove(key);</span>
            }
<span class="fc" id="L1367">        }</span>
<span class="fc" id="L1368">        return result;</span>
    }

    /**
     *  Returns a completely empty association but
     *  with the same key and value types as this one.
     *
     * @return A new association without any key-value pairs,
     *         or this association if it is already empty.
     */
    Association&lt;K, V&gt; clear();

    /**
     *  Returns a new association that is the same as this one
     *  but with the keys sorted based on the provided {@link Comparator}.
     *
     * @param comparator The comparator to use for sorting the keys in the returned association.
     * @return A new association with the keys sorted
     *        based on the provided comparator.
     */
    default Association&lt;K,V&gt; sort( Comparator&lt;K&gt; comparator ) {
<span class="fc" id="L1389">        Objects.requireNonNull(comparator, &quot;The provided comparator cannot be null.&quot;);</span>
<span class="fc" id="L1390">        return Sprouts.factory().associationOfSorted(this.keyType(), this.valueType(), comparator)</span>
<span class="fc" id="L1391">                .putAll((Stream) this.entrySet().stream());</span>
    }

    /**
     *  Converts this association to a java.util.Map.
     *  Note that the returned map is also immutable.
     *
     * @return A java.util.Map representation of this association.
     */
    default Map&lt;K, V&gt; toMap() {
<span class="fc" id="L1401">        return new AbstractMap&lt;K, V&gt;() {</span>
            @Override
            public V get(Object key) {
<span class="pc bpc" id="L1404" title="1 of 2 branches missed.">                if (key == null) {</span>
<span class="nc" id="L1405">                    throw new NullPointerException(&quot;Null key&quot;);</span>
                }
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">                if (!keyType().isAssignableFrom(key.getClass())) {</span>
<span class="nc" id="L1408">                    throw new ClassCastException(&quot;Key type mismatch&quot;);</span>
                }
<span class="fc" id="L1410">                return Association.this.get((K) key).orElseThrow(</span>
<span class="nc" id="L1411">                        () -&gt; new NoSuchElementException(&quot;Key not found&quot;)</span>
                );
            }
            @Override
            public boolean containsKey(Object key) {
<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">                if (key == null) {</span>
<span class="nc" id="L1417">                    throw new NullPointerException(&quot;Null key&quot;);</span>
                }
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">                if (!keyType().isAssignableFrom(key.getClass())) {</span>
<span class="nc" id="L1420">                    throw new ClassCastException(&quot;Key type mismatch&quot;);</span>
                }
<span class="fc" id="L1422">                return Association.this.containsKey((K) key);</span>
            }
            @Override
            public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc" id="L1426">                return new AbstractSet&lt;Entry&lt;K, V&gt;&gt;() {</span>
                    @Override
                    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L1429">                        return new Iterator&lt;Entry&lt;K, V&gt;&gt;() {</span>
<span class="fc" id="L1430">                            private final Iterator&lt;Pair&lt;K, V&gt;&gt; _iterator = Association.this.iterator();</span>

                            @Override
                            public boolean hasNext() {
<span class="fc" id="L1434">                                return _iterator.hasNext();</span>
                            }

                            @Override
                            public Entry&lt;K, V&gt; next() {
<span class="fc" id="L1439">                                Pair&lt;K, V&gt; pair = _iterator.next();</span>
<span class="fc" id="L1440">                                return new SimpleEntry&lt;&gt;(pair.first(), pair.second());</span>
                            }
                        };
                    }

                    @Override
                    public int size() {
<span class="fc" id="L1447">                        return Association.this.size();</span>
                    }
                };
            }
        };
    }

    /**
     *  Checks if any of the key-value pairs in this association match the given predicate
     *  and returns {@code true} if any of them do, otherwise {@code false}.
     *  @param predicate The predicate to check.
     *  @return True if any of the key-value pairs in this association match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean any( Predicate&lt;Pair&lt;K,V&gt;&gt; predicate ) {
<span class="nc" id="L1462">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1463">        return this.entrySet().stream().anyMatch( predicate );</span>
    }

    /**
     *  Checks if all the key-value pairs in this association match the given predicate
     *  and returns {@code true} if all of them do, otherwise {@code false}.
     *  @param predicate The predicate to check.
     *  @return True if all the key-value pairs in this association match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean all( Predicate&lt;Pair&lt;K,V&gt;&gt; predicate ) {
<span class="nc" id="L1474">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1475">        return this.entrySet().stream().allMatch( predicate );</span>
    }

    /**
     *  Checks if none of the key-value pairs in this association match the given predicate
     *  and returns {@code true} if none of them do, otherwise {@code false}.
     *  @param predicate The predicate to run over all key-value pairs.
     *  @return True if none of the key-value pairs in this association match the given predicate.
     *  @throws NullPointerException if the predicate is {@code null}.
     */
    default boolean none( Predicate&lt;Pair&lt;K,V&gt;&gt; predicate ) {
<span class="nc" id="L1486">        Objects.requireNonNull(predicate);</span>
<span class="nc" id="L1487">        return this.entrySet().stream().noneMatch( predicate );</span>
    }

    /**
     * Compares the specified object with this association for value equality.
     * Returns {@code true} only if the specified object is also an association with the same {@link #size()},
     * {@link #keyType()}, {@link #valueType()}, and where every key value pair in the specified
     * association is contained in this association
     * (or equivalently, every member of this association is contained in the specified association).
     * &lt;b&gt;Additionally, two associations must also report the same values for {@link #isLinked()} and {@link #isSorted()}.&lt;/b&gt;
     * This definition ensures that the equals method works properly across different
     * implementations of the association interface.
     *
     * @param o object to be compared for equality with this association
     * @return {@code true} if the specified object is equal to this association in terms of value semantic.
     */
    @Override
    boolean equals( Object o );

    /**
     * Returns the hash code value for this association. The hash code of an association is
     * defined to be the sum of the hash codes of the pairs in the association.
     * This ensures that {@code a1.equals(a2)} implies that
     * {@code a1.hashCode()==a2.hashCode()} for any two associations {@code a1}
     * and {@code a2}, as required by the general contract of
     * {@link Object#hashCode}.
     *
     * @return The hash code value for this association as a 32-bit integer,
     *         based on the sum of the hash codes of all pairs in this association.
     * @see Object#equals(Object)
     * @see Map#equals(Object)
     */
    @Override
    int hashCode();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>