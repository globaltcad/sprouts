<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Val.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">Val.java</span></div><h1>Val.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import sprouts.impl.Sprouts;

import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.regex.Pattern;

/**
 * 	A read only view on a wrapped item which can be observed for changes
 * 	using {@link Action}s registered through the {@link #onChange(Channel, Action)} method,
 * 	where the {@link Channel} is used to distinguish between changes from
 * 	different sources (usually application layers like the view model or the view).
 * 	The API of this is very similar to the {@link Optional} API in the
 * 	sense that it is a null safe wrapper around a single item, which may also be missing (null).
 * 	&lt;p&gt;
 * 	The {@link Channel} supplied to the {@link #onChange(Channel, Action)} method to register an {@link Action}
 * 	callback is expected to be a simple constant, usually one of the {@link From} constants
 * 	like for example {@link From#VIEW_MODEL} or {@link From#VIEW}.
 * 	You may fire a change event for a particular channel using the {@link #fireChange(Channel)} method or
 * 	in case the property is also a mutable {@link Var}, then through the {@link Var#set(Channel, Object)}.&lt;br&gt;
 * 	Note that {@link Var#set(Object)} method defaults to the {@link From#VIEW_MODEL} channel.
 * 	&lt;p&gt;
 * 	If you no longer need to observe changes on this property, then you can remove the registered {@link Action}
 * 	callback using the {@link #unsubscribe(Subscriber)} method ({@link Action} is also a {@link Subscriber}).
 * 	&lt;p&gt;
 * 	Note that the name of this class is short for &quot;value&quot;. This name was deliberately chosen because
 * 	it is short, concise and yet clearly conveys the same meaning as other names used to model this
 * 	kind of pattern, like &quot;property&quot;, &quot;observable object&quot;, &quot;observable value&quot;, &quot;observable property&quot;, etc.
 *  Using {@link Var} and {@link Val} as names also allows for the distinction between
 *  mutable and immutable properties without having to resort to prefixes like &quot;mutable&quot; or &quot;immutable&quot;
 *  as part of types that are supposed to be used everywhere in your code.
 * 	&lt;p&gt;
 * 	&lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/sprouts/&quot;&gt;living sprouts documentation&lt;/a&gt;
 * 	where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *
 * @see Var A mutable subclass of this class.
 * @param &lt;T&gt; The type of the item held by this {@link Val}.
 */
public interface Val&lt;T extends @Nullable Object&gt; extends Observable {
	String NO_ID = &quot;&quot;; // This is the default id for properties
	String EMPTY = &quot;EMPTY&quot;; // This is the default string for empty properties
<span class="fc" id="L51">	Pattern ID_PATTERN = Pattern.compile(&quot;[a-zA-Z0-9_]*&quot;);</span>
<span class="fc" id="L52">	From DEFAULT_CHANNEL = From.VIEW_MODEL;</span>

	/**
	 *  Use this factory method to create a new {@link Val} instance
	 *  whose item may or may not be null.
	 *  &lt;p&gt;
	 *  &lt;b&gt;Example:&lt;/b&gt;
	 *  &lt;pre&gt;{@code
	 *      Val.ofNullable(String.class, null);
	 *  }&lt;/pre&gt;
	 *  &lt;p&gt;
	 * @param type The type of the item wrapped by the property.
	 *             This is used to check if the item is of the correct type.
	 * @param item The initial item of the property.
	 *              This may be null.
	 * @param &lt;T&gt; The type of the wrapped item.
	 * @return A new {@link Val} instance.
	 */
	static &lt;T&gt; Val&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, @Nullable T item ) {
<span class="fc" id="L71">		return Sprouts.factory().valOfNullable( type, item );</span>
	}

	/**
	 *  A more concise version of {@link #ofNullable(Class, Object)}
	 *  which is equivalent to {@code Var.ofNullable(type, null)}. &lt;br&gt;
	 *  The {@link Val} instances returned by this factory method, are nullable, which
	 *  means their {@link #allowsNull()} method will always yield {@code true}.
	 *
	 * @param type The type of the item wrapped by the property.
	 * @return A new {@link Val} instance.
	 * @param &lt;T&gt; The type of the wrapped item.
	 */
	static &lt;T&gt; Val&lt;@Nullable T&gt; ofNull( Class&lt;T&gt; type ) {
<span class="nc" id="L85">		return Sprouts.factory().valOfNull( type );</span>
	}

	/**
	 * 	This factory method returns a {@code Val} describing the given non-{@code null}
	 * 	item similar to {@link Optional#of(Object)}, but specifically
	 * 	designed for use with Swing-Tree.
	 *
	 * @param item The initial item of the property which must not be null.
	 * @param &lt;T&gt; The type of the item held by the {@link Val}!
	 * @return A new {@link Val} instance wrapping the given item.
	 */
	static &lt;T&gt; Val&lt;T&gt; of( T item ) {
<span class="fc" id="L98">		return Sprouts.factory().valOf( item );</span>
	}

	/**
	 *  A factory method for creating a new {@link Val} instance
	 *  which is effectively an immutable copy of the given {@link Val}.
	 *  The provided {@link Val} must not contain a null item.
	 *
	 * @param toBeCopied The {@link Val} to be copied.
	 * @return A new {@link Val} instance.
	 * @param &lt;T&gt; The type of the item held by the {@link Val}!
	 */
	static &lt;T&gt; Val&lt;T&gt; of( Val&lt;T&gt; toBeCopied ) {
<span class="fc" id="L111">		Objects.requireNonNull(toBeCopied);</span>
<span class="fc" id="L112">		return Sprouts.factory().valOf( toBeCopied );</span>
	}

	/**
	 *  A factory method for creating a new {@link Val} instance
	 *  which is effectively an immutable copy of the given {@link Val}.
	 *  The provided {@link Val} may contain a null item.
	 *
	 * @param toBeCopied The {@link Val} to be copied.
	 * @return A new {@link Val} instance.
	 * @param &lt;T&gt; The type of the item held by the {@link Val}!
	 */
	static &lt;T extends @Nullable Object&gt; Val&lt;@Nullable T&gt; ofNullable( Val&lt;T&gt; toBeCopied ) {
<span class="fc" id="L125">		Objects.requireNonNull(toBeCopied);</span>
<span class="fc" id="L126">		return Sprouts.factory().valOfNullable( toBeCopied );</span>
	}

	/**
	 * Creates a read-only {@link Val} property that represents a live view of the two given properties using a
	 * combiner function.
	 * &lt;p&gt;
	 * The combiner function takes the items of the two properties and returns an updated item based on them.
	 * The combiner is called to compute a new item for the view property whenever at least one of the items
	 * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
	 * on either of the two properties.
	 * &lt;p&gt;
	 * Note: The property view does &lt;b&gt;not&lt;/b&gt; allow storing {@code null} references!
	 * So if the combiner function returns a {@code null} reference or throws an exception on the first call,
	 * a {@link NullPointerException} will be thrown.
	 * If a {@code null} reference is returned on subsequent calls, the view will log a warning and simply retain the
	 * last non-null value!
	 * &lt;p&gt;
	 * If you need a composite view that allows {@code null}, use the {@link #viewOfNullable(Val, Val, BiFunction)}
	 * method instead.
	 *
	 * @param first    The first property to be combined.
	 * @param second   The second property to be combined.
	 * @param combiner The function used to combine the items of the two properties,
	 *                 where the first argument is the item of the first property and
	 *                 the second argument is the item of the second property.
	 * @param &lt;T&gt;      The type of the item of the first property and the returned property.
	 * @param &lt;U&gt;      The type of the second property.
	 * @return A new {@link Val} instance which is a live view of the two given properties.
	 * @throws NullPointerException If the combiner function returns a {@code null} reference
	 *                              &lt;b&gt;when it is first called&lt;/b&gt;.
	 */
	static &lt;T extends @Nullable Object, U extends @Nullable Object&gt; Val&lt;@NonNull T&gt; viewOf(Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, @NonNull T&gt; combiner ) {
<span class="fc" id="L159">		Objects.requireNonNull(first);</span>
<span class="fc" id="L160">		Objects.requireNonNull(second);</span>
<span class="fc" id="L161">		Objects.requireNonNull(combiner);</span>
<span class="fc" id="L162">		return Sprouts.factory().viewOf( first, second, combiner );</span>
	}

	/**
	 * Creates a read-only nullable {@link Val} property that represents a live view of the two given properties using a
	 * combiner function.
	 * &lt;p&gt;
	 * The combiner function takes the items of the two properties and returns an updated item based on them.
	 * The combiner is called to compute a new item for the view property whenever at least one of the items
	 * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
	 * on either of the two properties.
	 * &lt;p&gt;
	 * Note: The property view does &lt;b&gt;allow&lt;/b&gt; storing {@code null} references!
	 * If the combiner function throws an exception, the view will be set to {@code null}.
	 * &lt;p&gt;
	 * If you need a composite view that does not allow {@code null}, use the {@link #viewOf(Val, Val, BiFunction)}
	 * method instead.
	 *
	 * @param first    The first property to be combined.
	 * @param second   The second property to be combined.
	 * @param combiner The function used to combine the items of the two properties,
	 *                 where the first argument is the item of the first property and
	 *                 the second argument is the item of the second property.
	 * @param &lt;T&gt;      The type of the item of the first property and the returned property.
	 * @param &lt;U&gt;      The type of the second property.
	 * @return A new nullable {@link Val} instance which is a live view of the two given properties.
	 */
	static &lt;T extends @Nullable Object, U extends @Nullable Object&gt; Val&lt;@Nullable T&gt; viewOfNullable(Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, @Nullable T&gt; combiner ) {
<span class="fc" id="L190">		Objects.requireNonNull(first);</span>
<span class="fc" id="L191">		Objects.requireNonNull(second);</span>
<span class="fc" id="L192">		Objects.requireNonNull(combiner);</span>
<span class="fc" id="L193">		return Sprouts.factory().viewOfNullable( first, second, combiner );</span>
	}

	/**
	 * Creates a read-only {@link Val} property that represents a live view of the two given properties using a
	 * combiner function.
	 * &lt;p&gt;
	 * The combiner function takes the items of the two properties and returns an updated item based on them.
	 * The combiner is called to compute a new item for the view property whenever at least one of the items
	 * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
	 * on either of the two properties.
	 * &lt;p&gt;
	 * Note: The property view does &lt;b&gt;not&lt;/b&gt; allow storing {@code null} references!
	 * So if the combiner function returns a {@code null} reference on the first call, a {@link NullPointerException}
	 * will be thrown.
	 * If a {@code null} reference is returned on subsequent calls, the view will log a warning and simply retain the
	 * last non-null value!
	 * &lt;p&gt;
	 * If you need a composite view that allows {@code null}, use the {@link #viewOfNullable(Class, Val, Val, BiFunction)}
	 * method instead.
	 *
	 * @param type     The type of the item returned from the mapping function.
	 * @param first    The first property to be combined.
	 * @param second   The second property to be combined.
	 * @param combiner The function used to combine the items of the two properties,
	 *                 where the first argument is the item of the first property and
	 *                 the second argument is the item of the second property.
	 * @param &lt;T&gt;      The type of the first property.
	 * @param &lt;U&gt;      The type of the second property.
	 * @param &lt;R&gt;      The type of the returned property.
	 * @return A new {@link Val} instance which is a live view of the two given properties.
	 * @throws NullPointerException If the combiner function returns a {@code null} reference
	 *                              &lt;b&gt;when it is first called&lt;/b&gt;.
	 */
	static &lt;T extends @Nullable Object, U extends @Nullable Object, R&gt; Val&lt;R&gt; viewOf(Class&lt;R&gt; type, Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, R&gt; combiner ) {
<span class="fc" id="L228">		Objects.requireNonNull(type);</span>
<span class="fc" id="L229">		Objects.requireNonNull(first);</span>
<span class="fc" id="L230">		Objects.requireNonNull(second);</span>
<span class="fc" id="L231">		Objects.requireNonNull(combiner);</span>
<span class="fc" id="L232">		return Sprouts.factory().viewOf( type, first, second, combiner );</span>
	}

	/**
	 * Creates a read-only nullable {@link Val} property that represents a live view of the two given properties using a
	 * combiner function.
	 * &lt;p&gt;
	 * The combiner function takes the items of the two properties and returns an updated item based on them.
	 * The combiner is called to compute a new item for the view property whenever at least one of the items
	 * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
	 * on either of the two properties.
	 * &lt;p&gt;
	 * Note: The property view does &lt;b&gt;allow&lt;/b&gt; storing {@code null} references!
	 * If the combiner function throws an exception, the view will be set to {@code null}.
	 * &lt;p&gt;
	 * If you need a composite view that not allows {@code null}, use the {@link #viewOf(Class, Val, Val, BiFunction)}
	 * method instead.
	 *
	 * @param type     The type of the item returned from the mapping function.
	 * @param first    The first property to be combined.
	 * @param second   The second property to be combined.
	 * @param combiner The function used to combine the items of the two properties,
	 *                 where the first argument is the item of the first property and
	 *                 the second argument is the item of the second property.
	 * @param &lt;T&gt;      The type of the first property.
	 * @param &lt;U&gt;      The type of the second property.
	 * @param &lt;R&gt;      The type of the returned property.
	 * @return A new {@link Val} instance which is a live view of the two given properties.
	 */
	static &lt;T extends @Nullable Object, U extends @Nullable Object, R&gt; Val&lt;@Nullable R&gt; viewOfNullable(Class&lt;R&gt; type, Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, @Nullable R&gt; combiner ) {
<span class="fc" id="L262">		Objects.requireNonNull(type);</span>
<span class="fc" id="L263">		Objects.requireNonNull(first);</span>
<span class="fc" id="L264">		Objects.requireNonNull(second);</span>
<span class="fc" id="L265">		Objects.requireNonNull(combiner);</span>
<span class="fc" id="L266">		return Sprouts.factory().viewOfNullable( type, first, second, combiner );</span>
	}

	/**
	 * This method is intended to be used for when you want to wrap non-nullable types.
	 * So if an item is present (not null), it returns the item, otherwise however
	 * {@code NoSuchElementException} will be thrown.
	 * If you simply want to get the item of this property irrespective of
	 * it being null or not, use {@link #orElseNull()} to avoid an exception.
	 * However, if this property wraps a nullable type, which is not intended to be null,
	 * please use {@link #orElseThrow()} to make this intention clear.
	 * The {@link #orElseThrow()} method is functionally identical to this method.
	 *
	 * @return the non-{@code null} item described by this {@code Val}
	 * @throws NoSuchElementException if no item is present
	 */
<span class="fc" id="L282">	default @NonNull T get() { return orElseThrow(); }</span>

	/**
	 * If an item is present, returns the item, otherwise returns
	 * {@code other}.
	 *
	 * @param other the item to be returned, if no item is present.
	 *        May be {@code null}.
	 * @return the item, if present, otherwise {@code other}
	 */
	default @Nullable T orElseNullable( @Nullable T other ) {
<span class="nc bnc" id="L293" title="All 2 branches missed.">		return orElseNull() != null ? Objects.requireNonNull(orElseNull()) : other;</span>
	}

	/**
	 * If an item is present, returns the item, otherwise returns
	 * {@code other}.
	 *
	 * @param other the item to be returned, if no item is present.
	 *        May not be {@code null}.
	 * @return the item, if present, otherwise {@code other}
	 */
	default @NonNull T orElse( @NonNull T other ) {
<span class="fc" id="L305">		Objects.requireNonNull(other);</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">		return isPresent() ? get() : other;</span>
	}

	/**
	 * If an item is present, returns the item, otherwise returns the result
	 * produced by the supplying function.
	 *
	 * @param supplier the supplying function that produces an item to be returned
	 * @return the item, if present, otherwise the result produced by the
	 *         supplying function
	 * @throws NullPointerException if no item is present and the supplying
	 *         function is {@code null}
	 */
	default T orElseGet( Supplier&lt;? extends T&gt; supplier ) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">		return this.isPresent() ? orElseThrow() : supplier.get();</span>
	}

	/**
	 * If an item is present, returns the item, otherwise returns
	 * {@code null}.
	 *
	 * @return the item, if present, otherwise {@code null}
	 */
	@Nullable T orElseNull();

	/**
	 * If an item is present, returns the item, otherwise throws
	 * {@code NoSuchElementException}.
	 *
	 * @return the non-{@code null} item described by this {@code Val}
	 * @throws NoSuchElementException if no item is present
	 */
	default @NonNull T orElseThrow() {
		// This class is similar to optional, so if the value is null, we throw an exception!
<span class="fc" id="L340">		T value = orElseNull();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">		if ( Objects.isNull(value) )</span>
<span class="fc" id="L342">			throw new NoSuchElementException(&quot;No value present&quot;);</span>
<span class="fc" id="L343">		return value;</span>
	}

	/**
	 * If an item is present, returns {@code true}, otherwise {@code false}.
	 *
	 * @return {@code true} if an item is present, otherwise {@code false}
	 */
<span class="fc bfc" id="L351" title="All 2 branches covered.">	default boolean isPresent() { return orElseNull() != null; }</span>

	/**
	 * If an item is  not present, returns {@code true}, otherwise
	 * {@code false}.
	 *
	 * @return  {@code true} if an item is not present, otherwise {@code false}
	 */
	default boolean isEmpty() {
<span class="fc bfc" id="L360" title="All 2 branches covered.">		return !isPresent();</span>
	}

	/**
	 *  Creates and returns a boolean property which is a live view of the {@link #isPresent()}
	 *  flag of this property.
	 *
	 * @return A live view of the presence of an item in this property in the form
	 *         of a {@link Boolean} property.
	 *         So whenever the {@link #isPresent()} flag of this property changes,
	 *         the item of the returned property will be updated to reflect the change.
	 */
	default Val&lt;Boolean&gt; viewIsPresent() {
<span class="fc bfc" id="L373" title="All 2 branches covered.">		if ( !this.allowsNull() )</span>
<span class="fc" id="L374">			return Val.of( true );</span>
<span class="fc" id="L375">		return viewAs(Boolean.class, Objects::nonNull);</span>
	}

	/**
	 *  Creates and returns a boolean property which is a live view of the {@link #isEmpty()}
	 *  flag of this property.
	 *
	 * @return A live view of the absence of an item in this property in the form
	 *         of a {@link Boolean} property.
	 *         So whenever the {@link #isEmpty()} flag of this property changes,
	 *         the item of the returned property will be updated to reflect the change.
	 */
	default Val&lt;Boolean&gt; viewIsEmpty() {
<span class="fc bfc" id="L388" title="All 2 branches covered.">		if ( !this.allowsNull() )</span>
<span class="fc" id="L389">			return Val.of( false );</span>
		else
<span class="fc" id="L391">			return viewAs(Boolean.class, Objects::isNull);</span>
	}

	/**
	 * If an item is present, performs the given action with the item,
	 * otherwise does nothing.
	 *
	 * @param action the action to be performed, if an item is present
	 * @throws NullPointerException if item is present and the given action is
	 *         {@code null}
	 */
	default void ifPresent( Consumer&lt;T&gt; action ) {
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">		if ( this.isPresent() )</span>
<span class="fc" id="L404">			action.accept( get() );</span>
<span class="fc" id="L405">	}</span>

	/**
	 * If an item is present, performs the given action with the item,
	 * otherwise performs the given empty-based action.
	 *
	 * @param action the action to be performed, if an item is present
	 * @param emptyAction the empty-based action to be performed, if no item is
	 *        present
	 * @throws NullPointerException if an item is present and the given action
	 *         is {@code null}, or no item is present and the given empty-based
	 *         action is {@code null}.
	 */
	default void ifPresentOrElse( Consumer&lt;? super T&gt; action, Runnable emptyAction ) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">		if ( isPresent() )</span>
<span class="nc" id="L420">			action.accept(get());</span>
<span class="nc" id="L421">		emptyAction.run();</span>
<span class="nc" id="L422">	}</span>

	/**
	 * If an item is present, returns a {@code Val} describing the item,
	 * otherwise returns a {@code Val} produced by the supplying function.
	 *
	 * @param supplier the supplying function that produces a {@code Val}
	 *        to be returned
	 * @return returns a {@code Val} describing the item of this
	 *         {@code Val}, if an item is present, otherwise a
	 *         {@code Val} produced by the supplying function.
	 * @throws NullPointerException if the supplying function is {@code null} or
	 *         produces a {@code null} result
	 */
	default Val&lt;T&gt; or( Supplier&lt;? extends Val&lt;? extends T&gt;&gt; supplier ) {
<span class="nc" id="L437">		Objects.requireNonNull(supplier);</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">		if ( isPresent() )</span>
<span class="nc" id="L439">			return this;</span>

		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L442">		Val&lt;T&gt; r = (Val&lt;T&gt;) supplier.get();</span>
<span class="nc" id="L443">		Objects.requireNonNull(r);</span>
<span class="nc" id="L444">		return r;</span>
	}

	/**
	 *  If the item is present, applies the provided mapping function to it,
	 *  and returns it wrapped in a new {@link Val} instance. &lt;br&gt;
	 *  If the item is not present, then an empty {@link Val} instance is returned. &lt;br&gt;
	 *  &lt;p&gt;
	 *  But note that the resulting property does not constitute a live view of this property
	 *  and will not be updated when this property changes. &lt;br&gt;
	 *  It is functionally very similar to the {@link Optional#map(Function)} method. &lt;br&gt;
	 *  &lt;p&gt;
	 *  &lt;b&gt;
	 *      If you want to map to a property which is an automatically updated live view of this property,
	 *      then use the {@link #view(Function)} method instead.
	 *  &lt;/b&gt;
	 *  This is essentially the same as {@link Optional#map(Function)} but based on {@link Val}
	 *  as the wrapper instead of {@link Optional}.
	 *
	 * @param mapper the mapping function to apply to an item, if present
	 * @return A new property either empty (containing null) or containing the result of applying
	 * 			the mapping function to the item of this property.
	 */
	Val&lt;T&gt; map( Function&lt;T, T&gt; mapper );

	/**
	 *  If the item is present, applies the provided mapping function to it,
	 *  and returns it wrapped in a new {@link Val} instance. &lt;br&gt;
	 *  If the item is not present, then an empty {@link Val} instance is returned. &lt;br&gt;
	 *  &lt;p&gt;
	 *  But note that the resulting property does not constitute a live view of this property
	 *  and will not be updated when this property changes. &lt;br&gt;
	 *  It is functionally very similar to the {@link Optional#map(Function)} method. &lt;br&gt;
	 *  &lt;p&gt;
	 *  &lt;b&gt;
	 *      If you want to map to a property which is an automatically updated live view of this property,
	 *      then use the {@link #viewAs(Class, Function)} method instead.
	 *  &lt;/b&gt;
	 *
	 * @param type The type of the item returned from the mapping function
	 * @param mapper the mapping function to apply to an item, if present
	 * @return A new property either empty (containing null) or containing the result of applying
	 * 			the mapping function to the item of this property.
	 * @param &lt;U&gt; The type of the item returned from the mapping function
	 */
	&lt;U&gt; Val&lt;U&gt; mapTo( Class&lt;U&gt; type, java.util.function.Function&lt;T, U&gt; mapper );

	/**
	 * Use this to create a live view of this property through a new property based on the provided mapping function.
	 * So whenever the value of this property changes, the value of the new property will be updated based on the
	 * mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function is not allowed to map to {@code null}, but may need to handle {@code null}.
	 * Null must be mapped to an appropriate null object.
	 * &lt;p&gt;
	 * The result is a non-nullable view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param type   The type of the item returned from the mapping function
	 * @param mapper the mapping function to apply to an item, if present
	 * @param &lt;U&gt;    The type of the item returned from the mapping function
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default &lt;U&gt; Val&lt;U&gt; viewAs( Class&lt;U&gt; type, Function&lt;T, U&gt; mapper ) {
<span class="fc" id="L509">		final Var&lt;U&gt; viewProperty = Var.of(type, mapper.apply(orElseNull()));</span>
<span class="fc" id="L510">		onChange(Util.VIEW_CHANNEL, Action.ofWeak(viewProperty, (innerViewProperty, v) -&gt; {</span>
<span class="fc" id="L511">			innerViewProperty.set(mapper.apply(v.orElseNull()));</span>
<span class="fc" id="L512">		}));</span>
<span class="fc" id="L513">		return viewProperty;</span>
	}

	/**
	 * Use this to create a live view of this property through a new property based on the provided mapping function.
	 * So whenever the item of this property changes, the item of the new property will be updated based on the
	 * mapping function and null object.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null} or throws an exception, the view will contain the proved
	 * null object.
	 * &lt;p&gt;
	 * The result is a non-nullable view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param nullObject The null object to use if no item is present.
	 * @param mapper     The mapping function to apply to an item.
	 * @param &lt;U&gt;        The type of the resulting property.
	 * @return A property that is a live view of this property based on the provided mapping function and null object.
	 */
	default &lt;U&gt; Val&lt;U&gt; view( U nullObject, Function&lt;T, @Nullable U&gt; mapper ) {
<span class="fc" id="L535">		return view(nullObject, nullObject, mapper);</span>
	}

	/**
	 * Use this to create a live view of this property through a new property based on the provided mapping function.
	 * So whenever the item of this property changes, the item of the new property will be updated based on the
	 * mapping function and null object.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null}, the view will contain the proved null object.
	 * If the mapping function throws an exception, the view will contain the proved error object.
	 * &lt;p&gt;
	 * The result is a non-nullable view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param nullObject  The null object to use if no item is present.
	 * @param errorObject The error object to use if an error occurs.
	 * @param mapper      The mapping function to apply to an item.
	 * @param &lt;U&gt;         The type of the resulting property.
	 * @return A property that is a live view of this property based on the provided mapping function and null object.
	 */
	default &lt;U&gt; Val&lt;U&gt; view( U nullObject, U errorObject, Function&lt;T, @Nullable U&gt; mapper ) {
<span class="fc" id="L558">		Objects.requireNonNull(nullObject);</span>
<span class="fc" id="L559">		Objects.requireNonNull(errorObject);</span>

<span class="fc" id="L561">		Function&lt;T, U&gt; nonNullMapper = Util.nonNullMapper(nullObject, errorObject, mapper);</span>

<span class="fc" id="L563">		final U initial = nonNullMapper.apply(orElseNull());</span>
<span class="fc" id="L564">		final Var&lt;U&gt; viewProperty = Var.of( initial );</span>

<span class="fc" id="L566">		onChange(Util.VIEW_CHANNEL, Action.ofWeak( viewProperty, (innerViewProperty, v) -&gt; {</span>
<span class="fc" id="L567">			final U value = nonNullMapper.apply(orElseNull());</span>
<span class="fc" id="L568">			innerViewProperty.set( value );</span>
<span class="fc" id="L569">		}));</span>
<span class="fc" id="L570">		return viewProperty;</span>
	}


	/**
	 * Use this to create a nullable live view of this property through a new property based on the provided mapping
	 * function.
	 * So whenever the value of this property changes, the value of the new property will be updated based on the
	 * mapping function.
	 *
	 * @param type   The type of the value returned from the mapping function
	 * @param mapper The mapping function to apply to a value
	 * @param &lt;U&gt;    The type of the resulting property.
	 * @return A nullable property that is a live view of this property based on the provided mapping function.
	 */
	default &lt;U&gt; Val&lt;@Nullable U&gt; viewAsNullable( Class&lt;U&gt; type, Function&lt;T, @Nullable U&gt; mapper ) {
<span class="fc" id="L586">		final Var&lt;@Nullable U&gt; viewProperty = Var.ofNullable(type, mapper.apply(orElseNull()));</span>
<span class="fc" id="L587">		onChange(Util.VIEW_CHANNEL, Action.ofWeak( viewProperty, (innerViewProperty, v) -&gt; {</span>
<span class="nc" id="L588">			innerViewProperty.set(mapper.apply(v.orElseNull()));</span>
<span class="nc" id="L589">		}));</span>
<span class="fc" id="L590">		return viewProperty;</span>
	}

	/**
	 * 	Use this to create a live view of this property
	 * 	based on a mapping function which maps the item of this property to an item of the same type as this property.
	 * 	So whenever the item of this property changes, the item of the new property
	 * 	will be updated based on the mapping function.
	 * 	If you want to create a live view of a different type, use the {@link #viewAs(Class, Function)}
	 * 	method instead.
	 * 	&lt;p&gt;
	 * 	Note that this method will try to map value based item types like
	 * 	{@link String}, {@link Integer}, {@link Double}, etc.
	 * 	to the default value (or &quot;null object&quot;) of their respective types,
	 * 	if the provided mapping function returns a null reference.&lt;br&gt;
	 * 	So if the type of this property is a {@link String}, and the mapping function returns a null reference,
	 * 	then the resulting view property will always contain an empty string and
	 * 	its {@link #allowsNull()} method will always return false.
	 * 	&lt;p&gt;
	 * 	Also note that a property view may only contain null if the property it is based on
	 * 	was created with the &quot;ofNullable(...)&quot; factory method
	 * 	(in which case its {@link #allowsNull()} method will return true).
	 * 	Otherwise, it will throw an exception when trying to map a null reference.
	 *
	 * @param mapper the mapping function to apply to an item, if present
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;T&gt; view( Function&lt;T, T&gt; mapper ) {
<span class="fc" id="L618">		return viewAs( type(), mapper );</span>
	}

	/**
	 * Use this to create a {@link String} based live view of this property through a new property based on the
	 * provided mapping function and null object.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null} or throws an exception, the view will contain the proved
	 * null object.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link String} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param nullObject The null object to use if the mapping function returns {@code null}.
	 * @param mapper The mapping function to map the item of this property to a {@link String}.
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;String&gt; viewAsString( String nullObject, Function&lt;T, @Nullable String&gt; mapper ) {
<span class="nc" id="L640">		Objects.requireNonNull(nullObject);</span>
<span class="nc" id="L641">		return view(nullObject, nullObject, mapper);</span>
	}

	/**
	 * Use this to create a {@link String} based live view of this property through a new property based on the
	 * provided mapping function.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null} or throws an exception, the view will contain the
	 * &quot;null object&quot; of the {@link String} type, which is an empty string.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link String} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param mapper The mapping function to map the item of this property to a {@link String}.
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;String&gt; viewAsString( Function&lt;T, @Nullable String&gt; mapper ) {
<span class="fc" id="L662">		return view(&quot;&quot;, &quot;&quot;, mapper);</span>
	}

	/**
	 * Use this to create a {@link String} based live view of this property through a new property based on the
	 * {@link Object#toString()} method used as the mapping function.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the {@link Object#toString()} mapping function.
	 * &lt;p&gt;
	 * Note: {@code null} references within the viewed property will always be mapped to the &quot;null object&quot; of the
	 * {@link String} type, which is an empty string.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link String} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;String&gt; viewAsString() {
<span class="fc bfc" id="L681" title="All 2 branches covered.">		return view(&quot;&quot;, &quot;&quot;, v -&gt; v == null ? null  : v.toString());}</span>

	/**
	 * Use this to create a {@link Double} based live view of this property through a new property based on the
	 * provided mapping function and null object.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null}, the view will contain the provided null object.
	 * If the mapping function throws an exception, the view will contain {@code Double.NaN}.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link Double} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param nullObject The null object to use if the mapping function returns {@code null}.
	 * @param mapper The mapping function to map the item of this property to a {@link Double}.
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;Double&gt; viewAsDouble( double nullObject, Function&lt;T, @Nullable Double&gt; mapper ) {
<span class="nc" id="L702">		return view(nullObject, Double.NaN, mapper);</span>
	}

	/**
	 * Use this to create a {@link Double} based live view of this property through a new property based on the
	 * provided mapping function.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null}, the view will contain the
	 * &quot;null object&quot; of the {@link Double} type, which is {@code 0.0}.
	 * If the mapping function throws an exception, the view will contain {@code Double.NaN}.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link Double} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param mapper The mapping function to map the item of this property to a {@link Double}.
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;Double&gt; viewAsDouble( Function&lt;T, @Nullable Double&gt; mapper ) {
<span class="fc" id="L724">		return view(0.0, Double.NaN, mapper);</span>
	}

	/**
	 * Use this to create a {@link Double} based live view of this property through a new property based on the
	 * {@link Object#toString()} and {@link Double#parseDouble(String)} methods used as the mapping functions.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping functions.
	 * &lt;p&gt;
	 * Note: {@code null} references within the viewed property will always be mapped to the &quot;null object&quot; of the
	 * {@link Double} type, which is {@code 0.0}.
	 * If the item cannot be parsed, the item of the view will be {@link Double#NaN}.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link String} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @return A {@link Double} property that is a live view of this property.
	 */
	default Val&lt;Double&gt; viewAsDouble() {
<span class="fc bfc" id="L744" title="All 2 branches covered.">		return view( 0.0, Double.NaN, v -&gt; v == null ? null : Double.parseDouble( v.toString() ));</span>
	}

	/**
	 * Use this to create a {@link Integer} based live view of this property through a new property based on the
	 * provided mapping function and null object.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null} or throws an exception, the view will contain the provided
	 * null object.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link Integer} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param nullObject The null object to use if the mapping function returns {@code null}.
	 * @param mapper The mapping function to map the item of this property to a {@link Integer}.
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;Integer&gt; viewAsInt( int nullObject, Function&lt;T, @Nullable Integer&gt; mapper ) {
<span class="nc" id="L766">		return view(nullObject, nullObject, mapper);</span>
	}

	/**
	 * Use this to create a {@link Integer} based live view of this property through a new property based on the
	 * provided mapping function.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping function.
	 * &lt;p&gt;
	 * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
	 * If the mapping function returns {@code null}, the view will contain the
	 * &quot;null object&quot; of the {@link Integer} type, which is {@code 0}.
	 * If the mapping function throws an exception, the view will contain {@code 0}.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link Integer} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @param mapper The mapping function to map the item of this property to a {@link Integer}.
	 * @return A property that is a live view of this property based on the provided mapping function.
	 */
	default Val&lt;Integer&gt; viewAsInt( Function&lt;T, @Nullable Integer&gt; mapper ) {
<span class="fc" id="L788">		return view(0, 0, mapper);</span>
	}

	/**
	 * Use this to create a {@link Integer} based live view of this property through a new property based on the
	 * {@link Object#toString()} and {@link Integer#parseInt(String)} methods used as the mapping functions.
	 * This means that whenever the item of this property changes, the item of the new property
	 * will also be updated based on the result of the mapping functions.
	 * &lt;p&gt;
	 * Note: {@code null} references within the viewed property will always be mapped to the &quot;null object&quot; of the
	 * {@link Integer} type, which is {@code 0}.
	 * If the item cannot be parsed, the item of the view will be {@code 0}.
	 * &lt;p&gt;
	 * The result is a non-nullable {@link Integer} view of the property.
	 * The reason for this design decision is that a view of a property is intended to be used as part of an
	 * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.
	 *
	 * @return A {@link Integer} property that is a live view of this property.
	 */
	default Val&lt;Integer&gt; viewAsInt() {
<span class="fc bfc" id="L808" title="All 2 branches covered.">		return view(0, 0, v -&gt; v == null ? null : Integer.parseInt(v.toString()));</span>
	}

	/**
	 *  This method simply returns a {@link String} representation of the wrapped item
	 *  which would otherwise be accessed via the {@link #orElseThrow()} method.
	 *  Calling it should not have any side effects. &lt;br&gt;
	 *  The string conversion is based on the {@link String#valueOf(Object)} method,
	 *  and if the item is null, the string &quot;EMPTY&quot; will be returned.
	 *
	 * @return The {@link String} representation of the item wrapped by an implementation of this interface.
	 */
	default String itemAsString() {
<span class="fc" id="L821">		return this.mapTo(String.class, String::valueOf).orElse(EMPTY);</span>
	}

	/**
	 *  This method returns a {@link String} representation of the type of the wrapped item.
	 *  Calling it should not have any side effects.
	 *
	 * @return A simple {@link String} representation of the type of the item wrapped by an implementation of this interface.
	 */
<span class="fc" id="L830">	default String typeAsString() { return this.type().getName(); }</span>

	/**
	 *  This method check if the provided item is equal to the item wrapped by this {@link Var} instance.
	 *
	 * @param otherItem The other item of the same type as is wrapped by this.
	 * @return The truth value determining if the provided item is equal to the wrapped item.
	 */
	default boolean is( @Nullable T otherItem ) {
<span class="fc" id="L839">		return equals(otherItem, orElseNull());</span>
	}

	/**
	 *  This method check if the item by the provided property
	 *  is equal to the item wrapped by this {@link Var} instance.
	 *
	 * @param other The other property of the same type as is wrapped by this.
	 * @return The truth value determining if the item of the supplied property is equal to the wrapped item.
	 */
	default boolean is( Val&lt;@Nullable T&gt; other ) {
<span class="fc" id="L850">		Objects.requireNonNull(other);</span>
<span class="fc" id="L851">		return is( other.orElseNull() );</span>
	}

	/**
	 *  This method check if the provided item is not equal to the item wrapped by this {@link Val} instance.
	 *  This is the opposite of {@link #is(Object)} which returns true if the items are equal.
	 *
	 * @param otherItem The other item of the same type as is wrapped by this.
	 * @return The truth value determining if the provided item is not equal to the wrapped item.
	 */
<span class="fc bfc" id="L861" title="All 2 branches covered.">	default boolean isNot( @Nullable T otherItem ) { return !is(otherItem); }</span>

	/**
	 *  This method check if the item of the provided property
	 *  is not equal to the item wrapped by this {@link Val} instance.
	 *  This is the opposite of {@link #is(Val)} which returns true if the items are equal.
	 *
	 * @param other The other property of the same type as is wrapped by this.
	 * @return The truth value determining if the item of the supplied property is not equal to the wrapped item.
	 */
<span class="fc bfc" id="L871" title="All 2 branches covered.">	default boolean isNot( Val&lt;@Nullable T&gt; other ) { return !is(other); }</span>

	/**
	 *  This method checks if at least one of the provided items is equal to
	 *  the item wrapped by this {@link Var} instance.
	 *
	 * @param first The first item of the same type as is wrapped by this.
	 * @param second The second item of the same type as is wrapped by this.
	 * @param otherValues The other items of the same type as is wrapped by this.
	 * @return The truth value determining if the provided item is equal to the wrapped item.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default boolean isOneOf( @Nullable T first, @Nullable T second, @Nullable T... otherValues ) {
<span class="fc bfc" id="L884" title="All 2 branches covered.">		if ( this.is(first) ) return true;</span>
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">		if ( this.is(second) ) return true;</span>
<span class="fc" id="L886">		Objects.requireNonNull(otherValues);</span>
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">		for ( T otherValue : otherValues )</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">			if ( is(otherValue) ) return true;</span>
<span class="fc" id="L889">		return false;</span>
	}

	/**
	 *  This checks if at least one of the items of the provided properties
	 *  is equal to the item wrapped by this {@link Var} instance.
	 *
	 * @param first The first property of the same type as is wrapped by this.
	 * @param second The second property of the same type as is wrapped by this.
	 * @param otherValues The other properties of the same type as is wrapped by this.
	 * @return The truth value determining if the item of the supplied property is equal to the wrapped item.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default boolean isOneOf( Val&lt;@Nullable T&gt; first, Val&lt;@Nullable T&gt; second, Val&lt;@Nullable T&gt;... otherValues ) {
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">		if ( this.is(first) ) return true;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">		if ( this.is(second) ) return true;</span>
<span class="fc" id="L905">		Objects.requireNonNull(otherValues);</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">		for ( Val&lt;T&gt; otherValue : otherValues )</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">			if ( is(otherValue) ) return true;</span>
<span class="fc" id="L908">		return false;</span>
	}

	/**
	 *  Returns the name/id of the property which is useful for debugging as well as
	 *  persisting their state by using them as keys for whatever storage data structure one chooses. &lt;br&gt;
	 *  For example, when converting a property based model to a JSON object, the id of the properties
	 *  can be used as keys in the JSON object.
	 *
	 * @return The id which is assigned to this property.
	 */
	String id();

	/**
	 *  Use this method to create a new property with an id.
	 *  This id is used to identify the property in the UI
	 *  or as a key in a map, which is useful when converting your
	 *  view model to a JSON object, or similar formats.
	 *  &lt;p&gt;
	 *  You can retrieve the id of a property by calling the {@link #id()} method.&lt;br&gt;
	 *  An id may &lt;b&gt;not be null&lt;/b&gt;, please use the {@link #NO_ID} constant
	 *  or an empty string to indicate that a property has no id.
	 *
	 * @param id The id of the property, which is used to identify it.
	 *           It may &lt;b&gt;not be null&lt;/b&gt;, please use the {@link #NO_ID} constant
	 * @return A new {@link Val} instance with the given id.
	 */
	Val&lt;T&gt; withId( String id );

	/**
	 *  A convenient method to check if this property has not been assigned an id. &lt;br&gt;
	 *  This is the same as calling {@code !hasID()} or {@code id().equals(NO_ID)}.
	 * @return True when this property has not been assigned an id or
	 * 				the id is equal to the {@link #NO_ID} constant.
	 */
	default boolean hasNoID() {
<span class="nc bnc" id="L944" title="All 2 branches missed.">		return !hasID();</span>
	}

	/**
	 *  A convenient method to check if this property has been assigned an id. &lt;br&gt;
	 *  This is the same as calling {@code !id().equals(NO_ID)}.
	 *
	 * @return The truth value determining if this property has been assigned an id,
	 *  	 		or if &lt;b&gt;id is not equal to the {@link #NO_ID} constant&lt;/b&gt;.
	 */
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">	default boolean hasID() { return !NO_ID.equals(id()); }</span>

	/**
	 *  This returns the type of the item wrapped by this {@link Var}
	 *  which can be accessed by calling the {@link Var#orElseThrow()} method.
	 *
	 * @return The type of the item wrapped by the {@link Var}.
	 */
	Class&lt;T&gt; type();

	/**
	 *  Use this to turn this property to an {@link Optional} which can be used to
	 *  interact with the item wrapped by this {@link Val} in a more functional way.
	 * @return An {@link Optional} wrapping the item wrapped by this {@link Val}.
	 */
<span class="fc" id="L969">	default Optional&lt;T&gt; toOptional() { return Optional.ofNullable(this.orElseNull()); }</span>

	/**
	 *  Use this to register an observer lambda for a particular {@link Channel},
	 *  which will be called whenever the item
	 *  wrapped by this {@link Val} changes through the {@code Var::set(Channel, T)} method.
	 *  The lambda will receive the current item of this property.
	 *  The default channel is {@link From#VIEW_MODEL}, so if you use the {@code Var::set(T)} method
	 *  then the observer lambdas registered through this method will be called.
	 *
	 * @param channel The channel from which the item is set.
	 * @param action The lambda which will be called whenever the item wrapped by this {@link Var} changes.
	 * @return The {@link Val} instance itself.
	 */
	Val&lt;T&gt; onChange( Channel channel, Action&lt;Val&lt;T&gt;&gt; action );

	/**
	 *  Triggers all observer lambdas for the given {@link Channel}.
	 *  Change listeners may be registered using the {@link #onChange(Channel, Action)} method.
	 *  Note that when the {@code Var::set(T)} method is called
	 *  then this will automatically translate to {@code fireChange(From.VIEW_MODEL)}.
	 *  So it is supposed to be used by the view to update the UI components.
	 *  This is in essence how binding works in Swing-Tree.
	 *
	 * @param channel The channel from which the item is set.
	 * @return The {@link Val} instance itself.
	 */
	Val&lt;T&gt; fireChange( Channel channel );

	/**
	 *  A property will only allow null items if it was constructed with a &quot;ofNullable(..)&quot; factory method.
	 *  Otherwise, it will throw an {@link IllegalArgumentException} when trying to set a {@code null} reference.
	 *  This flag cannot be changed after the property has been constructed!
	 *  &lt;br&gt;
	 *  The purpose of this method is to warn the UI that this property can contain null items,
	 *  so that it may throw an exception or do something else to handle this case.
	 *  For many types of properties {@code null} is simply nonsensical, like {@link String} for example,
	 *  where the absence of a value is represented by an empty string.
	 *
	 * @return {@code true}, if this property can contain null, {@code false} otherwise.
	 */
	boolean allowsNull();

	/**
	 *  {@link Val} and {@link Var} implementations are expected to represent
	 *  simple wrappers for data centric quasi value types!
	 *  So two primitive arrays of integers for example would not be recognized as
	 *  equal when calling one of their {@link Object#equals(Object)} methods
	 *  because the method does not compare the contents of the two arrays, it compares the
	 *  identities of the arrays!
	 *  This method defines what it means for 2 property items to be equal.
	 *  So in this example it ensures that two {@link Var} instances wrapping
	 *  different arrays but with the same contents are treated as the same items.
	 *
	 * @param o1 The first object which ought to be compared to the second one.
	 * @param o2 The second object which ought to be compared to the first one.
	 * @return The truth value determining if the objects are equal in terms of their state!
	 */
	static boolean equals( @Nullable Object o1, @Nullable Object o2 ) {
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">		if ( o1 instanceof float[]   ) return Arrays.equals( (float[] )  o1, (float[] )  o2 );</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">		if ( o1 instanceof int[]     ) return Arrays.equals( (int[]   )  o1, (int[]   )  o2 );</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">		if ( o1 instanceof char[]    ) return Arrays.equals( (char[]  )  o1, (char[]  )  o2 );</span>
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">		if ( o1 instanceof double[]  ) return Arrays.equals( (double[])  o1, (double[])  o2 );</span>
<span class="pc bpc" id="L1032" title="1 of 2 branches missed.">		if ( o1 instanceof long[]    ) return Arrays.equals( (long[]  )  o1, (long[]  )  o2 );</span>
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">		if ( o1 instanceof byte[]    ) return Arrays.equals( (byte[]  )  o1, (byte[]  )  o2 );</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">		if ( o1 instanceof short[]   ) return Arrays.equals( (short[] )  o1, (short[] )  o2 );</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">		if ( o1 instanceof boolean[] ) return Arrays.equals( (boolean[]) o1, (boolean[]) o2 );</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">		if ( o1 instanceof Object[]  ) return Arrays.equals( (Object[])  o1, (Object[])  o2 );</span>
<span class="fc" id="L1037">		return Objects.equals( o1, o2 );</span>
	}

	/**
	 * 	{@link Val} and {@link Var} implementations require their own {@link Object#hashCode()}
	 * 	method because they are supposed to be viewed as data centric quasi value types!
	 * 	So two arrays of integer for example would not have the same hash code when calling
	 * 	{@link Object#hashCode()} on them.
	 * 	This is because the method does not compare the contents of the two arrays!
	 *
	 * @param o The object for which a hash code is required.
	 * @return The hash code of the object.
	 */
	static int hashCode( Object o ) {
<span class="pc bpc" id="L1051" title="1 of 2 branches missed.">		if ( o instanceof float[]   ) return Arrays.hashCode( (float[] )  o );</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">		if ( o instanceof int[]     ) return Arrays.hashCode( (int[]   )  o );</span>
<span class="pc bpc" id="L1053" title="1 of 2 branches missed.">		if ( o instanceof char[]    ) return Arrays.hashCode( (char[]  )  o );</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">		if ( o instanceof double[]  ) return Arrays.hashCode( (double[])  o );</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">		if ( o instanceof long[]    ) return Arrays.hashCode( (long[]  )  o );</span>
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">		if ( o instanceof byte[]    ) return Arrays.hashCode( (byte[]  )  o );</span>
<span class="pc bpc" id="L1057" title="1 of 2 branches missed.">		if ( o instanceof short[]   ) return Arrays.hashCode( (short[] )  o );</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">		if ( o instanceof boolean[] ) return Arrays.hashCode( (boolean[]) o );</span>
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">		if ( o instanceof Object[]  ) return Arrays.hashCode( (Object[])  o );</span>
<span class="fc" id="L1060">		return Objects.hashCode( o );</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>