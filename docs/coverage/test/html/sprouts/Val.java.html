<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Val.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts</a> &gt; <span class="el_source">Val.java</span></div><h1>Val.java</h1><pre class="source lang-java linenums">package sprouts;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import sprouts.impl.Sprouts;

import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 *  A read only wrapper around an item which can be mapped to a weakly referenced {@link Viewable}
 *  to then be observed for changes using {@link Action}s registered through the
 *  {@link Viewable#onChange(Channel, Action)} method,
 *  where the {@link Channel} is used to distinguish between changes from
 *  different sources (usually application layers like the view model or the view).&lt;br&gt;
 *  Use {@link #view()} to access a simple no-op live view of the item of this property
 *  and register change listeners on it to react to state changes.
 *  When the {@link Viewable} is no longer referenced strongly in your code,
 *  then it will be garbage collected alongside all of its listeners.&lt;br&gt;
 *  &lt;p&gt;
 *  The {@link Channel} supplied to the {@link Viewable#onChange(Channel, Action)} method to register an {@link Action}
 *  callback is expected to be a simple constant, usually one of the {@link From} constants
 *  like for example {@link From#VIEW_MODEL} or {@link From#VIEW}.
 *  You may fire a change event for a particular channel using the {@link #fireChange(Channel)} method or
 *  in case the property is also a mutable {@link Var}, then through the {@link Var#set(Channel, Object)}.&lt;br&gt;
 *  Note that {@link Var#set(Object)} method defaults to the {@link From#VIEW_MODEL} channel.
 *  &lt;p&gt;
 *  If you no longer need to observe changes a {@link Viewable} created from this property,
 *  then you can remove any registered {@link Action} callback using
 *  the {@link Viewable#unsubscribe(Subscriber)} method ({@link Action} is also a {@link Subscriber}).
 *  &lt;p&gt;
 *  Note that the name of this class is short for &quot;value&quot;.
 *  Its API is inspired by the {@link Optional} API in the
 *  sense that it is a null safe wrapper around a single item, which may also be missing (null).
 *  The name of this class was deliberately chosen because
 *  it is short, concise and yet clearly conveys the same meaning as other names used to model this
 *  kind of pattern, like &quot;property&quot;, &quot;observable object&quot;, &quot;observable value&quot;, &quot;observable property&quot;, etc.
 *  Using {@link Var} and {@link Val} as names also allows for the distinction between
 *  mutable and immutable properties without having to resort to prefixes like &quot;mutable&quot; or &quot;immutable&quot;
 *  as part of types that are supposed to be used everywhere in your code.
 *  &lt;p&gt;
 *  &lt;b&gt;Please take a look at the &lt;a href=&quot;https://globaltcad.github.io/sprouts/&quot;&gt;living sprouts documentation&lt;/a&gt;
 *  where you can browse a large collection of examples demonstrating how to use the API of this class.&lt;/b&gt;
 *
 * @see Var A mutable subclass of this class.
 * @see Viewable A weakly referenced, read only live view of mutable properties
 *               to be used for registering change listeners.
 * @param &lt;T&gt; The type of the item held by this {@link Val}.
 */
public interface Val&lt;T extends @Nullable Object&gt; extends Maybe&lt;T&gt; {

    /**
     *  Use this factory method to create a new {@link Val} instance
     *  whose item may or may not be null.
     *  &lt;p&gt;
     *  &lt;b&gt;Example:&lt;/b&gt;
     *  &lt;pre&gt;{@code
     *      Val.ofNullable(String.class, null);
     *  }&lt;/pre&gt;
     *  Note that it is required to supply a {@link Class} to ensure that the property
     *  can return a valid type when {@link Val#type()} is called.
     *
     * @param type The type of the item wrapped by the property.
     *             This is used to check if the item is of the correct type.
     * @param item The initial item of the property.
     *              This may be null.
     * @param &lt;T&gt; The type of the wrapped item.
     * @return A new {@link Val} instance.
     * @throws NullPointerException If the type is null.
     */
    static &lt;T&gt; Val&lt;@Nullable T&gt; ofNullable( Class&lt;T&gt; type, @Nullable T item ) {
<span class="fc" id="L77">        Objects.requireNonNull(type);</span>
<span class="fc" id="L78">        return Sprouts.factory().valOfNullable( type, item );</span>
    }

    /**
     *  A more concise version of {@link #ofNullable(Class, Object)}
     *  which is equivalent to {@code Var.ofNullable(type, null)}. &lt;br&gt;
     *  The {@link Val} instances returned by this factory method, are nullable, which
     *  means their {@link #allowsNull()} method will always yield {@code true}. &lt;br&gt;
     *  Note that it is required to supply a {@link Class} to ensure that the property
     *  can return a valid type when {@link Val#type()} is called.
     *
     * @param type The type of the item wrapped by the property.
     * @return A new {@link Val} instance.
     * @param &lt;T&gt; The type of the wrapped item.
     * @throws NullPointerException If the supplied type is null.
     */
    static &lt;T&gt; Val&lt;@Nullable T&gt; ofNull( Class&lt;T&gt; type ) {
<span class="fc" id="L95">        Objects.requireNonNull(type);</span>
<span class="fc" id="L96">        return Sprouts.factory().valOfNull( type );</span>
    }

    /**
     *  This factory method returns a {@code Val} describing the given non-{@code null}
     *  item similar to {@link Optional#of(Object)}, but specifically
     *  designed for use with Swing-Tree.
     *
     * @param item The initial item of the property which must not be null.
     * @param &lt;T&gt; The type of the item held by the {@link Val}!
     * @return A new {@link Val} instance wrapping the given item.
     * @throws NullPointerException If the supplied item is null.
     *                              Use {@link #ofNullable(Class, Object)} if the item may be null.
     */
    static &lt;T&gt; Val&lt;T&gt; of( T item ) {
<span class="fc" id="L111">        Objects.requireNonNull(item);</span>
<span class="fc" id="L112">        return Sprouts.factory().valOf( item );</span>
    }

    /**
     *  A factory method for creating a new {@link Val} instance
     *  which is effectively an immutable copy of the given {@link Val}.
     *  The provided {@link Val} must not contain a null item.
     *
     * @param toBeCopied The {@link Val} to be copied.
     * @return A new {@link Val} instance.
     * @param &lt;T&gt; The type of the item held by the {@link Val}!
     * @throws NullPointerException If the supplied {@link Val} is null.
     * @throws NoSuchElementException If the item of the supplied {@link Val} is null.
     */
    static &lt;T&gt; Val&lt;T&gt; of( Val&lt;T&gt; toBeCopied ) {
<span class="fc" id="L127">        Objects.requireNonNull(toBeCopied);</span>
<span class="fc" id="L128">        return Sprouts.factory().valOf( toBeCopied );</span>
    }

    /**
     *  A factory method for creating a new {@link Val} instance
     *  which is effectively an immutable copy of the given {@link Val}.
     *  The provided {@link Val} may contain a null item.
     *
     * @param toBeCopied The {@link Val} to be copied.
     * @return A new {@link Val} instance.
     * @param &lt;T&gt; The type of the item held by the {@link Val}!
     * @throws NullPointerException If the supplied {@link Val} is null.
     *                              Does not throw however, if the item of the supplied {@link Val} is null.
     */
    static &lt;T extends @Nullable Object&gt; Val&lt;@Nullable T&gt; ofNullable( Val&lt;T&gt; toBeCopied ) {
<span class="fc" id="L143">        Objects.requireNonNull(toBeCopied);</span>
<span class="fc" id="L144">        return Sprouts.factory().valOfNullable( toBeCopied );</span>
    }

    /**
     * Creates a read-only {@link Val} property that represents a live view of the two given properties using a
     * combiner function.
     * &lt;p&gt;
     * The combiner function takes the items of the two properties and returns an updated item based on them.
     * The combiner is called to compute a new item for the view property whenever at least one of the items
     * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
     * on either of the two properties.
     * &lt;p&gt;
     * Note: The property view does &lt;b&gt;not&lt;/b&gt; allow storing {@code null} references!
     * So if the combiner function returns a {@code null} reference or throws an exception on the first call,
     * a {@link NullPointerException} will be thrown.
     * If a {@code null} reference is returned on subsequent calls, the view will log a warning and simply retain the
     * last non-null value!
     * &lt;p&gt;
     * If you need a composite view that allows {@code null}, use the {@link #viewOfNullable(Val, Val, BiFunction)}
     * method instead.
     *
     * @param first    The first property to be combined.
     * @param second   The second property to be combined.
     * @param combiner The function used to combine the items of the two properties,
     *                 where the first argument is the item of the first property and
     *                 the second argument is the item of the second property.
     * @param &lt;T&gt;      The type of the item of the first property and the returned property.
     * @param &lt;U&gt;      The type of the second property.
     * @return A new {@link Val} instance which is a live view of the two given properties.
     * @throws NullPointerException If the combiner function returns a {@code null} reference
     *                              &lt;b&gt;when it is first called&lt;/b&gt;.
     */
    static &lt;T extends @Nullable Object, U extends @Nullable Object&gt; Viewable&lt;@NonNull T&gt; viewOf( Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, @NonNull T&gt; combiner ) {
<span class="fc" id="L177">        Objects.requireNonNull(first);</span>
<span class="fc" id="L178">        Objects.requireNonNull(second);</span>
<span class="fc" id="L179">        Objects.requireNonNull(combiner);</span>
<span class="fc" id="L180">        return Sprouts.factory().viewOf( first, second, combiner );</span>
    }

    /**
     * Creates a read-only nullable {@link Val} property that represents a live view of the two given properties using a
     * combiner function.
     * &lt;p&gt;
     * The combiner function takes the items of the two properties and returns an updated item based on them.
     * The combiner is called to compute a new item for the view property whenever at least one of the items
     * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
     * on either of the two properties.
     * &lt;p&gt;
     * Note: The property view does &lt;b&gt;allow&lt;/b&gt; storing {@code null} references!
     * If the combiner function throws an exception, the view will be set to {@code null}.
     * &lt;p&gt;
     * If you need a composite view that does not allow {@code null}, use the {@link #viewOf(Val, Val, BiFunction)}
     * method instead.
     *
     * @param first    The first property to be combined.
     * @param second   The second property to be combined.
     * @param combiner The function used to combine the items of the two properties,
     *                 where the first argument is the item of the first property and
     *                 the second argument is the item of the second property.
     * @param &lt;T&gt;      The type of the item of the first property and the returned property.
     * @param &lt;U&gt;      The type of the second property.
     * @return A new nullable {@link Viewable} instance which is a live view of the two given properties.
     */
    static &lt;T extends @Nullable Object, U extends @Nullable Object&gt; Viewable&lt;@Nullable T&gt; viewOfNullable(
            Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, @Nullable T&gt; combiner
    ) {
<span class="fc" id="L210">        Objects.requireNonNull(first);</span>
<span class="fc" id="L211">        Objects.requireNonNull(second);</span>
<span class="fc" id="L212">        Objects.requireNonNull(combiner);</span>
<span class="fc" id="L213">        return Sprouts.factory().viewOfNullable( first, second, combiner );</span>
    }

    /**
     * Creates a read-only {@link Val} property that represents a live view of the two given properties using a
     * combiner function.
     * &lt;p&gt;
     * The combiner function takes the items of the two properties and returns an updated item based on them.
     * The combiner is called to compute a new item for the view property whenever at least one of the items
     * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
     * on either of the two properties.
     * &lt;p&gt;
     * Note: The property view does &lt;b&gt;not&lt;/b&gt; allow storing {@code null} references!
     * So if the combiner function returns a {@code null} reference on the first call, a {@link NullPointerException}
     * will be thrown.
     * If a {@code null} reference is returned on subsequent calls, the view will log a warning and simply retain the
     * last non-null value!
     * &lt;p&gt;
     * If you need a composite view that allows {@code null}, use the {@link #viewOfNullable(Class, Val, Val, BiFunction)}
     * method instead.
     *
     * @param type     The type of the item returned from the mapping function.
     * @param first    The first property to be combined.
     * @param second   The second property to be combined.
     * @param combiner The function used to combine the items of the two properties,
     *                 where the first argument is the item of the first property and
     *                 the second argument is the item of the second property.
     * @param &lt;T&gt;      The type of the first property.
     * @param &lt;U&gt;      The type of the second property.
     * @param &lt;R&gt;      The type of the returned property.
     * @return A new {@link Viewable} instance which is a live view of the two given properties.
     * @throws NullPointerException If the combiner function returns a {@code null} reference
     *                              &lt;b&gt;when it is first called&lt;/b&gt;.
     */
    static &lt;T extends @Nullable Object, U extends @Nullable Object, R&gt; Viewable&lt;R&gt; viewOf(Class&lt;R&gt; type, Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, R&gt; combiner ) {
<span class="fc" id="L248">        Objects.requireNonNull(type);</span>
<span class="fc" id="L249">        Objects.requireNonNull(first);</span>
<span class="fc" id="L250">        Objects.requireNonNull(second);</span>
<span class="fc" id="L251">        Objects.requireNonNull(combiner);</span>
<span class="fc" id="L252">        return Sprouts.factory().viewOf( type, first, second, combiner );</span>
    }

    /**
     * Creates a read-only nullable {@link Val} property that represents a live view of the two given properties using a
     * combiner function.
     * &lt;p&gt;
     * The combiner function takes the items of the two properties and returns an updated item based on them.
     * The combiner is called to compute a new item for the view property whenever at least one of the items
     * in the two properties changes, or whenever a manual change event is fired (see {@link Var#fireChange(Channel)})
     * on either of the two properties.
     * &lt;p&gt;
     * Note: The property view does &lt;b&gt;allow&lt;/b&gt; storing {@code null} references!
     * If the combiner function throws an exception, the view will be set to {@code null}.
     * &lt;p&gt;
     * If you need a composite view that not allows {@code null}, use the {@link #viewOf(Class, Val, Val, BiFunction)}
     * method instead.
     *
     * @param type     The type of the item returned from the mapping function.
     * @param first    The first property to be combined.
     * @param second   The second property to be combined.
     * @param combiner The function used to combine the items of the two properties,
     *                 where the first argument is the item of the first property and
     *                 the second argument is the item of the second property.
     * @param &lt;T&gt;      The type of the first property.
     * @param &lt;U&gt;      The type of the second property.
     * @param &lt;R&gt;      The type of the returned property.
     * @return A new {@link Viewable} instance which is a live view of the two given properties.
     */
    static &lt;T extends @Nullable Object, U extends @Nullable Object, R&gt; Viewable&lt;@Nullable R&gt; viewOfNullable(Class&lt;R&gt; type, Val&lt;T&gt; first, Val&lt;U&gt; second, BiFunction&lt;T, U, @Nullable R&gt; combiner ) {
<span class="fc" id="L282">        Objects.requireNonNull(type);</span>
<span class="fc" id="L283">        Objects.requireNonNull(first);</span>
<span class="fc" id="L284">        Objects.requireNonNull(second);</span>
<span class="fc" id="L285">        Objects.requireNonNull(combiner);</span>
<span class="fc" id="L286">        return Sprouts.factory().viewOfNullable( type, first, second, combiner );</span>
    }

    /**
     * This method is intended to be used for when you want to wrap non-nullable types.
     * So if an item is present (not null), it returns the item, otherwise however
     * {@code NoSuchElementException} will be thrown.
     * If you simply want to get the item of this {@link Val} irrespective of
     * it being null or not, use {@link #orElseNull()} to avoid an exception.
     * However, if this result wraps a nullable type, which is not intended to be null,
     * please use {@link #orElseThrow()} or {@link #orElseThrowUnchecked()} to
     * make this intention clear to the reader of your code.
     * The {@link #orElseThrowUnchecked()} method is functionally identical to this method.
     *
     * @return The non-{@code null} item described by this {@code Val}.
     * @throws NoSuchElementException if no item is present.
     */
    default @NonNull T get() {
<span class="fc" id="L304">        return orElseThrowUnchecked();</span>
    }

    /**
     * If an item is present, returns a {@code Val} describing the item,
     * otherwise returns a {@code Val} produced by the supplying function.
     *
     * @param supplier the supplying function that produces a {@code Val}
     *        to be returned
     * @return returns a {@code Val} describing the item of this
     *         {@code Val}, if an item is present, otherwise a
     *         {@code Val} produced by the supplying function.
     * @throws NullPointerException if the supplying function is {@code null} or
     *         produces a {@code null} result
     */
    @Override
    default Val&lt;T&gt; or( Supplier&lt;? extends Maybe&lt;? extends T&gt;&gt; supplier ) {
<span class="fc" id="L321">        Objects.requireNonNull(supplier);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if ( isPresent() )</span>
<span class="fc" id="L323">            return this;</span>

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L326">        Maybe&lt;T&gt; r = (Maybe&lt;T&gt;) supplier.get();</span>
<span class="fc" id="L327">        Objects.requireNonNull(r);</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if ( r instanceof Val )</span>
<span class="fc" id="L329">            return (Val&lt;T&gt;) r;</span>
        else
<span class="nc" id="L331">            return Val.ofNullable(r.type(), r.orElseNull());</span>
    }

    /**
     *  If the item is present, applies the provided mapping function to it,
     *  and returns it wrapped in a new {@link Val} instance. &lt;br&gt;
     *  If the item is not present, then an empty {@link Val} instance is returned. &lt;br&gt;
     *  &lt;p&gt;
     *  But note that the resulting property does not constitute a live view of this property
     *  and will not be updated when this property changes. &lt;br&gt;
     *  It is functionally very similar to the {@link Optional#map(Function)} method. &lt;br&gt;
     *  &lt;p&gt;
     *  &lt;b&gt;
     *      If you want to map to a property which is an automatically updated live view of this property,
     *      then use the {@link #view(Function)} method instead.
     *  &lt;/b&gt;
     *  This is essentially the same as {@link Optional#map(Function)} but based on {@link Val}
     *  as the wrapper instead of {@link Optional}.
     *
     * @param mapper the mapping function to apply to an item, if present
     * @return A new property either empty (containing null) or containing the result of applying
     *             the mapping function to the item of this property.
     */
    @Override
    default Val&lt;T&gt; map( Function&lt;T, T&gt; mapper ) {
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if ( !isPresent() )</span>
<span class="nc" id="L357">            return Val.ofNull( type() );</span>

<span class="nc" id="L359">        T newValue = mapper.apply( get() );</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        return allowsNull() ? Val.ofNullable( type(), newValue ) : Val.of( newValue );</span>
    }

    /**
     *  If the item is present, applies the provided mapping function to it,
     *  and returns it wrapped in a new {@link Val} instance. &lt;br&gt;
     *  If the item is not present, then an empty {@link Val} instance is returned. &lt;br&gt;
     *  &lt;p&gt;
     *  But note that the resulting property does not constitute a live view of this property
     *  and will not be updated when this property changes. &lt;br&gt;
     *  It is functionally very similar to the {@link Optional#map(Function)} method. &lt;br&gt;
     *  &lt;p&gt;
     *  &lt;b&gt;
     *      If you want to map to a property which is an automatically updated live view of this property,
     *      then use the {@link #viewAs(Class, Function)} method instead.
     *  &lt;/b&gt;
     *
     * @param type The type of the item returned from the mapping function
     * @param mapper the mapping function to apply to an item, if present
     * @return A new property either empty (containing null) or containing the result of applying
     *             the mapping function to the item of this property.
     * @param &lt;U&gt; The type of the item returned from the mapping function
     */
    @Override
    default &lt;U&gt; Val&lt;U&gt; mapTo( Class&lt;U&gt; type, java.util.function.Function&lt;T, U&gt; mapper ) {
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if ( !isPresent() )</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            return !isMutable() ? Val.ofNull( type ) : Var.ofNull( type );</span>

<span class="fc" id="L388">        U newValue = mapper.apply( get() );</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">        if ( !isMutable() )</span>
<span class="fc" id="L391">            return Val.ofNullable( type, newValue );</span>
        else
<span class="fc" id="L393">            return Var.ofNullable( type, newValue );</span>
    }

    /**
     *  Returns a no-op {@link Viewable} of this {@link Val} to
     *  be used for registering change listeners (see {@link Viewable#onChange(Channel, Action)}).&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     * @return A weakly referenced {@link Viewable} to be used for registering
     *         change listeners.
     */
    default Viewable&lt;T&gt; view() {
<span class="fc" id="L410">        return Sprouts.factory().viewOf(this);</span>
    }

    /**
     *  Creates and returns a boolean property which is a live view of the {@link #isPresent()}
     *  flag of this property.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @return A live view of the presence of an item in this property in the form
     *         of a {@link Boolean} property.
     *         So whenever the {@link #isPresent()} flag of this property changes,
     *         the item of the returned property will be updated to reflect the change.
     */
    default Viewable&lt;Boolean&gt; viewIsPresent() {
<span class="fc" id="L430">        return viewAs(Boolean.class, Objects::nonNull);</span>
    }

    /**
     *  Creates and returns a boolean property which is a live view of the {@link #isEmpty()}
     *  flag of this property.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @return A live view of the absence of an item in this property in the form
     *         of a {@link Boolean} property.
     *         So whenever the {@link #isEmpty()} flag of this property changes,
     *         the item of the returned property will be updated to reflect the change.
     */
    default Viewable&lt;Boolean&gt; viewIsEmpty() {
<span class="fc" id="L450">        return viewAs(Boolean.class, Objects::isNull);</span>
    }

    /**
     * Use this to create a live view of this property through a new property based on the provided mapping function.
     * So whenever the value of this property changes, the value of the new property will be updated based on the
     * mapping function.
     * &lt;p&gt;
     * Note: The mapping function is not allowed to map to {@code null}, but may need to handle {@code null}.
     * Null must be mapped to an appropriate null object.
     * &lt;p&gt;
     * The result is a non-nullable view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param type   The type of the item returned from the mapping function
     * @param mapper the mapping function to apply to an item, if present
     * @param &lt;U&gt;    The type of the item returned from the mapping function
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default &lt;U&gt; Viewable&lt;U&gt; viewAs( Class&lt;U&gt; type, Function&lt;T, U&gt; mapper ) {
<span class="fc" id="L478">        return Sprouts.factory().viewOf( type, this, mapper );</span>
    }

    /**
     * Use this to create a live view of this property through a new property based on the provided mapping function.
     * So whenever the item of this property changes, the item of the new property will be updated based on the
     * mapping function and null object.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null} or throws an exception, the view will contain the proved
     * null object.
     * &lt;p&gt;
     * The result is a non-nullable view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param nullObject The null object to use if no item is present.
     * @param mapper     The mapping function to apply to an item.
     * @param &lt;U&gt;        The type of the resulting property.
     * @return A property that is a live view of this property based on the provided mapping function and null object.
     */
    default &lt;U&gt; Viewable&lt;U&gt; view( U nullObject, Function&lt;T, @Nullable U&gt; mapper ) {
<span class="fc" id="L507">        return view(nullObject, nullObject, mapper);</span>
    }

    /**
     * Use this to create a live view of this property through a new property based on the provided mapping function.
     * So whenever the item of this property changes, the item of the new property will be updated based on the
     * mapping function and null object.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null}, the view will contain the proved null object.
     * If the mapping function throws an exception, the view will contain the proved error object.
     * &lt;p&gt;
     * The result is a non-nullable view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param nullObject  The null object to use if no item is present.
     * @param errorObject The error object to use if an error occurs.
     * @param mapper      The mapping function to apply to an item.
     * @param &lt;U&gt;         The type of the resulting property.
     * @return A property that is a live view of this property based on the provided mapping function and null object.
     */
    default &lt;U&gt; Viewable&lt;U&gt; view( U nullObject, U errorObject, Function&lt;T, @Nullable U&gt; mapper ) {
<span class="fc" id="L537">        return Sprouts.factory().viewOf(nullObject, errorObject, this, mapper);</span>
    }


    /**
     * Use this to create a nullable live view of this property through a new property based on the provided mapping
     * function.
     * So whenever the value of this property changes, the value of the new property will be updated based on the
     * mapping function.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param type   The type of the value returned from the mapping function
     * @param mapper The mapping function to apply to a value
     * @param &lt;U&gt;    The type of the resulting property.
     * @return A nullable property that is a live view of this property based on the provided mapping function.
     */
    default &lt;U&gt; Viewable&lt;@Nullable U&gt; viewAsNullable( Class&lt;U&gt; type, Function&lt;T, @Nullable U&gt; mapper ) {
<span class="fc" id="L560">        return Sprouts.factory().viewOfNullable( type, this, mapper );</span>
    }

    /**
     *  Use this to create a live view of this property
     *  based on a mapping function which maps the item of this property to an item of the same type as this property.
     *  So whenever the item of this property changes, the item of the new property
     *  will be updated based on the mapping function.
     *  If you want to create a live view of a different type, use the {@link #viewAs(Class, Function)}
     *  method instead.
     *  &lt;p&gt;
     *  Note that this method will try to map value based item types like
     *  {@link String}, {@link Integer}, {@link Double}, etc.
     *  to the default value (or &quot;null object&quot;) of their respective types,
     *  if the provided mapping function returns a null reference.&lt;br&gt;
     *  So if the type of this property is a {@link String}, and the mapping function returns a null reference,
     *  then the resulting view property will always contain an empty string and
     *  its {@link #allowsNull()} method will always return false.
     *  &lt;p&gt;
     *  Also note that a property view may only contain null if the property it is based on
     *  was created with the &quot;ofNullable(...)&quot; factory method
     *  (in which case its {@link #allowsNull()} method will return true).
     *  Otherwise, it will throw an exception when trying to map a null reference.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param mapper the mapping function to apply to an item, if present
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;T&gt; view( Function&lt;T, T&gt; mapper ) {
<span class="fc" id="L595">        return viewAs( type(), mapper );</span>
    }

    /**
     * Use this to create a {@link String} based live view of this property through a new property based on the
     * provided mapping function and null object.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping function.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null} or throws an exception, the view will contain the proved
     * null object.
     * &lt;p&gt;
     * The result is a non-nullable {@link String} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param nullObject The null object to use if the mapping function returns {@code null}.
     * @param mapper The mapping function to map the item of this property to a {@link String}.
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;String&gt; viewAsString( String nullObject, Function&lt;T, @Nullable String&gt; mapper ) {
<span class="fc" id="L624">        Objects.requireNonNull(nullObject);</span>
<span class="fc" id="L625">        return view(nullObject, nullObject, mapper);</span>
    }

    /**
     * Use this to create a {@link String} based live view of this property through a new property based on the
     * provided mapping function.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping function.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null} or throws an exception, the view will contain the
     * &quot;null object&quot; of the {@link String} type, which is an empty string.
     * &lt;p&gt;
     * The result is a non-nullable {@link String} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param mapper The mapping function to map the item of this property to a {@link String}.
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;String&gt; viewAsString( Function&lt;T, @Nullable String&gt; mapper ) {
<span class="fc" id="L653">        return view(&quot;&quot;, &quot;&quot;, mapper);</span>
    }

    /**
     * Use this to create a {@link String} based live view of this property through a new property based on the
     * {@link Object#toString()} method used as the mapping function.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the {@link Object#toString()} mapping function.
     * &lt;p&gt;
     * Note: {@code null} references within the viewed property will always be mapped to the &quot;null object&quot; of the
     * {@link String} type, which is an empty string.
     * &lt;p&gt;
     * The result is a non-nullable {@link String} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;String&gt; viewAsString() {
<span class="fc bfc" id="L679" title="All 2 branches covered.">        return view(&quot;&quot;, &quot;&quot;, v -&gt; v == null ? null  : v.toString());}</span>

    /**
     * Use this to create a {@link Double} based live view of this property through a new property based on the
     * provided mapping function and null object.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping function.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null}, the view will contain the provided null object.
     * If the mapping function throws an exception, the view will contain {@code Double.NaN}.
     * &lt;p&gt;
     * The result is a non-nullable {@link Double} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param nullObject The null object to use if the mapping function returns {@code null}.
     * @param mapper The mapping function to map the item of this property to a {@link Double}.
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;Double&gt; viewAsDouble( double nullObject, Function&lt;T, @Nullable Double&gt; mapper ) {
<span class="fc" id="L707">        return view(nullObject, Double.NaN, mapper);</span>
    }

    /**
     * Use this to create a {@link Double} based live view of this property through a new property based on the
     * provided mapping function.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping function.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null}, the view will contain the
     * &quot;null object&quot; of the {@link Double} type, which is {@code 0.0}.
     * If the mapping function throws an exception, the view will contain {@code Double.NaN}.
     * &lt;p&gt;
     * The result is a non-nullable {@link Double} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param mapper The mapping function to map the item of this property to a {@link Double}.
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;Double&gt; viewAsDouble( Function&lt;T, @Nullable Double&gt; mapper ) {
<span class="fc" id="L736">        return view(0.0, Double.NaN, mapper);</span>
    }

    /**
     * Use this to create a {@link Double} based live view of this property through a new property based on the
     * {@link Object#toString()} and {@link Double#parseDouble(String)} methods used as the mapping functions.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping functions.
     * &lt;p&gt;
     * Note: {@code null} references within the viewed property will always be mapped to the &quot;null object&quot; of the
     * {@link Double} type, which is {@code 0.0}.
     * If the item cannot be parsed, the item of the view will be {@link Double#NaN}.
     * &lt;p&gt;
     * The result is a non-nullable {@link String} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @return A {@link Double} property that is a live view of this property.
     */
    default Viewable&lt;Double&gt; viewAsDouble() {
<span class="fc bfc" id="L763" title="All 2 branches covered.">        return view( 0.0, Double.NaN, v -&gt; v == null ? null : Double.parseDouble( v.toString() ));</span>
    }

    /**
     * Use this to create a {@link Integer} based live view of this property through a new property based on the
     * provided mapping function and null object.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping function.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null} or throws an exception, the view will contain the provided
     * null object.
     * &lt;p&gt;
     * The result is a non-nullable {@link Integer} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param nullObject The null object to use if the mapping function returns {@code null}.
     * @param mapper The mapping function to map the item of this property to a {@link Integer}.
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;Integer&gt; viewAsInt( int nullObject, Function&lt;T, @Nullable Integer&gt; mapper ) {
<span class="fc" id="L792">        return view(nullObject, nullObject, mapper);</span>
    }

    /**
     * Use this to create a {@link Integer} based live view of this property through a new property based on the
     * provided mapping function.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping function.
     * &lt;p&gt;
     * Note: The mapping function can map to {@code null} and may need to handle {@code null}.
     * If the mapping function returns {@code null}, the view will contain the
     * &quot;null object&quot; of the {@link Integer} type, which is {@code 0}.
     * If the mapping function throws an exception, the view will contain {@code 0}.
     * &lt;p&gt;
     * The result is a non-nullable {@link Integer} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @param mapper The mapping function to map the item of this property to a {@link Integer}.
     * @return A property that is a live view of this property based on the provided mapping function.
     */
    default Viewable&lt;Integer&gt; viewAsInt( Function&lt;T, @Nullable Integer&gt; mapper ) {
<span class="fc" id="L821">        return view(0, 0, mapper);</span>
    }

    /**
     * Use this to create a {@link Integer} based live view of this property through a new property based on the
     * {@link Object#toString()} and {@link Integer#parseInt(String)} methods used as the mapping functions.
     * This means that whenever the item of this property changes, the item of the new property
     * will also be updated based on the result of the mapping functions.
     * &lt;p&gt;
     * Note: {@code null} references within the viewed property will always be mapped to the &quot;null object&quot; of the
     * {@link Integer} type, which is {@code 0}.
     * If the item cannot be parsed, the item of the view will be {@code 0}.
     * &lt;p&gt;
     * The result is a non-nullable {@link Integer} view of the property.
     * The reason for this design decision is that a view of a property is intended to be used as part of an
     * application, where {@code null} can lead to exceptions and ultimately a confusing user experience.&lt;br&gt;
     *  &lt;b&gt;
     *      Warning: &lt;br&gt;
     *      If you have change listeners registered the {@link Viewable} returned by this method,
     *      and you do not keep a reference to it,
     *      then it will be garbage collected alongside all of its change listeners.&lt;br&gt;
     *      So if there are changes in this property afterwords, the change listeners will not be called!
     *  &lt;/b&gt;
     *
     * @return A {@link Integer} property that is a live view of this property.
     */
    default Viewable&lt;Integer&gt; viewAsInt() {
<span class="fc bfc" id="L848" title="All 2 branches covered.">        return view(0, 0, v -&gt; v == null ? null : Integer.parseInt(v.toString()));</span>
    }

    /**
     * Creates a live view of this property as a {@link Tuple} containing items of
     * the specified type using the given mapping function which dynamically maps
     * the current property item {@code T} to a {@code Tuple&lt;U&gt;}.&lt;br&gt;
     * &lt;p&gt;
     * The resulting view is automatically updated whenever the value of this property changes,
     * meaning that the mapper {@code Function&lt;T, @Nullable Tuple&lt;U&gt;&gt;} is called with the new property item
     * and the state of the view is updated with the result of said mapping function.
     * &lt;p&gt;
     * The {@code type} parameter is used to obtain a default tuple instance (via {@code Tuple.of(type)}) which serves
     * both as the fallback null object and error object. This means that if the mapping function returns {@code null}
     * or throws an exception, the view will retain a default {@code Tuple} instance instead of propagating
     * storing {@code null}, which is not allowed for this view.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; If you register change listeners on the returned view and do not maintain a strong reference
     * to it, the view along with its listeners may be garbage collected, and subsequent changes to this property
     * will not trigger the listeners.
     *
     * @param type   The class representing the type of the tuple's element. This is used to create a default tuple instance.
     * @param mapper A function that maps the value of this property to a {@link Tuple} of type {@code U}. The function
     *               should handle {@code null} values appropriately.
     * @param &lt;U&gt;    The type of the element within the tuple.
     * @return A live view of this property as a {@link Tuple} of type {@code U}.
     * @throws NullPointerException if either {@code type} or {@code mapper} is {@code null}.
     */
    default &lt;U&gt; Viewable&lt;Tuple&lt;U&gt;&gt; viewAsTuple( Class&lt;U&gt; type, Function&lt;T, @Nullable Tuple&lt;U&gt;&gt; mapper ) {
<span class="fc" id="L877">        Objects.requireNonNull(type);</span>
<span class="fc" id="L878">        Objects.requireNonNull(mapper);</span>
<span class="fc" id="L879">        return view(Tuple.of(type), Tuple.of(type), mapper);</span>
    }

    /**
     * Creates a live view of this property as a {@link Association} containing key-value pairs of
     * the specified key type {@code K} and value type {@code V} using the supplied mapping function which dynamically maps
     * the current property item {@code T} to a {@code Association&lt;K, V&gt;}.&lt;br&gt;
     * &lt;p&gt;
     * The resulting view is automatically updated whenever the value of this property changes,
     * meaning that the mapper {@code Function&lt;T, @Nullable Association&lt;K, V&gt;&gt;} is called with the new property item
     * and the state of the view is updated with the result of said mapping function.
     * &lt;p&gt;
     * The {@code keyType} and {@code valueType} parameters are used to obtain a
     * default association instance (via {@code Association.between(keyType, valueType)}) which serves
     * both as the fallback null object and error object. This means that if the mapping function returns {@code null}
     * or throws an exception, the view will retain an empty default {@code Association} instance instead of propagating
     * storing {@code null}, which is not allowed for this view.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; If you register change listeners on the returned view and do not maintain a strong reference
     * to it, the view along with its listeners may be garbage collected, and subsequent changes to this property
     * will not trigger the listeners.
     *
     * @param keyType   The class representing the type of the association's key. This is used to create a default association instance.
     *                  This parameter must not be {@code null}.
     * @param valueType The class representing the type of the association's value. This is used to create a default association instance.
     *                  This parameter must not be {@code null}.
     * @param mapper    A function that maps the value of this property to an {@link Association} of type {@code K, V}.
     *                  The function should handle {@code null} values appropriately.
     * @param &lt;K&gt;       The type of the key within the association.
     * @param &lt;V&gt;       The type of the value within the association.
     * @return A live view of this property as an {@link Association} of type {@code K, V}.
     * @throws NullPointerException if either {@code keyType}, {@code valueType}, or {@code mapper} is {@code null}.
     */
    default &lt;K, V&gt; Viewable&lt;Association&lt;K, V&gt;&gt; viewAsAssociation( Class&lt;K&gt; keyType, Class&lt;V&gt; valueType, Function&lt;T, @Nullable Association&lt;K, V&gt;&gt; mapper ) {
<span class="nc" id="L913">        Objects.requireNonNull(keyType);</span>
<span class="nc" id="L914">        Objects.requireNonNull(valueType);</span>
<span class="nc" id="L915">        Objects.requireNonNull(mapper);</span>
<span class="nc" id="L916">        Association&lt;K, V&gt; empty = Association.between(keyType, valueType);</span>
<span class="nc" id="L917">        return view(empty, empty, mapper);</span>
    }

    /**
     *  Returns the name/id of the property which is useful for debugging as well as
     *  persisting their state by using them as keys for whatever storage data structure one chooses. &lt;br&gt;
     *  For example, when converting a property based model to a JSON object, the id of the properties
     *  can be used as keys in the JSON object.
     *
     * @return The id which is assigned to this property.
     */
    String id();

    /**
     *  Use this method to create a new property with an id.
     *  This id is used to identify the property in the UI
     *  or as a key in a map, which is useful when converting your
     *  view model to a JSON object, or similar formats.
     *  &lt;p&gt;
     *  You can retrieve the id of a property by calling the {@link #id()} method.&lt;br&gt;
     *  An id may &lt;b&gt;not be null&lt;/b&gt;, please use the {@link Sprouts#defaultId()} constant
     *  or an empty string to indicate that a property has no id.
     *
     * @param id The id of the property, which is used to identify it.
     *           It may &lt;b&gt;not be null&lt;/b&gt;, please use the {@link Sprouts#defaultId()} constant
     * @return A new {@link Val} instance with the given id.
     */
    Val&lt;T&gt; withId( String id );

    /**
     *  A convenient method to check if this property has not been assigned an id. &lt;br&gt;
     *  This is the same as calling {@code !hasID()} or {@code id().equals(Sprouts.defaultId())}.
     * @return True when this property has not been assigned an id or
     *                 the id is equal to the {@link Sprouts#defaultId()} constant.
     */
    default boolean hasNoID() {
<span class="fc bfc" id="L953" title="All 2 branches covered.">        return !hasID();</span>
    }

    /**
     *  A convenient method to check if this property has been assigned an id. &lt;br&gt;
     *  This is the same as calling {@code !id().equals(NO_ID)}.
     *
     * @return The truth value determining if this property has been assigned an id,
     *               or if &lt;b&gt;id is not equal to the {@link Sprouts#defaultId()} constant&lt;/b&gt;.
     */
<span class="fc bfc" id="L963" title="All 2 branches covered.">    default boolean hasID() { return !Sprouts.factory().defaultId().equals(id()); }</span>

    /**
     *  Triggers all observer lambdas for the given {@link Channel}.
     *  Change listeners may be registered using the {@link Viewable#onChange(Channel, Action)} method.
     *  Note that when the {@code Var::set(T)} method is called
     *  then this will automatically translate to {@code fireChange(From.VIEW_MODEL)}.
     *  So it is supposed to be used by the view to update the UI components.
     *  This is in essence how binding works in Swing-Tree.
     *
     * @param channel The channel from which the item is set.
     * @return The {@link Val} instance itself.
     */
    Val&lt;T&gt; fireChange( Channel channel );

    /**
     *  A property will only allow null items if it was constructed with a &quot;ofNullable(..)&quot; factory method.
     *  Otherwise, it will throw an {@link IllegalArgumentException} when trying to set a {@code null} reference.
     *  This flag cannot be changed after the property has been constructed!
     *  &lt;br&gt;
     *  The purpose of this method is to warn the UI that this property can contain null items,
     *  so that it may throw an exception or do something else to handle this case.
     *  For many types of properties {@code null} is simply nonsensical, like {@link String} for example,
     *  where the absence of a value is represented by an empty string.
     *
     * @return {@code true}, if this property can contain null, {@code false} otherwise.
     */
    boolean allowsNull();

    /**
     *  This method is used to determine if the property is mutable or not.
     *  A mutable property can be changed by calling the {@code Var.set(T)} method.
     *  An immutable property cannot be changed and will throw an exception when trying to do so.
     *  &lt;br&gt;
     *  The purpose of this method is to warn the UI that this property can be changed,
     *  so that it may throw an exception or do something else to handle this case.
     *  &lt;br&gt;
     *  Note that this is the inverse of {@link #isImmutable()}.
     *
     * @return {@code true}, if this property can be changed, {@code false} otherwise.
     */
    boolean isMutable();

    /**
     *  This method is used to determine if the property is immutable or not.
     *  An immutable property cannot be changed by calling the {@code Var.set(T)} method
     *  and will throw an exception when trying to do so.
     *  &lt;br&gt;
     *  The purpose of this method is to give the UI confidence in the fact that this property cannot be changed,
     *  so that it may make some assumptions based on that.
     *  &lt;br&gt;
     *  Note that this is the inverse of {@link #isMutable()}.
     *
     * @return {@code true}, if this property can not be changed, {@code false} otherwise.
     */
    default boolean isImmutable() {
<span class="pc bpc" id="L1019" title="1 of 2 branches missed.">        return !this.isMutable();</span>
    }

    /**
     *  This method is used to determine if the property is a lens or not.
     *  A lens is a property which observes a specific part of the item
     *  of a parent property, and is used to create a view of that part,
     *  which may also be modified using the {@code Var.set(T)} method.&lt;br&gt;
     *  See {@link Var#zoomTo(Function, BiFunction)} and {@link Var#zoomTo(Object, Function, BiFunction)}
     *  for more information on how to create a lens.
     *
     * @return {@code true}, if this property is a lens, {@code false} otherwise.
     */
<span class="fc" id="L1032">    default boolean isLens() { return false; }</span>

    /**
     *  This method is used to determine if the property is a view or not.
     *  A view is a simple property which observes the item of another property,
     *  using a mapping function to create a new item based on the item of the parent property.
     *  This kind of property may only change its state when the parent property changes. &lt;br&gt;
     *  See {@link Var#viewAs(Class, Function)} and {@link Var#view(Object, Function)} for more information
     *  on how to create a view.
     *
     * @return {@code true}, if this property is a view, {@code false} otherwise.
     */
<span class="fc" id="L1044">    default boolean isView() { return false; }</span>

    /**
     *  {@link Val} and {@link Var} implementations are expected to represent
     *  simple wrappers for data centric quasi value types!
     *  So two primitive arrays of integers for example would not be recognized as
     *  equal when calling one of their {@link Object#equals(Object)} methods
     *  because the method does not compare the contents of the two arrays, it compares the
     *  identities of the arrays!
     *  This method defines what it means for 2 property items to be equal.
     *  So in this example it ensures that two {@link Var} instances wrapping
     *  different arrays but with the same contents are treated as the same items.
     *
     * @param o1 The first object which ought to be compared to the second one.
     * @param o2 The second object which ought to be compared to the first one.
     * @return The truth value determining if the objects are equal in terms of their state!
     */
    static boolean equals( @Nullable Object o1, @Nullable Object o2 ) {
<span class="fc bfc" id="L1062" title="All 2 branches covered.">        if ( o1 instanceof float[]   ) return Arrays.equals( (float[] )  o1, (float[] )  o2 );</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        if ( o1 instanceof int[]     ) return Arrays.equals( (int[]   )  o1, (int[]   )  o2 );</span>
<span class="fc bfc" id="L1064" title="All 2 branches covered.">        if ( o1 instanceof char[]    ) return Arrays.equals( (char[]  )  o1, (char[]  )  o2 );</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">        if ( o1 instanceof double[]  ) return Arrays.equals( (double[])  o1, (double[])  o2 );</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">        if ( o1 instanceof long[]    ) return Arrays.equals( (long[]  )  o1, (long[]  )  o2 );</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">        if ( o1 instanceof byte[]    ) return Arrays.equals( (byte[]  )  o1, (byte[]  )  o2 );</span>
<span class="pc bpc" id="L1068" title="1 of 2 branches missed.">        if ( o1 instanceof short[]   ) return Arrays.equals( (short[] )  o1, (short[] )  o2 );</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if ( o1 instanceof boolean[] ) return Arrays.equals( (boolean[]) o1, (boolean[]) o2 );</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">        if ( o1 instanceof Object[]  ) return Arrays.equals( (Object[])  o1, (Object[])  o2 );</span>
<span class="fc" id="L1071">        return Objects.equals( o1, o2 );</span>
    }

    /**
     *  {@link Val} and {@link Var} implementations require their own {@link Object#hashCode()}
     *  method because they are supposed to be viewed as data centric quasi value types!
     *  So two arrays of integer for example would not have the same hash code when calling
     *  {@link Object#hashCode()} on them.
     *  This is because the method does not compare the contents of the two arrays!
     *
     * @param o The object for which a hash code is required.
     * @return The hash code of the object.
     */
    static int hashCode( Object o ) {
<span class="fc bfc" id="L1085" title="All 2 branches covered.">        if ( o instanceof float[]   ) return Arrays.hashCode( (float[] )  o );</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if ( o instanceof int[]     ) return Arrays.hashCode( (int[]   )  o );</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        if ( o instanceof char[]    ) return Arrays.hashCode( (char[]  )  o );</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">        if ( o instanceof double[]  ) return Arrays.hashCode( (double[])  o );</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">        if ( o instanceof long[]    ) return Arrays.hashCode( (long[]  )  o );</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">        if ( o instanceof byte[]    ) return Arrays.hashCode( (byte[]  )  o );</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        if ( o instanceof short[]   ) return Arrays.hashCode( (short[] )  o );</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if ( o instanceof boolean[] ) return Arrays.hashCode( (boolean[]) o );</span>
<span class="fc bfc" id="L1093" title="All 2 branches covered.">        if ( o instanceof Object[]  ) return Arrays.hashCode( (Object[])  o );</span>
<span class="fc" id="L1094">        return Objects.hashCode( o );</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>