<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TupleHamt.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">TupleHamt.java</span></div><h1>TupleHamt.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.SequenceChange;
import sprouts.Tuple;

import java.util.*;
import java.util.function.Consumer;

import static sprouts.impl.ArrayUtil.*;

/**
 *  A tuple implementation based on a HAMT (Hash Array Mapped Trie) data structure.
 * @param &lt;T&gt; The type of the items in the tuple.
 */
public final class TupleHamt&lt;T extends @Nullable Object&gt; implements Tuple&lt;T&gt; {

    private static final int BRANCHING_FACTOR = 32;
    private static final int MAX_LEAF_NODE_SIZE = 512;


    interface Node {
        int size();

        &lt;T&gt; T getAt(int index, Class&lt;T&gt; type);

        @Nullable
        Node slice(int from, int to, Class&lt;?&gt; type, boolean allowsNull);

        @Nullable
        Node removeRange(int from, int to, Class&lt;?&gt; type, boolean allowsNull);

        @Nullable &lt;T&gt; Node addAllAt(int index, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, boolean allowsNull);

        @Nullable &lt;T&gt; Node setAllAt(int index, int offset, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, boolean allowsNull);

        &lt;T&gt; void forEach(Class&lt;T&gt; type, Consumer&lt;T&gt; consumer);
    }

    static final class LeafNode implements Node {
        private final Object _data;

<span class="fc" id="L43">        LeafNode(Object data) {</span>
<span class="fc" id="L44">            _data = data;</span>
<span class="fc" id="L45">        }</span>

        @Override
        public int size() {
<span class="fc" id="L49">            return _length(_data);</span>
        }

        @Override
        public &lt;T&gt; T getAt(int index, Class&lt;T&gt; type) {
<span class="fc" id="L54">            return Util.fakeNonNull(_getAt(index, _data, type));</span>
        }

        @Override
        public @Nullable Node slice(int from, int to, Class&lt;?&gt; type, boolean allowsNull) {
<span class="fc bfc" id="L59" title="All 4 branches covered.">            if ( from == 0 &amp;&amp; to == _length(_data) )</span>
<span class="fc" id="L60">                return this;</span>
            else {
<span class="fc" id="L62">                int newSize = (to - from);</span>
<span class="fc" id="L63">                Object newItems = _createArray(type, allowsNull, newSize);</span>
<span class="fc" id="L64">                System.arraycopy(_data, from, newItems, 0, newSize);</span>
<span class="fc" id="L65">                return new LeafNode(newItems);</span>
            }
        }

        @Override
        public @Nullable Node removeRange(int from, int to, Class&lt;?&gt; type, boolean allowsNull) {
<span class="pc bpc" id="L71" title="2 of 4 branches missed.">            if ( from &lt; 0 || to &gt; _length(_data) )</span>
<span class="nc" id="L72">                return this;</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">            if ( from &gt; to )</span>
<span class="nc" id="L74">                return this;</span>
<span class="fc" id="L75">            int numberOfItemsToRemove = to - from;</span>
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">            if ( numberOfItemsToRemove == 0 )</span>
<span class="nc" id="L77">                return this;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if ( numberOfItemsToRemove == this.size() )</span>
<span class="fc" id="L79">                return null;</span>
            else
<span class="fc" id="L81">                return new LeafNode(_withRemoveRange(from, to, _data, type, allowsNull));</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node addAllAt(int index, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, boolean allowsNull) {
<span class="fc" id="L86">            int currentSize = _length(_data);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if ( currentSize + tuple.size() &gt; MAX_LEAF_NODE_SIZE ) {</span>
<span class="fc" id="L88">                List&lt;T&gt; asList = _toList(_data, type);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">                for (int i = 0; i &lt; tuple.size(); i++) {</span>
<span class="fc" id="L90">                    asList.add(index + i, tuple.get(i));</span>
                }
<span class="fc" id="L92">                return _createRootFromList(type, allowsNull, asList);</span>
            }
<span class="fc" id="L94">            Object newItems = _withAddAllAt(index, tuple, _data, type, allowsNull);</span>
<span class="fc" id="L95">            return new LeafNode(newItems);</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node setAllAt(int index, int offset, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, boolean allowsNull) {
<span class="fc" id="L100">            int currentSize = _length(_data);</span>
<span class="fc" id="L101">            int offsetInTuple = Math.abs(Math.min(0, index))+offset;</span>
<span class="fc" id="L102">            int startIndex = Math.max(0, index);</span>
<span class="fc" id="L103">            boolean isAlreadyTheSame = true;</span>
<span class="fc" id="L104">            Object newItems = _clone(_data, type, allowsNull);</span>
<span class="fc" id="L105">            int numberToSet = Math.min(tuple.size()-offsetInTuple, currentSize - startIndex);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            for (int i = 0; i &lt; numberToSet; i++) {</span>
<span class="fc" id="L107">                Object itemToSet = tuple.get(offsetInTuple+i);</span>
<span class="fc" id="L108">                _setAt(startIndex + i, itemToSet, newItems);</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                if ( !Objects.equals(itemToSet, _getAt(startIndex+i, _data, type)) )</span>
<span class="fc" id="L110">                    isAlreadyTheSame = false;</span>
            }
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if ( isAlreadyTheSame )</span>
<span class="fc" id="L113">                return this;</span>
<span class="fc" id="L114">            return new LeafNode(newItems);</span>
        }

        @Override
        public &lt;T&gt; void forEach(Class&lt;T&gt; type, Consumer&lt;T&gt; consumer) {
<span class="nc" id="L119">            _each(_data, type, consumer);</span>
<span class="nc" id="L120">        }</span>
    }

    static final class BranchNode implements Node {
        private final Node[] _children;
        private final int _size;

<span class="fc" id="L127">        BranchNode(Node[] children) {</span>
<span class="fc" id="L128">            _children = children;</span>
<span class="fc" id="L129">            int sum = 0;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            for (Node child : children) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">                if ( child != null )</span>
<span class="fc" id="L132">                    sum += child.size();</span>
            }
<span class="fc" id="L134">            _size = sum;</span>
<span class="fc" id="L135">        }</span>

        @Override
        public int size() {
<span class="fc" id="L139">            return _size;</span>
        }

        @Override
        public &lt;T&gt; T getAt(int index, Class&lt;T&gt; type) {
<span class="fc" id="L144">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L145">            Node[] children = _children;</span>
<span class="fc" id="L146">            Node lastNode = children[0];</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            for (Node branch : children) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                    if (index &lt; currentBranchStartIndex + branch.size()) {</span>
<span class="fc" id="L150">                        lastNode = branch;</span>
<span class="fc" id="L151">                        break;</span>
                    }
<span class="fc" id="L153">                    currentBranchStartIndex += branch.size();</span>
                }
            }
<span class="fc" id="L156">            int childIndex = index - currentBranchStartIndex;</span>
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">            if (childIndex &lt; 0 || childIndex &gt;= lastNode.size()) {</span>
<span class="nc" id="L158">                throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
            }
<span class="fc" id="L160">            return lastNode.getAt(childIndex, type);</span>
        }

        @Override
        public @Nullable Node slice(
            final int from,
            final int to,
            final Class&lt;?&gt; type,
            final boolean allowsNull
        ) {
<span class="fc" id="L170">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L171">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L172">            @Nullable Node[] newChildren = null;</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L174">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                    if (from &lt; currentBranchStartIndex + branch.size()) {</span>
<span class="fc" id="L177">                        int childFrom = Math.max(0, from - currentBranchStartIndex);</span>
<span class="fc" id="L178">                        int childTo = Math.min(to - currentBranchStartIndex, branch.size());</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                        if (childFrom &lt; childTo) {</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                            if (newChildren == null)</span>
<span class="fc" id="L181">                                newChildren = new Node[children.length];</span>
<span class="fc" id="L182">                            newChildren[i] = branch.slice(childFrom, childTo, type, allowsNull);</span>
                        }
                    }
<span class="fc" id="L185">                    currentBranchStartIndex += branch.size();</span>
                }
            }
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            if ( newChildren == null )</span>
<span class="nc" id="L189">                return null;</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            else if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L191">                return null;</span>
            else
<span class="fc" id="L193">                return new BranchNode(newChildren);</span>
        }

        @Override
        public @Nullable Node removeRange(
            final int from,
            final int to,
            final Class&lt;?&gt; type,
            final boolean allowsNull
        ) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">            if ( from == to )</span>
<span class="nc" id="L204">                return this;</span>
<span class="fc" id="L205">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L206">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L207">            Node[] newChildren = children;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L209">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc" id="L211">                    int nextPosition = currentBranchStartIndex + branch.size();</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                    if (from &lt; nextPosition) {</span>
<span class="fc" id="L213">                        int childFrom = Math.max(0, from - currentBranchStartIndex);</span>
<span class="fc" id="L214">                        int childTo = Math.min(to - currentBranchStartIndex, branch.size());</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">                        if (childFrom &lt; childTo) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                            if (newChildren == children)</span>
<span class="fc" id="L217">                                newChildren = children.clone();</span>
<span class="fc" id="L218">                            newChildren[i] = branch.removeRange(childFrom, childTo, type, allowsNull);</span>
                        }
                    }
<span class="fc" id="L221">                    currentBranchStartIndex = nextPosition;</span>
                }
            }
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if ( newChildren == children )</span>
<span class="nc" id="L225">                return this; // this was not affected</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">            else if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L227">                return null;</span>
            else
<span class="fc" id="L229">                return new BranchNode(newChildren);</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node addAllAt(int index, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, boolean allowsNull) {
<span class="fc" id="L234">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L235">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L236">            Node[] newChildren = children;</span>
<span class="fc" id="L237">            int bestIndex = -1;</span>
<span class="fc" id="L238">            int bestIndexStart = -1;</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L240">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc" id="L242">                    int nextPosition = currentBranchStartIndex + branch.size();</span>
<span class="fc bfc" id="L243" title="All 4 branches covered.">                    if ( currentBranchStartIndex &lt;= index &amp;&amp; index &lt;= nextPosition ) {</span>
<span class="fc" id="L244">                        bestIndex = i;</span>
<span class="fc" id="L245">                        bestIndexStart = currentBranchStartIndex;</span>
                    }
<span class="fc" id="L247">                    currentBranchStartIndex = nextPosition;</span>
                }
            }
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">            if (newChildren == children)</span>
<span class="fc" id="L251">                newChildren = children.clone();</span>
<span class="fc" id="L252">            int childIndex = index - bestIndexStart;</span>
<span class="fc" id="L253">            Node branch = newChildren[bestIndex];</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">            if ( branch == null )</span>
<span class="nc" id="L255">                newChildren[bestIndex] = _createRootFromList(type, allowsNull, tuple.toList());</span>
            else
<span class="fc" id="L257">                newChildren[bestIndex] = branch.addAllAt(childIndex, tuple, type, allowsNull);</span>

<span class="pc bpc" id="L259" title="1 of 2 branches missed.">            if (newChildren[bestIndex] == branch)</span>
<span class="nc" id="L260">                throw new IllegalStateException(&quot;TupleNode was not modified&quot;);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">            if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L262">                throw new IllegalStateException(&quot;TupleNode is all null&quot;);</span>
            else
<span class="fc" id="L264">                return new BranchNode(newChildren);</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node setAllAt(int index, int offset, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, boolean allowsNull) {
<span class="fc" id="L269">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L270">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L271">            Node[] newChildren = children;</span>
<span class="fc" id="L272">            int endIndex = index + tuple.size();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L274">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc" id="L276">                    int nextPosition = currentBranchStartIndex + branch.size();</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                    if ( endIndex &lt;= currentBranchStartIndex )</span>
<span class="fc" id="L278">                        break;</span>
<span class="fc bfc" id="L279" title="All 4 branches covered.">                    if (currentBranchStartIndex &lt;= index &amp;&amp; index &lt; nextPosition) {</span>
<span class="fc" id="L280">                        int childIndex = index - currentBranchStartIndex;</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                        if (newChildren == children)</span>
<span class="fc" id="L282">                            newChildren = children.clone();</span>
<span class="fc" id="L283">                        newChildren[i] = branch.setAllAt(childIndex, offset, tuple, type, allowsNull);</span>
<span class="pc bpc" id="L284" title="1 of 4 branches missed.">                    } else if (currentBranchStartIndex &lt;= endIndex &amp;&amp; endIndex &lt; nextPosition) {</span>
<span class="fc" id="L285">                        int childIndex = 0;</span>
<span class="fc" id="L286">                        int additionalOffset = offset + (currentBranchStartIndex - index);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                        if (newChildren == children)</span>
<span class="nc" id="L288">                            newChildren = children.clone();</span>
<span class="fc" id="L289">                        newChildren[i] = branch.setAllAt(childIndex, additionalOffset, tuple, type, allowsNull);</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">                    } else if (index &lt;= currentBranchStartIndex &amp;&amp; nextPosition &lt;= endIndex ) {</span>
<span class="fc" id="L291">                        int childIndex = 0;</span>
<span class="fc" id="L292">                        int additionalOffset = offset + (currentBranchStartIndex - index);</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">                        if (newChildren == children)</span>
<span class="nc" id="L294">                            newChildren = children.clone();</span>
<span class="fc" id="L295">                        newChildren[i] = branch.setAllAt(childIndex, additionalOffset, tuple, type, allowsNull);</span>
                    }
<span class="fc" id="L297">                    currentBranchStartIndex += branch.size();</span>
                }
            }
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">            if ( newChildren == children )</span>
<span class="nc" id="L301">                return this; // this was not affected</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">            else if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L303">                return null;</span>
            else
<span class="fc" id="L305">                return new BranchNode(newChildren);</span>
        }

        @Override
        public &lt;T&gt; void forEach(Class&lt;T&gt; type, Consumer&lt;T&gt; consumer) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">            for (Node branch : _children) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (branch != null)</span>
<span class="nc" id="L312">                    branch.forEach(type, consumer);</span>
            }
<span class="nc" id="L314">        }</span>
    }

    private final int _size;
    private final boolean _allowsNull;
    private final Class&lt;T&gt; _type;
    private final Node _root;

    @SuppressWarnings(&quot;NullAway&quot;)
    public static &lt;T&gt; TupleHamt&lt;T&gt; of(
        boolean allowsNull,
        Class&lt;T&gt; type,
        List&lt;T&gt; items
    ) {
<span class="fc" id="L328">        return new TupleHamt(</span>
<span class="fc" id="L329">                items.size(),</span>
                allowsNull,
                type,
<span class="fc" id="L332">                _createRootFromList(type, allowsNull, items)</span>
            );
    }

    public static &lt;T&gt; TupleHamt&lt;T&gt; of(
        boolean allowsNull,
        Class&lt;T&gt; type,
        @Nullable T... items
    ) {
<span class="fc" id="L341">        return of(allowsNull, type, Arrays.asList(items));</span>
    }

    public static &lt;T&gt; TupleHamt&lt;T&gt; ofRaw(
            boolean allowsNull,
            Class&lt;T&gt; type,
            Object data
    ) {
<span class="fc" id="L349">        LeafNode leaf = new LeafNode(data);</span>
<span class="fc" id="L350">        return new TupleHamt(</span>
<span class="fc" id="L351">                leaf.size(),</span>
                allowsNull,
                type,
                leaf
        );
    }

    @SuppressWarnings(&quot;NullAway&quot;)
    private TupleHamt(
            int size,
            boolean allowsNull,
            Class&lt;T&gt; type,
            @Nullable Node root
<span class="fc" id="L364">    ) {</span>
<span class="fc" id="L365">        Objects.requireNonNull(type);</span>
<span class="fc" id="L366">        _size = size;</span>
<span class="fc" id="L367">        _allowsNull = allowsNull;</span>
<span class="fc" id="L368">        _type = type;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        _root = root == null ? new LeafNode(_createArray(type, allowsNull, size)) : root;</span>
<span class="fc" id="L370">    }</span>

    private static Node _createRootFromList(Class&lt;?&gt; type, boolean allowsNull, List&lt;?&gt; items) {
<span class="fc bfc" id="L373" title="All 4 branches covered.">        if ( items.isEmpty() || items.size() &lt; MAX_LEAF_NODE_SIZE )</span>
<span class="fc" id="L374">            return new LeafNode(_createArrayFromList(type, allowsNull, items));</span>
<span class="fc" id="L375">        Node[] branches = new Node[BRANCHING_FACTOR];</span>
<span class="fc" id="L376">        int stepSize = items.size() / branches.length;</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (int i = 0; i &lt; branches.length; i++) {</span>
<span class="fc" id="L378">            int start = i * stepSize;</span>
<span class="fc" id="L379">            int end = (i + 1) * stepSize;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (i == branches.length - 1) {</span>
<span class="fc" id="L381">                end = items.size();</span>
            }
<span class="fc" id="L383">            List&lt;?&gt; subList = items.subList(start, end);</span>
<span class="fc" id="L384">            branches[i] = _createRootFromList(type, allowsNull, subList);</span>
        }
<span class="fc" id="L386">        return new BranchNode(branches);</span>
    }


    @Override
    public Class&lt;T&gt; type() {
<span class="fc" id="L392">        return _type;</span>
    }

    @Override
    public int size() {
<span class="fc" id="L397">        return _size;</span>
    }

    @Override
    @SuppressWarnings(&quot;NullAway&quot;)
    public T get(int index) {
<span class="pc bpc" id="L403" title="2 of 4 branches missed.">        if (index &lt; 0 || index &gt;= _size) {</span>
<span class="nc" id="L404">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
        }
<span class="fc" id="L406">        return _root.getAt(index, _type);</span>
    }

    @Override
    public boolean allowsNull() {
<span class="fc" id="L411">        return _allowsNull;</span>
    }

    @Override
    public TupleHamt&lt;T&gt; slice(int from, int to) {
<span class="pc bpc" id="L416" title="3 of 6 branches missed.">        if (from &lt; 0 || to &gt; _size || from &gt; to) {</span>
<span class="nc" id="L417">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + from + &quot;, Size: &quot; + _size);</span>
        }
<span class="pc bpc" id="L419" title="1 of 2 branches missed.">        if ( from &gt; to )</span>
<span class="nc" id="L420">            throw new IllegalArgumentException();</span>

<span class="fc" id="L422">        int newSize = (to - from);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if ( newSize == this.size() )</span>
<span class="nc" id="L424">            return this;</span>

<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        if ( newSize == 0 ) {</span>
<span class="nc" id="L427">            SequenceDiff diff = SequenceDiff.of(this, SequenceChange.RETAIN, -1, 0);</span>
<span class="nc" id="L428">            Node newRoot = _createRootFromList(_type, _allowsNull, Collections.emptyList());</span>
<span class="nc" id="L429">            return new TupleHamt&lt;&gt;(0, _allowsNull, _type, newRoot);</span>
        }
<span class="fc" id="L431">        Node newRoot = _root.slice(from, to, _type, _allowsNull);</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L433">            return this;</span>
<span class="fc" id="L434">        return new TupleHamt&lt;&gt;(newSize, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleHamt&lt;T&gt; removeRange(int from, int to) {
<span class="pc bpc" id="L439" title="2 of 4 branches missed.">        if ( from &lt; 0 || to &gt; _size )</span>
<span class="nc" id="L440">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + from + &quot;, Size: &quot; + _size);</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if ( from &gt; to )</span>
<span class="nc" id="L442">            throw new IllegalArgumentException();</span>
<span class="fc" id="L443">        int numberOfItemsToRemove = to - from;</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if ( numberOfItemsToRemove == 0 )</span>
<span class="nc" id="L445">            return this;</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if ( numberOfItemsToRemove == this.size() ) {</span>
<span class="nc" id="L447">            return new TupleHamt&lt;&gt;(0, _allowsNull, _type, null);</span>
        }
<span class="fc" id="L449">        Node newRoot = _root.removeRange(from, to, _type, _allowsNull);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L451">            return this;</span>
<span class="fc" id="L452">        return new TupleHamt&lt;&gt;(_size - numberOfItemsToRemove, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleHamt&lt;T&gt; removeAll(Tuple&lt;T&gt; properties) {
<span class="fc bfc" id="L457" title="All 2 branches covered.">        if (properties.size() == 0) {</span>
<span class="fc" id="L458">            return this;</span>
        }
<span class="fc" id="L460">        List&lt;T&gt; newItems = new ArrayList&lt;&gt;(_size);</span>
<span class="fc" id="L461">        Set&lt;T&gt; toRemove = properties.toSet();</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L463">            T item = get(i);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">            if (!toRemove.contains(item)) {</span>
<span class="fc" id="L465">                newItems.add(item);</span>
            }
        }
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (newItems.size() == _size) {</span>
<span class="fc" id="L469">            return this;</span>
        }
<span class="fc" id="L471">        return new TupleHamt&lt;&gt;(newItems.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, newItems));</span>
    }

    @Override
    public TupleHamt&lt;T&gt; addAt(int index, T item) {
<span class="fc bfc" id="L476" title="All 4 branches covered.">        if ( !this.allowsNull() &amp;&amp; item == null )</span>
<span class="fc" id="L477">            throw new NullPointerException();</span>
<span class="pc bpc" id="L478" title="2 of 4 branches missed.">        if ( index &lt; 0 || index &gt; _size )</span>
<span class="nc" id="L479">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">        Tuple&lt;T&gt; singleton = _allowsNull ? Tuple.ofNullable(type(), item) : Tuple.of(item);</span>
<span class="fc" id="L482">        Node newRoot = _root.addAllAt(index, singleton, _type, _allowsNull);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L484">            return this;</span>
<span class="fc" id="L485">        return new TupleHamt&lt;&gt;(_size+1, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleHamt&lt;T&gt; setAt(int index, T item) {
<span class="pc bpc" id="L490" title="2 of 4 branches missed.">        if ( index &lt; 0 || index &gt;= _size )</span>
<span class="nc" id="L491">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
<span class="pc bpc" id="L492" title="1 of 4 branches missed.">        if ( !this.allowsNull() &amp;&amp; item == null )</span>
<span class="fc" id="L493">            throw new NullPointerException();</span>
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        return setAllAt(index, _allowsNull ? Tuple.ofNullable(type(), item) : Tuple.of(item));</span>
    }

    @Override
    public TupleHamt&lt;T&gt; addAllAt(int index, Tuple&lt;T&gt; tuple) {
<span class="fc" id="L499">        Objects.requireNonNull(tuple);</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if ( tuple.isEmpty() )</span>
<span class="fc" id="L501">            return this; // nothing to do</span>
<span class="fc bfc" id="L502" title="All 4 branches covered.">        if ( !this.allowsNull() &amp;&amp; tuple.allowsNull() )</span>
<span class="fc" id="L503">            throw new NullPointerException();</span>
<span class="pc bpc" id="L504" title="2 of 4 branches missed.">        if ( index &lt; 0 || index &gt; _size )</span>
<span class="nc" id="L505">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
<span class="fc" id="L506">        Node newRoot = _root.addAllAt(index, tuple, _type, _allowsNull);</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L508">            return this;</span>
<span class="fc" id="L509">        return new TupleHamt&lt;&gt;(_size+tuple.size(), _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleHamt&lt;T&gt; setAllAt(int index, Tuple&lt;T&gt; tuple) {
<span class="fc" id="L514">        Objects.requireNonNull(tuple);</span>
<span class="pc bpc" id="L515" title="1 of 4 branches missed.">        if ( !this.allowsNull() &amp;&amp; tuple.allowsNull() )</span>
<span class="fc" id="L516">            throw new NullPointerException();</span>
<span class="pc bpc" id="L517" title="2 of 4 branches missed.">        if ( index &lt; 0 || index + tuple.size() &gt; size() )</span>
<span class="nc" id="L518">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
<span class="fc" id="L519">        Node newRoot = _root.setAllAt(index, 0, tuple, _type, _allowsNull);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if ( newRoot == _root )</span>
<span class="fc" id="L521">            return this;</span>
<span class="fc" id="L522">        return new TupleHamt&lt;&gt;(_size, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public Tuple&lt;T&gt; retainAll(Tuple&lt;T&gt; tuple) {
<span class="nc" id="L527">        Objects.requireNonNull(tuple);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if ( tuple.isEmpty() ) {</span>
<span class="nc" id="L529">            Node newRoot = _createRootFromList(_type, _allowsNull, Collections.emptyList());</span>
<span class="nc" id="L530">            return new TupleHamt&lt;&gt;(0, _allowsNull, _type, newRoot);</span>
        }
<span class="nc" id="L532">        int[] indicesOfThingsToKeep = new int[this.size()];</span>
<span class="nc" id="L533">        int newSize = 0;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        int singleSequenceIndex = size() &gt; 0 ? -2 : -1;</span>
<span class="nc" id="L535">        int retainSequenceSize = 0;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        for ( int i = 0; i &lt; this.size(); i++ ) {</span>
<span class="nc" id="L537">            int index = tuple.firstIndexOf( get(i) );</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if ( index != -1 ) {</span>
<span class="nc" id="L539">                indicesOfThingsToKeep[newSize] = i;</span>
<span class="nc" id="L540">                newSize++;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if ( singleSequenceIndex != -1 ) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                    if ( singleSequenceIndex == -2 )</span>
<span class="nc" id="L543">                        singleSequenceIndex = i;</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                    else if ( i &gt; singleSequenceIndex + retainSequenceSize )</span>
<span class="nc" id="L545">                        singleSequenceIndex = -1;</span>
                }
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if ( singleSequenceIndex &gt;= 0 )</span>
<span class="nc" id="L548">                    retainSequenceSize++;</span>
            } else {
<span class="nc" id="L550">                indicesOfThingsToKeep[newSize] = -1;</span>
            }
        }
<span class="nc" id="L553">        return _retainAll(singleSequenceIndex, newSize, indicesOfThingsToKeep);</span>
    }

    TupleHamt&lt;T&gt; _retainAll(int singleSequenceIndex, int newSize, int[] indicesOfThingsToKeep) {
<span class="fc bfc" id="L557" title="All 2 branches covered.">        if ( newSize == this.size() )</span>
<span class="fc" id="L558">            return this;</span>
<span class="fc" id="L559">        List&lt;T&gt; newItems = new ArrayList&lt;&gt;(newSize);</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">        for ( int i = 0; i &lt; newSize; i++ ) {</span>
<span class="fc" id="L561">            int index = indicesOfThingsToKeep[i];</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">            if ( index != -1 )</span>
<span class="fc" id="L563">                newItems.add(get(index));</span>
        }
<span class="fc" id="L565">        Node newRoot = _createRootFromList(_type, _allowsNull, newItems);</span>
<span class="fc" id="L566">        return new TupleHamt&lt;&gt;(newItems.size(), _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleHamt&lt;T&gt; clear() {
<span class="fc" id="L571">        return new TupleHamt&lt;&gt;(0, _allowsNull, _type, null);</span>
    }

    @Override
    public TupleHamt&lt;T&gt; sort(Comparator&lt;T&gt; comparator) {
<span class="fc" id="L576">        List&lt;T&gt; sortedList = new ArrayList&lt;&gt;(_size);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L578">            sortedList.add(get(i));</span>
        }
<span class="fc" id="L580">        sortedList.sort(comparator);</span>
<span class="fc" id="L581">        return new TupleHamt&lt;&gt;(sortedList.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, sortedList));</span>
    }

    @Override
    public TupleHamt&lt;T&gt; makeDistinct() {
<span class="fc" id="L586">        Set&lt;T&gt; distinctSet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L588">            distinctSet.add(get(i));</span>
        }
<span class="fc" id="L590">        List&lt;T&gt; distinctList = new ArrayList&lt;&gt;(distinctSet);</span>
<span class="fc" id="L591">        return new TupleHamt&lt;&gt;(distinctList.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, distinctList));</span>
    }

    @Override
    public TupleHamt&lt;T&gt; reversed() {
<span class="fc" id="L596">        List&lt;T&gt; reversedList = new ArrayList&lt;&gt;(_size);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        for (int i = _size - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L598">            reversedList.add(get(i));</span>
        }
<span class="fc" id="L600">        return new TupleHamt&lt;&gt;(reversedList.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, reversedList));</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L605">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L606">        sb.append(&quot;Tuple&lt;&quot;);</span>
<span class="fc" id="L607">        sb.append(_type.getSimpleName());</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">        if (allowsNull())</span>
<span class="fc" id="L609">            sb.append(&quot;?&quot;);</span>
<span class="fc" id="L610">        sb.append(&quot;&gt;[&quot;);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L612">            sb.append(get(i));</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">            if (i &lt; _size - 1)</span>
<span class="fc" id="L614">                sb.append(&quot;, &quot;);</span>
        }
<span class="fc" id="L616">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L617">        return sb.toString();</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L623">            return true;</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">        if (!(obj instanceof Tuple))</span>
<span class="nc" id="L625">            return false;</span>
<span class="fc" id="L626">        Tuple&lt;?&gt; other = (Tuple&lt;?&gt;) obj;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (other.allowsNull() != this.allowsNull())</span>
<span class="fc" id="L628">            return false;</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">        if (other.size() != this.size())</span>
<span class="fc" id="L630">            return false;</span>
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">        if (!other.type().equals(_type))</span>
<span class="nc" id="L632">            return false;</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        for (int i = 0; i &lt; this.size(); i++) {</span>
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">            if (!Objects.equals(this.get(i), other.get(i)))</span>
<span class="nc" id="L635">                return false;</span>
        }
<span class="fc" id="L637">        return true;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L642">        int hash = _type.hashCode() ^ _size;</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L644">            T item = get(i);</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">            hash = 31 * hash + (item == null ? 0 : item.hashCode());</span>
        }
<span class="fc bfc" id="L647" title="All 2 branches covered.">        return hash ^ (_allowsNull ? 1 : 0);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>