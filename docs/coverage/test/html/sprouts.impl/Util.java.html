<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Util.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">Util.java</span></div><h1>Util.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.NonNull;
import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.helpers.MessageFormatter;
import org.slf4j.helpers.NOPLogger;
import sprouts.From;

import java.lang.reflect.UndeclaredThrowableException;
import java.util.function.Function;
import java.util.function.Supplier;

final class Util {

<span class="fc" id="L16">    public static From VIEW_CHANNEL = From.ALL;</span>

    private Util() {}

    static void sneakyThrowExceptionIfFatal(Throwable throwable) {
<span class="pc bpc" id="L21" title="1 of 2 branches missed.">        if (</span>
            throwable instanceof UndeclaredThrowableException &amp;&amp;
<span class="nc bnc" id="L23" title="All 2 branches missed.">            throwable.getCause() instanceof InterruptedException</span>
        ) {
<span class="nc" id="L25">            throwable = throwable.getCause();</span>
        }
<span class="fc bfc" id="L27" title="All 2 branches covered.">        if (isFatal(throwable)) {</span>
<span class="pc bpc" id="L28" title="1 of 2 branches missed.">            if (throwable instanceof InterruptedException) {</span>
<span class="fc" id="L29">                Thread.currentThread().interrupt();</span>
            }
<span class="nc" id="L31">            sneakyThrow(throwable);</span>
        }
<span class="fc" id="L33">    }</span>

    static boolean isFatal(Throwable throwable) {
<span class="pc bpc" id="L36" title="1 of 4 branches missed.">        return throwable instanceof InterruptedException</span>
                || throwable instanceof LinkageError
<span class="pc bpc" id="L38" title="2 of 4 branches missed.">                || ThreadDeathResolver.isThreadDeath(throwable)</span>
                || throwable instanceof VirtualMachineError;
    }

    private static class ThreadDeathResolver {
<span class="fc" id="L43">        static final @Nullable Class&lt;?&gt; THREAD_DEATH_CLASS = resolve();</span>

        static boolean isThreadDeath(Throwable throwable) {
<span class="pc bpc" id="L46" title="2 of 4 branches missed.">            return THREAD_DEATH_CLASS != null &amp;&amp; THREAD_DEATH_CLASS.isInstance(throwable);</span>
        }

        private static @Nullable Class&lt;?&gt; resolve() {
            try {
<span class="fc" id="L51">                return Class.forName(&quot;java.lang.ThreadDeath&quot;);</span>
<span class="nc" id="L52">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L53">                return null;</span>
            }
        }
    }

    @SuppressWarnings({&quot;unchecked&quot;, &quot;TypeParameterUnusedInFormals&quot;})
    static &lt;E extends Throwable, R&gt; R sneakyThrow(Throwable e) throws E {
<span class="fc" id="L60">        throw (E) e; // throw the returned thing and the compiler believes this is unchecked</span>
    }

    static void _logError(Logger log, String message, @Nullable Object... args) {
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        if ( log instanceof NOPLogger) {</span>
<span class="fc" id="L65">            Exception lastArgException = null;</span>
<span class="pc bpc" id="L66" title="2 of 6 branches missed.">            if ( args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[args.length - 1] instanceof Exception ) {</span>
<span class="fc" id="L67">                lastArgException = (Exception) args[args.length - 1];</span>
<span class="fc" id="L68">                args = java.util.Arrays.copyOf(args, args.length - 1);</span>
            }
<span class="fc" id="L70">            String loggingMarker = Sprouts.factory().loggingMarker().toString().trim();</span>
<span class="pc bpc" id="L71" title="5 of 6 branches missed.">            if ( !loggingMarker.isEmpty() &amp;&amp; !loggingMarker.startsWith(&quot;[&quot;) &amp;&amp; !loggingMarker.endsWith(&quot;]&quot;) ) {</span>
<span class="nc" id="L72">                loggingMarker = &quot;[&quot; + loggingMarker + &quot;]&quot;;</span>
            }
<span class="fc" id="L74">            System.err.println(</span>
<span class="fc" id="L75">                MessageFormatter.arrayFormat(&quot;[ERROR]&quot;+loggingMarker+&quot; &quot; + message, args)</span>
<span class="fc" id="L76">                .getMessage()</span>
            );
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if ( lastArgException != null ) {</span>
<span class="fc" id="L79">                lastArgException.printStackTrace();</span>
            }
<span class="fc" id="L81">        } else {</span>
<span class="nc" id="L82">            log.error(Sprouts.factory().loggingMarker(), message, args);</span>
        }
<span class="fc" id="L84">    }</span>

    static String _toString( @Nullable Object singleItem, Class&lt;?&gt; type ) {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if ( singleItem == null ) {</span>
<span class="nc" id="L88">            return &quot;null&quot;;</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        } else if ( type == String.class ) {</span>
<span class="fc" id="L90">            return &quot;\&quot;&quot; + singleItem + &quot;\&quot;&quot;;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">        } else if ( type == Character.class ) {</span>
<span class="fc" id="L92">            return &quot;'&quot; + singleItem + &quot;'&quot;;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">        } else if ( type == Boolean.class ) {</span>
<span class="fc" id="L94">            return singleItem.toString();</span>
        } else {
<span class="fc" id="L96">            return singleItem.toString();</span>
        }
    }

    @SuppressWarnings(&quot;ReferenceEquality&quot;)
    static boolean refEquals(@Nullable Object a, @Nullable Object b) {
        // We use == here to compare references, not .equals()!
<span class="fc bfc" id="L103" title="All 2 branches covered.">        return a == b;</span>
    }

    static &lt;T extends @Nullable Object, R&gt; Function&lt;T, R&gt; nonNullMapper(Logger log, R nullObject, R errorObject, Function&lt;T, @Nullable R&gt; mapper) {
<span class="fc" id="L107">        return t -&gt; {</span>
            try {
<span class="fc" id="L109">                @Nullable R r = mapper.apply(t);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">                return r == null ? nullObject : r;</span>
<span class="fc" id="L111">            } catch (Exception e) {</span>
<span class="fc" id="L112">                Util.sneakyThrowExceptionIfFatal(e);</span>
<span class="fc" id="L113">                _logError(log, &quot;An error occurred while mapping item '{}'.&quot;, t, e);</span>
<span class="fc" id="L114">                return errorObject;</span>
            }
        };
    }

    /**
     *  Returns the &lt;b&gt;expected&lt;/b&gt; class of the property type of the given item.
     *  This is in the vast majority of cases simply {@code item.getClass()}
     *  but in case of an enum constant with an anonymous implementation
     *  {@code getClass()} returns the anonymous class instead of the enum class.
     * @param item The item to get the property type class from.
     * @return The expected class of the property type of the given item.
     * @param &lt;T&gt; The type of the item.
     */
    static &lt;T&gt; Class&lt;T&gt; expectedClassFromItem( @NonNull T item ) {
<span class="fc" id="L129">        Class&lt;?&gt; itemType = item.getClass();</span>
        // We check if it is an enum:
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if ( Enum.class.isAssignableFrom(itemType) ) {</span>
            /*
                When it comes to enums, there is a pitfall we might
                fall into if just return the Class instance right away!
                The pitfall is that an enum constant may actually be
                an instance of an anonymous inner class instead an
                instance of the actual enum type!

                Check out this example enum:

                public enum Food {
                    TOFU { @Override public String toString() { return &quot;Tofu&quot;; } },
                    TEMPEH { @Override public String toString() { return &quot;Tempeh&quot;; } },
                    SEITAN { @Override public String toString() { return &quot;Seitan&quot;; } },
                    NATTO { @Override public String toString() { return &quot;Natto&quot;; } }
                }

                The problem with the enum declared above is that two
                different enum constant instances have different class instances,
                which is to say the following is true:

                Food.TOFU.getClass() != Food.SEITAN.getClass()

                ...and also:

                Food.class != Food.TOFU.getClass()
            */
            // Let's check for that:
<span class="fc" id="L159">            Class&lt;?&gt; superClass = itemType.getSuperclass();</span>
<span class="pc bpc" id="L160" title="1 of 4 branches missed.">            if ( superClass != null &amp;&amp; !superClass.equals(Enum.class) ) {</span>
                // We are good to go, it is an enum!
<span class="fc" id="L162">                return (Class&lt;T&gt;) superClass;</span>
            }
        }
<span class="fc" id="L165">        return (Class&lt;T&gt;) itemType;</span>
    }

    /**
     *  Unfortunately, NullAway does not support nullability annotations on type parameters.
     *  It always assumes that type parameters are non-null, irrespective if
     *  the user provides a nullability annotation or not.
     *  This is a problem in the sprouts library, which also uses nullability annotations.
     *  This method is a workaround for this issue.
     *
     * @param var The variable to be faked as non-null.
     * @return The same variable as the input, but with a non-null type.
     * @param &lt;T&gt; The type of the variable.
     */
    @SuppressWarnings(&quot;NullAway&quot;)
    static &lt;T&gt; T fakeNonNull( @Nullable T var ) {
<span class="fc" id="L181">        return var;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>