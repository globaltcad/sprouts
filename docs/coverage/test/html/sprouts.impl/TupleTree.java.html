<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TupleTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">TupleTree.java</span></div><h1>TupleTree.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.Tuple;
import sprouts.Val;

import java.lang.reflect.Array;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import static sprouts.impl.ArrayUtil.*;

/**
 * An immutable, persistent tuple (ordered sequence) implementation based on a multi-branch tree structure.
 * This provides efficient O(log32 n) positional access, slicing, and bulk operations while maximizing
 * structural sharing for memory efficiency.
 *
 * &lt;h2&gt;Design Overview&lt;/h2&gt;
 * &lt;p&gt;The tree consists of two node types:&lt;/p&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;&lt;strong&gt;Leaf nodes&lt;/strong&gt;: Store elements in contiguous arrays (up to {@value #IDEAL_LEAF_NODE_SIZE} elements)&lt;/li&gt;
 *   &lt;li&gt;&lt;strong&gt;Branch nodes&lt;/strong&gt;: Hold references to subtrees with a branching factor of {@value #BRANCHING_FACTOR},
 *       using cumulative subtree sizes for index resolution&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Performance Characteristics&lt;/h2&gt;
 * &lt;table border=&quot;1&quot;&gt;
 *   &lt;caption&gt;Operation Complexities&lt;/caption&gt;
 *   &lt;tr&gt;&lt;th&gt;Operation&lt;/th&gt;&lt;th&gt;Time&lt;/th&gt;&lt;th&gt;Space&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@link #get(int)}&lt;/td&gt;&lt;td&gt;O(log32 n)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@link #slice(int, int)}&lt;/td&gt;&lt;td&gt;O(log32 n)&lt;/td&gt;&lt;td&gt;O(log32 n) shared&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@link #addAllAt(int, Tuple)}&lt;/td&gt;&lt;td&gt;O(log32 n + m)&lt;/td&gt;&lt;td&gt;O(log32 n + m)&lt;/td&gt;&lt;/tr&gt;
 *   &lt;tr&gt;&lt;td&gt;{@link #setAt(int, Object)}&lt;/td&gt;&lt;td&gt;O(log32 n)&lt;/td&gt;&lt;td&gt;O(log32 n)&lt;/td&gt;&lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;h2&gt;Structural Sharing&lt;/h2&gt;
 * &lt;p&gt;All modification operations return new tuples that maximally share structure with the original:
 * &lt;pre&gt;{@code
 * Tuple&lt;String&gt; original = Tuple.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);
 * Tuple&lt;String&gt; modified = original.setAt(1, &quot;X&quot;);
 * // Only the path from root to modified leaf is copied
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Use Cases&lt;/h2&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Immutable sequences requiring frequent slicing/subsequence operations&lt;/li&gt;
 *   &lt;li&gt;Edit-heavy workflows where versions share most content (e.g., document history)&lt;/li&gt;
 *   &lt;li&gt;As a building block for persistent collections&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Implementation Notes&lt;/h2&gt;
 * &lt;ul&gt;
 *   &lt;li&gt;Null elements are permitted only when constructed with {@code allowsNull=true}&lt;/li&gt;
 *   &lt;li&gt;Iteration uses stack-based traversal for O(1) per-element overhead&lt;/li&gt;
 *   &lt;li&gt;Automatic leaf consolidation/splitting maintains size invariants&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;br&gt;
 * Also note that when this tuple tree is constructed from
 * another sequenced collection with a known size, like an array or list,
 * then there will only be a single leaf node with one large array holding all elements.
 * Only after adding or removing from this initial densely packed tuple, will a
 * tree structure be created to accommodate for followup operations...
 *
 * @param &lt;T&gt; the type of elements in this tuple
 *
 * @see sprouts.Association
 * @see sprouts.ValueSet
 * @see sprouts.Tuple
 * @see sprouts.Pair
 */
final class TupleTree&lt;T extends @Nullable Object&gt; implements Tuple&lt;T&gt; {

    private static final int BRANCHING_FACTOR = 32;
    private static final int IDEAL_LEAF_NODE_SIZE = 512;


    interface Node {
        int size();

        &lt;T&gt; T getAt(int index, ArrayItemAccess&lt;T, Object&gt; access);

        @Nullable
        Node slice(int from, int to, Class&lt;?&gt; type, boolean allowsNull);

        @Nullable
        Node removeRange(int from, int to, Class&lt;?&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull);

        @Nullable &lt;T&gt; Node addAllAt(int index, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull);

        @Nullable &lt;T&gt; Node setAllAt(int index, int offset, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull);

        &lt;T&gt; void forEach(ArrayItemAccess&lt;T, Object&gt; access, Consumer&lt;T&gt; consumer);
    }

    static final class LeafNode implements Node {
        private final Object _data;

<span class="fc" id="L101">        LeafNode(Object data) {</span>
<span class="fc" id="L102">            _data = data;</span>
<span class="fc" id="L103">        }</span>

        public Object data() {
<span class="fc" id="L106">            return  _data;</span>
        }

        @Override
        public int size() {
<span class="fc" id="L111">            return _length(_data);</span>
        }

        @Override
        public &lt;T&gt; T getAt(int index, ArrayItemAccess&lt;T, Object&gt; access) {
<span class="fc" id="L116">            return Util.fakeNonNull(access.get(index, _data));</span>
        }

        @Override
        public @Nullable Node slice(int from, int to, Class&lt;?&gt; type, boolean allowsNull) {
<span class="fc bfc" id="L121" title="All 4 branches covered.">            if ( from == 0 &amp;&amp; to == _length(_data) )</span>
<span class="fc" id="L122">                return this;</span>
            else {
<span class="fc" id="L124">                int newSize = (to - from);</span>
<span class="fc" id="L125">                Object newItems = _createArray(type, allowsNull, newSize);</span>
<span class="fc" id="L126">                System.arraycopy(_data, from, newItems, 0, newSize);</span>
<span class="fc" id="L127">                return new LeafNode(newItems);</span>
            }
        }

        @Override
        public @Nullable Node removeRange(int from, int to, Class&lt;?&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull) {
<span class="pc bpc" id="L133" title="2 of 4 branches missed.">            if ( from &lt; 0 || to &gt; _length(_data) )</span>
<span class="nc" id="L134">                return this;</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if ( from &gt; to )</span>
<span class="nc" id="L136">                return this;</span>
<span class="fc" id="L137">            int numberOfItemsToRemove = to - from;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if ( numberOfItemsToRemove == 0 )</span>
<span class="nc" id="L139">                return this;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if ( numberOfItemsToRemove == this.size() )</span>
<span class="fc" id="L141">                return null;</span>
            else {
<span class="fc" id="L143">                int newSize = _length(_data) - numberOfItemsToRemove;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">                if ( newSize &gt; IDEAL_LEAF_NODE_SIZE) {</span>
<span class="fc" id="L145">                    return _createRootFromList(type, allowsNull, new AbstractList() {</span>
                        @Override
                        public int size() {
<span class="fc" id="L148">                            return newSize;</span>
                        }
                        @Override
                        public @Nullable Object get(int fetchIndex) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">                            if ( fetchIndex &gt;= from ) {</span>
<span class="fc" id="L153">                                fetchIndex = fetchIndex + numberOfItemsToRemove;</span>
                            }
<span class="fc" id="L155">                            return access.get(fetchIndex, _data);</span>
                        }
                    });
                }
<span class="fc" id="L159">                return new LeafNode(_withRemoveRange(from, to, _data, type, allowsNull));</span>
            }
        }

        @Override
        public @Nullable &lt;T&gt; Node addAllAt(int index, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull) {
<span class="fc" id="L165">            int currentSize = _length(_data);</span>
<span class="fc" id="L166">            int newSize = (currentSize + tuple.size());</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if ( newSize &gt; IDEAL_LEAF_NODE_SIZE) {</span>
<span class="fc" id="L168">                return _createRootFromList(type, allowsNull, new AbstractList&lt;T&gt;() {</span>
                    @Override
                    public int size() {
<span class="fc" id="L171">                        return newSize;</span>
                    }
                    @Override
                    @SuppressWarnings(&quot;unchecked&quot;)
                    public @Nullable T get(int fetchIndex) {
<span class="fc bfc" id="L176" title="All 2 branches covered.">                        if ( fetchIndex &lt; index ) {</span>
<span class="fc" id="L177">                            return (T) access.get(fetchIndex, _data);</span>
                        }
<span class="fc bfc" id="L179" title="All 2 branches covered.">                        if ( fetchIndex &lt; (index + tuple.size()) ) {</span>
<span class="fc" id="L180">                            return tuple.get(fetchIndex - index);</span>
                        }
<span class="fc" id="L182">                        return (T) access.get(fetchIndex - tuple.size(), _data);</span>
                    }
                });
            }
<span class="fc" id="L186">            Object newItems = _withAddAllAt(index, tuple, _data, type, allowsNull);</span>
<span class="fc" id="L187">            return new LeafNode(newItems);</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node setAllAt(int index, int offset, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull) {
<span class="fc" id="L192">            int currentSize = _length(_data);</span>
<span class="fc" id="L193">            int offsetInTuple = Math.abs(Math.min(0, index))+offset;</span>
<span class="fc" id="L194">            int startIndex = Math.max(0, index);</span>
<span class="fc" id="L195">            boolean isAlreadyTheSame = true;</span>
<span class="fc" id="L196">            Object newItems = _clone(_data, type, allowsNull);</span>
<span class="fc" id="L197">            int numberToSet = Math.min(tuple.size()-offsetInTuple, currentSize - startIndex);</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">            for (int i = 0; i &lt; numberToSet; i++) {</span>
<span class="fc" id="L199">                Object itemToSet = tuple.get(offsetInTuple+i);</span>
<span class="fc" id="L200">                _setAt(startIndex + i, itemToSet, newItems);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">                if ( !Objects.equals(itemToSet, access.get(startIndex+i, _data)) )</span>
<span class="fc" id="L202">                    isAlreadyTheSame = false;</span>
            }
<span class="fc bfc" id="L204" title="All 2 branches covered.">            if ( isAlreadyTheSame )</span>
<span class="fc" id="L205">                return this;</span>
<span class="fc" id="L206">            return new LeafNode(newItems);</span>
        }

        @Override
        public &lt;T&gt; void forEach(ArrayItemAccess&lt;T, Object&gt; access, Consumer&lt;T&gt; consumer) {
<span class="nc" id="L211">            _each(_data, access, consumer);</span>
<span class="nc" id="L212">        }</span>
    }

    static final class BranchNode implements Node {
        private final Node[] _children;
        private final int _size;

<span class="fc" id="L219">        BranchNode(Node[] children) {</span>
<span class="fc" id="L220">            _children = children;</span>
<span class="fc" id="L221">            int sum = 0;</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            for (Node child : children) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">                if ( child != null )</span>
<span class="fc" id="L224">                    sum += child.size();</span>
            }
<span class="fc" id="L226">            _size = sum;</span>
<span class="fc" id="L227">        }</span>

        @Override
        public int size() {
<span class="fc" id="L231">            return _size;</span>
        }

        @Override
        public &lt;T&gt; T getAt(int index, ArrayItemAccess&lt;T, Object&gt; access) {
<span class="fc" id="L236">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L237">            Node[] children = _children;</span>
<span class="fc" id="L238">            Node lastNode = children[0];</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            for (Node branch : children) {</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                    if (index &lt; currentBranchStartIndex + branch.size()) {</span>
<span class="fc" id="L242">                        lastNode = branch;</span>
<span class="fc" id="L243">                        break;</span>
                    }
<span class="fc" id="L245">                    currentBranchStartIndex += branch.size();</span>
                }
            }
<span class="fc" id="L248">            int childIndex = index - currentBranchStartIndex;</span>
<span class="pc bpc" id="L249" title="2 of 4 branches missed.">            if (childIndex &lt; 0 || childIndex &gt;= lastNode.size()) {</span>
<span class="nc" id="L250">                throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
            }
<span class="fc" id="L252">            return lastNode.getAt(childIndex, access);</span>
        }

        @Override
        public @Nullable Node slice(
            final int from,
            final int to,
            final Class&lt;?&gt; type,
            final boolean allowsNull
        ) {
<span class="fc" id="L262">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L263">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L264">            @Nullable Node[] newChildren = null;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L266">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                    if (from &lt; currentBranchStartIndex + branch.size()) {</span>
<span class="fc" id="L269">                        int childFrom = Math.max(0, from - currentBranchStartIndex);</span>
<span class="fc" id="L270">                        int childTo = Math.min(to - currentBranchStartIndex, branch.size());</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                        if (childFrom &lt; childTo) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                            if (newChildren == null)</span>
<span class="fc" id="L273">                                newChildren = new Node[children.length];</span>
<span class="fc" id="L274">                            newChildren[i] = branch.slice(childFrom, childTo, type, allowsNull);</span>
                        }
                    }
<span class="fc" id="L277">                    currentBranchStartIndex += branch.size();</span>
                }
            }
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            if ( newChildren == null )</span>
<span class="nc" id="L281">                return null;</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            else if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L283">                return null;</span>
            else
<span class="fc" id="L285">                return new BranchNode(newChildren);</span>
        }

        @Override
        public @Nullable Node removeRange(
            final int from,
            final int to,
            final Class&lt;?&gt; type,
            ArrayItemAccess&lt;?, Object&gt; access,
            final boolean allowsNull
        ) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">            if ( from == to )</span>
<span class="nc" id="L297">                return this;</span>
<span class="fc" id="L298">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L299">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L300">            Node[] newChildren = children;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L302">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc" id="L304">                    int nextPosition = currentBranchStartIndex + branch.size();</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">                    if (from &lt; nextPosition) {</span>
<span class="fc" id="L306">                        int childFrom = Math.max(0, from - currentBranchStartIndex);</span>
<span class="fc" id="L307">                        int childTo = Math.min(to - currentBranchStartIndex, branch.size());</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">                        if (childFrom &lt; childTo) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">                            if (newChildren == children)</span>
<span class="fc" id="L310">                                newChildren = children.clone();</span>
<span class="fc" id="L311">                            newChildren[i] = branch.removeRange(childFrom, childTo, type, access, allowsNull);</span>
                        }
                    }
<span class="fc" id="L314">                    currentBranchStartIndex = nextPosition;</span>
                }
            }
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if ( newChildren == children )</span>
<span class="nc" id="L318">                return this; // this was not affected</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            else if ( _isAllNull(newChildren) )</span>
<span class="fc" id="L320">                return null;</span>
            else
<span class="fc" id="L322">                return new BranchNode(newChildren);</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node addAllAt(int index, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull) {
<span class="fc" id="L327">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L328">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L329">            Node[] newChildren = children;</span>
<span class="fc" id="L330">            int bestIndex = -1;</span>
<span class="fc" id="L331">            int bestIndexStart = -1;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L333">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc" id="L335">                    int nextPosition = currentBranchStartIndex + branch.size();</span>
<span class="fc bfc" id="L336" title="All 4 branches covered.">                    if ( currentBranchStartIndex &lt;= index &amp;&amp; index &lt;= nextPosition ) {</span>
<span class="fc" id="L337">                        bestIndex = i;</span>
<span class="fc" id="L338">                        bestIndexStart = currentBranchStartIndex;</span>
                    }
<span class="fc" id="L340">                    currentBranchStartIndex = nextPosition;</span>
                }
            }
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            if (newChildren == children)</span>
<span class="fc" id="L344">                newChildren = children.clone();</span>
<span class="fc" id="L345">            int childIndex = index - bestIndexStart;</span>
<span class="fc" id="L346">            Node branch = newChildren[bestIndex];</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            if ( branch == null )</span>
<span class="nc" id="L348">                newChildren[bestIndex] = _createRootFromList(type, allowsNull, tuple.toList());</span>
            else
<span class="fc" id="L350">                newChildren[bestIndex] = branch.addAllAt(childIndex, tuple, type, access, allowsNull);</span>

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">            if (newChildren[bestIndex] == branch)</span>
<span class="nc" id="L353">                throw new IllegalStateException(&quot;TupleNode was not modified&quot;);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L355">                throw new IllegalStateException(&quot;TupleNode is all null&quot;);</span>
            else
<span class="fc" id="L357">                return new BranchNode(newChildren);</span>
        }

        @Override
        public @Nullable &lt;T&gt; Node setAllAt(int index, int offset, Tuple&lt;T&gt; tuple, Class&lt;T&gt; type, ArrayItemAccess&lt;?, Object&gt; access, boolean allowsNull) {
<span class="fc" id="L362">            int currentBranchStartIndex = 0;</span>
<span class="fc" id="L363">            Node @Nullable[] children = _children;</span>
<span class="fc" id="L364">            Node[] newChildren = children;</span>
<span class="fc" id="L365">            int endIndex = index + tuple.size();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            for ( int i = 0; i &lt; children.length; i++ ) {</span>
<span class="fc" id="L367">                @Nullable Node branch = children[i];</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                if ( branch != null ) {</span>
<span class="fc" id="L369">                    int nextPosition = currentBranchStartIndex + branch.size();</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">                    if ( endIndex &lt;= currentBranchStartIndex )</span>
<span class="fc" id="L371">                        break;</span>
<span class="fc bfc" id="L372" title="All 4 branches covered.">                    if (currentBranchStartIndex &lt;= index &amp;&amp; index &lt; nextPosition) {</span>
<span class="fc" id="L373">                        int childIndex = index - currentBranchStartIndex;</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                        if (newChildren == children)</span>
<span class="fc" id="L375">                            newChildren = children.clone();</span>
<span class="fc" id="L376">                        newChildren[i] = branch.setAllAt(childIndex, offset, tuple, type, access, allowsNull);</span>
<span class="pc bpc" id="L377" title="1 of 4 branches missed.">                    } else if (currentBranchStartIndex &lt;= endIndex &amp;&amp; endIndex &lt; nextPosition) {</span>
<span class="fc" id="L378">                        int childIndex = 0;</span>
<span class="fc" id="L379">                        int additionalOffset = offset + (currentBranchStartIndex - index);</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                        if (newChildren == children)</span>
<span class="nc" id="L381">                            newChildren = children.clone();</span>
<span class="fc" id="L382">                        newChildren[i] = branch.setAllAt(childIndex, additionalOffset, tuple, type, access, allowsNull);</span>
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">                    } else if (index &lt;= currentBranchStartIndex &amp;&amp; nextPosition &lt;= endIndex ) {</span>
<span class="fc" id="L384">                        int childIndex = 0;</span>
<span class="fc" id="L385">                        int additionalOffset = offset + (currentBranchStartIndex - index);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">                        if (newChildren == children)</span>
<span class="nc" id="L387">                            newChildren = children.clone();</span>
<span class="fc" id="L388">                        newChildren[i] = branch.setAllAt(childIndex, additionalOffset, tuple, type, access, allowsNull);</span>
                    }
<span class="fc" id="L390">                    currentBranchStartIndex += branch.size();</span>
                }
            }
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">            if ( newChildren == children )</span>
<span class="nc" id="L394">                return this; // this was not affected</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">            else if ( _isAllNull(newChildren) )</span>
<span class="nc" id="L396">                return null;</span>
            else
<span class="fc" id="L398">                return new BranchNode(newChildren);</span>
        }

        @Override
        public &lt;T&gt; void forEach(ArrayItemAccess&lt;T, Object&gt; access, Consumer&lt;T&gt; consumer) {
<span class="nc bnc" id="L403" title="All 2 branches missed.">            for (Node branch : _children) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                if (branch != null)</span>
<span class="nc" id="L405">                    branch.forEach(access, consumer);</span>
            }
<span class="nc" id="L407">        }</span>
    }

    private final int _size;
    private final boolean _allowsNull;
    private final Class&lt;T&gt; _type;
    private final ArrayItemAccess&lt;T, Object&gt; _itemGetter;
    private final Node _root;
<span class="fc" id="L415">    private final AtomicReference&lt;@Nullable Integer&gt; _cachedHashCode = new AtomicReference&lt;&gt;(null);</span>

    /**
     * Creates a new {@link TupleTree} with the given list of items.
     * The items are copied into a new array, so the original items
     * can be modified without affecting this tuple tree.
     *
     * @param allowsNull Whether this tuple tree allows null values.
     * @param type The type of the items in this tuple tree.
     * @param items The items to be added to this tuple tree.
     * @param &lt;T&gt; The type of the items in this tuple tree.
     * @return A new {@link TupleTree} containing the given items.
     */
    @SuppressWarnings(&quot;NullAway&quot;)
    static &lt;T&gt; TupleTree&lt;T&gt; of(
        boolean allowsNull,
        Class&lt;T&gt; type,
        List&lt;T&gt; items
    ) {
<span class="fc" id="L434">        return new TupleTree(</span>
<span class="fc" id="L435">                items.size(),</span>
                allowsNull,
                type,
<span class="fc" id="L438">                _createInitialRootFromList(type, allowsNull, items)</span>
            );
    }

    /**
     * Creates a new {@link TupleTree} with the given array of items.
     * The items are copied into a new array, so the original items
     * can be modified without affecting this tuple tree.
     *
     * @param allowsNull Whether this tuple tree allows null values.
     * @param type The type of the items in this tuple tree.
     * @param items The items to be added to this tuple tree.
     * @param &lt;T&gt; The type of the items in this tuple tree.
     * @return A new {@link TupleTree} containing the given items.
     */
    @SafeVarargs static &lt;T&gt; TupleTree&lt;T&gt; of(
        boolean allowsNull,
        Class&lt;T&gt; type,
        @Nullable T... items
    ) {
<span class="fc" id="L458">        return ofAnyArray(allowsNull, type, items);</span>
    }

    static &lt;T&gt; TupleTree&lt;T&gt; ofAnyArray(
            boolean allowsNull,
            Class&lt;T&gt; type,
            @Nullable Object array
    ) {
<span class="fc" id="L466">        Node node = _createInitialRootFromArray(type, allowsNull, array);</span>
<span class="fc" id="L467">        return new TupleTree(node.size(), allowsNull, type, node);</span>
    }

    static &lt;T&gt; TupleTree&lt;T&gt; ofRaw(
            boolean allowsNull,
            Class&lt;T&gt; type,
            Object data
    ) {
<span class="fc" id="L475">        LeafNode leaf = new LeafNode(data);</span>
<span class="fc" id="L476">        return new TupleTree(</span>
<span class="fc" id="L477">                leaf.size(),</span>
                allowsNull,
                type,
                leaf
        );
    }

    @SuppressWarnings(&quot;NullAway&quot;)
    private TupleTree(
            int size,
            boolean allowsNull,
            Class&lt;T&gt; type,
            @Nullable Node root
<span class="fc" id="L490">    ) {</span>
<span class="fc" id="L491">        Objects.requireNonNull(type);</span>
<span class="fc" id="L492">        _size = size;</span>
<span class="fc" id="L493">        _allowsNull = allowsNull;</span>
<span class="fc" id="L494">        _type = type;</span>
<span class="fc" id="L495">        _itemGetter = ArrayItemAccess.of(type, _allowsNull);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        _root = root == null ? new LeafNode(_createArray(type, allowsNull, size)) : root;</span>
<span class="fc" id="L497">    }</span>

    private static Node _createInitialRootFromList(Class&lt;?&gt; type, boolean allowsNull, List&lt;?&gt; items) {
<span class="fc" id="L500">        return new LeafNode(_createArrayFromList(type, allowsNull, items));</span>
    }

    private static Node _createInitialRootFromArray(Class&lt;?&gt; type, boolean allowsNull, @Nullable Object arrayFromOutside) {
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if ( arrayFromOutside == null ) {</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">            if ( allowsNull )</span>
<span class="fc" id="L506">                return new LeafNode(_createArray(type, true, 1));</span>
            else
<span class="nc" id="L508">                throw new NullPointerException(&quot;Cannot create a TupleHamt with null items when allowsNull is false&quot;);</span>
        }
<span class="fc" id="L510">        return new LeafNode(_createArrayFromArray(type, allowsNull, arrayFromOutside));</span>
    }

    private static Node _createRootFromList(Class&lt;?&gt; type, boolean allowsNull, List&lt;?&gt; items) {
<span class="fc bfc" id="L514" title="All 4 branches covered.">        if ( items.isEmpty() || items.size() &lt; IDEAL_LEAF_NODE_SIZE)</span>
<span class="fc" id="L515">            return new LeafNode(_createArrayFromList(type, allowsNull, items));</span>
<span class="fc" id="L516">        Node[] branches = new Node[BRANCHING_FACTOR];</span>
<span class="fc" id="L517">        int stepSize = items.size() / branches.length;</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">        for (int i = 0; i &lt; branches.length; i++) {</span>
<span class="fc" id="L519">            int start = i * stepSize;</span>
<span class="fc" id="L520">            int end = (i + 1) * stepSize;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (i == branches.length - 1) {</span>
<span class="fc" id="L522">                end = items.size();</span>
            }
<span class="fc" id="L524">            List&lt;?&gt; subList = items.subList(start, end);</span>
<span class="fc" id="L525">            branches[i] = _createRootFromList(type, allowsNull, subList);</span>
        }
<span class="fc" id="L527">        return new BranchNode(branches);</span>
    }


    @Override
    public Class&lt;T&gt; type() {
<span class="fc" id="L533">        return _type;</span>
    }

    @Override
    public int size() {
<span class="fc" id="L538">        return _size;</span>
    }

    @Override
    @SuppressWarnings(&quot;NullAway&quot;)
    public T get(int index) {
<span class="pc bpc" id="L544" title="2 of 4 branches missed.">        if (index &lt; 0 || index &gt;= _size) {</span>
<span class="nc" id="L545">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
        }
<span class="fc" id="L547">        return _root.getAt(index, _itemGetter);</span>
    }

    @Override
    public boolean allowsNull() {
<span class="fc" id="L552">        return _allowsNull;</span>
    }

    @Override
    public TupleTree&lt;T&gt; slice(int from, int to) {
<span class="pc bpc" id="L557" title="3 of 6 branches missed.">        if (from &lt; 0 || to &gt; _size || from &gt; to) {</span>
<span class="nc" id="L558">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + from + &quot;, Size: &quot; + _size);</span>
        }
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if ( from &gt; to )</span>
<span class="nc" id="L561">            throw new IllegalArgumentException();</span>

<span class="fc" id="L563">        int newSize = (to - from);</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">        if ( newSize == this.size() )</span>
<span class="nc" id="L565">            return this;</span>

<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if ( newSize == 0 ) {</span>
<span class="nc" id="L568">            Node newRoot = _createRootFromList(_type, _allowsNull, Collections.emptyList());</span>
<span class="nc" id="L569">            return new TupleTree&lt;&gt;(0, _allowsNull, _type, newRoot);</span>
        }
<span class="fc" id="L571">        Node newRoot = _root.slice(from, to, _type, _allowsNull);</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L573">            return this;</span>
<span class="fc" id="L574">        return new TupleTree&lt;&gt;(newSize, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleTree&lt;T&gt; removeRange(int from, int to) {
<span class="pc bpc" id="L579" title="2 of 4 branches missed.">        if ( from &lt; 0 || to &gt; _size )</span>
<span class="nc" id="L580">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + from + &quot;, Size: &quot; + _size);</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">        if ( from &gt; to )</span>
<span class="nc" id="L582">            throw new IllegalArgumentException();</span>
<span class="fc" id="L583">        int numberOfItemsToRemove = to - from;</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        if ( numberOfItemsToRemove == 0 )</span>
<span class="nc" id="L585">            return this;</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if ( numberOfItemsToRemove == this.size() ) {</span>
<span class="nc" id="L587">            return new TupleTree&lt;&gt;(0, _allowsNull, _type, null);</span>
        }
<span class="fc" id="L589">        Node newRoot = _root.removeRange(from, to, _type, _itemGetter, _allowsNull);</span>
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L591">            return this;</span>
<span class="fc" id="L592">        return new TupleTree&lt;&gt;(_size - numberOfItemsToRemove, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public Tuple&lt;T&gt; removeIf( Predicate&lt;T&gt; predicate ) {
<span class="nc" id="L597">        List&lt;T&gt; itemsToKeep = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="nc" id="L599">            T item = get(i);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">            if ( !predicate.test(item) ) {</span>
<span class="nc" id="L601">                itemsToKeep.add(item);</span>
            }
        }
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if ( itemsToKeep.size() == this.size() )</span>
<span class="nc" id="L605">            return this;</span>
<span class="nc" id="L606">        T[] newItems = (T[]) Array.newInstance(type(), itemsToKeep.size());</span>
<span class="nc" id="L607">        itemsToKeep.toArray(newItems);</span>
<span class="nc" id="L608">        return TupleTree.of( allowsNull(), type(), newItems);</span>
    }

    @Override
    public Tuple&lt;T&gt; retainIf( Predicate&lt;T&gt; predicate ) {
<span class="nc" id="L613">        List&lt;T&gt; filteredItems = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        for ( int i = 0; i &lt; size(); i++ ) {</span>
<span class="nc" id="L615">            T item = get(i);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if ( predicate.test(item) ) {</span>
<span class="nc" id="L617">                filteredItems.add(item);</span>
            }
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if ( filteredItems.size() == this.size() )</span>
<span class="nc" id="L621">            return this;</span>
<span class="nc" id="L622">        return TupleTree.of(allowsNull(), type(), filteredItems);</span>
    }

    @Override
    public TupleTree&lt;T&gt; removeAll(Tuple&lt;T&gt; properties) {
<span class="fc bfc" id="L627" title="All 2 branches covered.">        if (properties.size() == 0) {</span>
<span class="fc" id="L628">            return this;</span>
        }
<span class="fc" id="L630">        List&lt;T&gt; newItems = new ArrayList&lt;&gt;(_size);</span>
<span class="fc" id="L631">        Set&lt;T&gt; toRemove = properties.toSet();</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L633">            T item = get(i);</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">            if (!toRemove.contains(item)) {</span>
<span class="fc" id="L635">                newItems.add(item);</span>
            }
        }
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if (newItems.size() == _size) {</span>
<span class="fc" id="L639">            return this;</span>
        }
<span class="fc" id="L641">        return new TupleTree&lt;&gt;(newItems.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, newItems));</span>
    }

    @Override
    public TupleTree&lt;T&gt; addAt(int index, T item) {
<span class="fc bfc" id="L646" title="All 4 branches covered.">        if ( !this.allowsNull() &amp;&amp; item == null )</span>
<span class="fc" id="L647">            throw new NullPointerException();</span>
<span class="pc bpc" id="L648" title="2 of 4 branches missed.">        if ( index &lt; 0 || index &gt; _size )</span>
<span class="nc" id="L649">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>

<span class="fc bfc" id="L651" title="All 2 branches covered.">        Tuple&lt;T&gt; singleton = _allowsNull ? Tuple.ofNullable(type(), item) : Tuple.of(item);</span>
<span class="fc" id="L652">        Node newRoot = _root.addAllAt(index, singleton, _type, _itemGetter, _allowsNull);</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L654">            return this;</span>
<span class="fc" id="L655">        return new TupleTree&lt;&gt;(_size+1, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleTree&lt;T&gt; setAt(int index, T item) {
<span class="fc bfc" id="L660" title="All 4 branches covered.">        if ( index &lt; 0 || index &gt;= _size )</span>
<span class="fc" id="L661">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
<span class="pc bpc" id="L662" title="1 of 4 branches missed.">        if ( !this.allowsNull() &amp;&amp; item == null )</span>
<span class="fc" id="L663">            throw new NullPointerException();</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">        return setAllAt(index, _allowsNull ? Tuple.ofNullable(type(), item) : Tuple.of(item));</span>
    }

    @Override
    public TupleTree&lt;T&gt; addAllAt(int index, Tuple&lt;T&gt; tuple) {
<span class="fc" id="L669">        Objects.requireNonNull(tuple);</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if ( tuple.isEmpty() )</span>
<span class="fc" id="L671">            return this; // nothing to do</span>
<span class="fc bfc" id="L672" title="All 4 branches covered.">        if ( !this.allowsNull() &amp;&amp; tuple.allowsNull() )</span>
<span class="fc" id="L673">            throw new NullPointerException();</span>
<span class="fc bfc" id="L674" title="All 4 branches covered.">        if ( index &lt; 0 || index &gt; _size )</span>
<span class="fc" id="L675">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
<span class="fc" id="L676">        Node newRoot = _root.addAllAt(index, tuple, _type, _itemGetter, _allowsNull);</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        if ( newRoot == _root )</span>
<span class="nc" id="L678">            return this;</span>
<span class="fc" id="L679">        return new TupleTree&lt;&gt;(_size+tuple.size(), _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleTree&lt;T&gt; setAllAt(int index, Tuple&lt;T&gt; tuple) {
<span class="fc" id="L684">        Objects.requireNonNull(tuple);</span>
<span class="pc bpc" id="L685" title="1 of 4 branches missed.">        if ( !this.allowsNull() &amp;&amp; tuple.allowsNull() )</span>
<span class="fc" id="L686">            throw new NullPointerException();</span>
<span class="fc bfc" id="L687" title="All 4 branches covered.">        if ( index &lt; 0 || index + tuple.size() &gt; size() )</span>
<span class="fc" id="L688">            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + _size);</span>
<span class="fc" id="L689">        Node newRoot = _root.setAllAt(index, 0, tuple, _type, _itemGetter, _allowsNull);</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">        if ( newRoot == _root )</span>
<span class="fc" id="L691">            return this;</span>
<span class="fc" id="L692">        return new TupleTree&lt;&gt;(_size, _allowsNull, _type, newRoot);</span>
    }

    @Override
    public Tuple&lt;T&gt; retainAll(Tuple&lt;T&gt; tuple) {
<span class="nc" id="L697">        Objects.requireNonNull(tuple);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if ( tuple.isEmpty() ) {</span>
<span class="nc" id="L699">            Node newRoot = _createRootFromList(_type, _allowsNull, Collections.emptyList());</span>
<span class="nc" id="L700">            return new TupleTree&lt;&gt;(0, _allowsNull, _type, newRoot);</span>
        }
<span class="nc" id="L702">        int[] indicesOfThingsToKeep = new int[this.size()];</span>
<span class="nc" id="L703">        int newSize = 0;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        int singleSequenceIndex = size() &gt; 0 ? -2 : -1;</span>
<span class="nc" id="L705">        int retainSequenceSize = 0;</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">        for ( int i = 0; i &lt; this.size(); i++ ) {</span>
<span class="nc" id="L707">            int index = tuple.firstIndexOf( get(i) );</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">            if ( index != -1 ) {</span>
<span class="nc" id="L709">                indicesOfThingsToKeep[newSize] = i;</span>
<span class="nc" id="L710">                newSize++;</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if ( singleSequenceIndex != -1 ) {</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                    if ( singleSequenceIndex == -2 )</span>
<span class="nc" id="L713">                        singleSequenceIndex = i;</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                    else if ( i &gt; singleSequenceIndex + retainSequenceSize )</span>
<span class="nc" id="L715">                        singleSequenceIndex = -1;</span>
                }
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if ( singleSequenceIndex &gt;= 0 )</span>
<span class="nc" id="L718">                    retainSequenceSize++;</span>
            } else {
<span class="nc" id="L720">                indicesOfThingsToKeep[newSize] = -1;</span>
            }
        }
<span class="nc" id="L723">        return _retainAll(singleSequenceIndex, newSize, indicesOfThingsToKeep);</span>
    }

    TupleTree&lt;T&gt; _retainAll(int singleSequenceIndex, int newSize, int[] indicesOfThingsToKeep) {
<span class="fc bfc" id="L727" title="All 2 branches covered.">        if ( newSize == this.size() )</span>
<span class="fc" id="L728">            return this;</span>
<span class="fc" id="L729">        List&lt;T&gt; newItems = new ArrayList&lt;&gt;(newSize);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">        for ( int i = 0; i &lt; newSize; i++ ) {</span>
<span class="fc" id="L731">            int index = indicesOfThingsToKeep[i];</span>
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">            if ( index != -1 )</span>
<span class="fc" id="L733">                newItems.add(get(index));</span>
        }
<span class="fc" id="L735">        Node newRoot = _createRootFromList(_type, _allowsNull, newItems);</span>
<span class="fc" id="L736">        return new TupleTree&lt;&gt;(newItems.size(), _allowsNull, _type, newRoot);</span>
    }

    @Override
    public TupleTree&lt;T&gt; clear() {
<span class="fc" id="L741">        return new TupleTree&lt;&gt;(0, _allowsNull, _type, null);</span>
    }

    @Override
    public Tuple&lt;T&gt; map( Function&lt;T,T&gt; mapper ) {
<span class="fc" id="L746">        Objects.requireNonNull(mapper);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L748">        T[] mappedItems = (T[]) Array.newInstance(type(), size());</span>
<span class="fc" id="L749">        int i = 0;</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc" id="L751">            mappedItems[i++] = mapper.apply( v );</span>
<span class="fc" id="L752">        }</span>
<span class="fc" id="L753">        return TupleTree.of( allowsNull(), type(), mappedItems);</span>
    }

    @Override
    public &lt;U extends @Nullable Object&gt; Tuple&lt;U&gt; mapTo(
        Class&lt;U&gt;      type,
        Function&lt;T,U&gt; mapper
    ) {
<span class="fc" id="L761">        Objects.requireNonNull(type);</span>
<span class="fc" id="L762">        Objects.requireNonNull(mapper);</span>
<span class="fc" id="L763">        U[] array = (U[]) Array.newInstance(type, size());</span>
<span class="fc" id="L764">        int i = 0;</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        for ( T v : this ) {</span>
<span class="fc" id="L766">            U m = mapper.apply( v );</span>
<span class="fc" id="L767">            array[i++] = m;</span>
<span class="fc" id="L768">        }</span>
<span class="fc" id="L769">        return TupleTree.of( allowsNull(), type, array );</span>
    }

    @Override
    public TupleTree&lt;T&gt; sort(Comparator&lt;T&gt; comparator) {
<span class="fc" id="L774">        List&lt;T&gt; sortedList = new ArrayList&lt;&gt;(_size);</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L776">            sortedList.add(get(i));</span>
        }
<span class="fc" id="L778">        sortedList.sort(comparator);</span>
<span class="fc" id="L779">        return new TupleTree&lt;&gt;(sortedList.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, sortedList));</span>
    }

    @Override
    public TupleTree&lt;T&gt; makeDistinct() {
<span class="fc" id="L784">        Set&lt;T&gt; distinctSet = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L786">            distinctSet.add(get(i));</span>
        }
<span class="fc" id="L788">        List&lt;T&gt; distinctList = new ArrayList&lt;&gt;(distinctSet);</span>
<span class="fc" id="L789">        return new TupleTree&lt;&gt;(distinctList.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, distinctList));</span>
    }

    @Override
    public TupleTree&lt;T&gt; reversed() {
<span class="fc" id="L794">        List&lt;T&gt; reversedList = new ArrayList&lt;&gt;(_size);</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">        for (int i = _size - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L796">            reversedList.add(get(i));</span>
        }
<span class="fc" id="L798">        return new TupleTree&lt;&gt;(reversedList.size(), _allowsNull, _type, _createRootFromList(_type, _allowsNull, reversedList));</span>
    }

    private static final class IteratorFrame {
        final Node node;
        final int end;
<span class="fc" id="L804">        int index = 0;</span>
        @Nullable IteratorFrame parent;

<span class="fc" id="L807">        IteratorFrame(Node n, @Nullable IteratorFrame parent) {</span>
<span class="fc" id="L808">            this.node = n;</span>
<span class="fc" id="L809">            this.parent = parent;</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">            if ( n instanceof LeafNode ) {</span>
<span class="fc" id="L811">                end = n.size();</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            } else if ( n instanceof BranchNode ) {</span>
<span class="fc" id="L813">                end = ((BranchNode) n)._children.length;</span>
            }
<span class="nc" id="L815">            else throw new IllegalArgumentException();</span>
<span class="fc" id="L816">        }</span>
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L821">        return new TupleIterator&lt;&gt;(this, ArrayItemAccess.of(_type, _allowsNull));</span>
    }

    @Override
    public Spliterator&lt;T&gt; spliterator() {
<span class="fc" id="L826">        return _createFastSpliteratorFor(_root, _type, _itemGetter, _allowsNull, 0, _size);</span>
    }

    private static &lt;T&gt; Spliterator&lt;T&gt; _createFastSpliteratorFor(
            TupleTree.Node node, Class&lt;T&gt; type, ArrayItemAccess&lt;T, Object&gt; itemGetter, boolean allowsNull, int start, int end
    ) {
<span class="fc bfc" id="L832" title="All 2 branches covered.">        if ( node instanceof LeafNode ) {</span>
<span class="fc" id="L833">            LeafNode leafNode = (LeafNode) node;</span>
<span class="fc bfc" id="L834" title="All 2 branches covered.">            if ( allowsNull )</span>
<span class="fc" id="L835">                return Spliterators.spliterator((T[])leafNode._data, 0, end, _spliteratorCharacteristics(allowsNull));</span>
<span class="pc bpc" id="L836" title="1 of 4 branches missed.">            else if ( type == Integer.class || type == int.class )</span>
<span class="fc" id="L837">                return (Spliterator&lt;T&gt;) Spliterators.spliterator((int[])leafNode._data, start, end, _spliteratorCharacteristics(allowsNull));</span>
<span class="pc bpc" id="L838" title="1 of 4 branches missed.">            else if ( type == Long.class || type == long.class )</span>
<span class="fc" id="L839">                return (Spliterator&lt;T&gt;) Spliterators.spliterator((long[])leafNode._data, start, end, _spliteratorCharacteristics(allowsNull));</span>
<span class="pc bpc" id="L840" title="1 of 4 branches missed.">            else if ( type == Double.class || type == double.class )</span>
<span class="fc" id="L841">                return (Spliterator&lt;T&gt;) Spliterators.spliterator((double[])leafNode._data, start, end, _spliteratorCharacteristics(allowsNull));</span>
        }
<span class="fc" id="L843">        return new TupleSpliterator&lt;&gt;(start, end, type, itemGetter, allowsNull, node);</span>
    }

    private static int _spliteratorCharacteristics(boolean allowsNull) {
<span class="fc" id="L847">        int characteristics = Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.IMMUTABLE;</span>
<span class="fc bfc" id="L848" title="All 2 branches covered.">        if (!allowsNull)</span>
<span class="fc" id="L849">            characteristics |= Spliterator.NONNULL;</span>
<span class="fc" id="L850">        return characteristics;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L855">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L856">        sb.append(&quot;Tuple&lt;&quot;);</span>
<span class="fc" id="L857">        sb.append(_type.getSimpleName());</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">        if (allowsNull())</span>
<span class="fc" id="L859">            sb.append(&quot;?&quot;);</span>
<span class="fc" id="L860">        sb.append(&quot;&gt;[&quot;);</span>
<span class="fc" id="L861">        final int howMany = Math.min(_size, 10);</span>
<span class="fc" id="L862">        int numberOfElementsLeft = _size - howMany;</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">        for (int i = 0; i &lt; howMany; i++) {</span>
<span class="fc" id="L864">            sb.append(get(i));</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (i &lt; _size - 1)</span>
<span class="fc" id="L866">                sb.append(&quot;, &quot;);</span>
        }
<span class="fc bfc" id="L868" title="All 2 branches covered.">        if (numberOfElementsLeft &gt; 0) {</span>
<span class="fc" id="L869">            sb.append(&quot;... &quot;).append(numberOfElementsLeft).append(&quot; items left&quot;);</span>
        }
<span class="fc" id="L871">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L872">        return sb.toString();</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L878">            return true;</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">        if (!(obj instanceof Tuple))</span>
<span class="nc" id="L880">            return false;</span>
<span class="fc" id="L881">        Tuple&lt;?&gt; other = (Tuple&lt;?&gt;) obj;</span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">        if (other.allowsNull() != this.allowsNull())</span>
<span class="fc" id="L883">            return false;</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">        if (other.size() != this.size())</span>
<span class="fc" id="L885">            return false;</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">        if (!other.type().equals(_type))</span>
<span class="nc" id="L887">            return false;</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">        if ( other instanceof TupleWithDiff ) {</span>
<span class="fc" id="L889">            other = ((TupleWithDiff)other).getData();</span>
        }
<span class="fc" id="L891">        TupleTree&lt;?&gt; otherHamt = null;</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">        if ( other instanceof TupleTree ) {</span>
<span class="fc" id="L893">            otherHamt = (TupleTree&lt;?&gt;) other;</span>
        }
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">        if ( otherHamt != null ) {</span>
<span class="fc" id="L896">            return _recursiveEquals(this._root, otherHamt._root, allowsNull(), type());</span>
        }
<span class="nc" id="L898">        return _exhaustiveEquals(this, (Tuple&lt;T&gt;)other);</span>
    }


    private static &lt;E&gt; boolean _exhaustiveEquals(Tuple&lt;E&gt; tuple1, Tuple&lt;E&gt; tuple2) {
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">        if ( tuple2.size() != tuple1.size() ) {</span>
<span class="nc" id="L904">            return false;</span>
        }
<span class="fc bfc" id="L906" title="All 2 branches covered.">        for (int i = 0; i &lt; tuple1.size(); i++) {</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">            if (!Objects.equals(tuple1.get(i), tuple2.get(i)))</span>
<span class="nc" id="L908">                return false;</span>
        }
<span class="fc" id="L910">        return true;</span>
    }

    private static &lt;E&gt; boolean _recursiveEquals(@Nullable Node node1, @Nullable Node node2, boolean allowsNull, Class&lt;E&gt; type) {
<span class="fc bfc" id="L914" title="All 2 branches covered.">        if ( node1 == node2 ) {</span>
<span class="fc" id="L915">            return true;</span>
        }
<span class="pc bpc" id="L917" title="2 of 4 branches missed.">        if ( node1 == null || node2 == null ) {</span>
<span class="nc" id="L918">            return false;</span>
        }
<span class="fc" id="L920">        boolean firstIsLeaf = node1 instanceof LeafNode;</span>
<span class="fc" id="L921">        boolean secondIsLeaf = node2 instanceof LeafNode;</span>
<span class="pc bpc" id="L922" title="1 of 4 branches missed.">        if ( firstIsLeaf &amp;&amp; secondIsLeaf ) {</span>
<span class="fc" id="L923">            LeafNode thisLeaf = (LeafNode) node1;</span>
<span class="fc" id="L924">            LeafNode otherLeaf = (LeafNode) node2;</span>
<span class="fc" id="L925">            return Val.equals(thisLeaf._data, otherLeaf._data);</span>
<span class="pc bpc" id="L926" title="1 of 4 branches missed.">        } else if ( !firstIsLeaf &amp;&amp; !secondIsLeaf ) {</span>
<span class="fc" id="L927">            BranchNode branchNode1 = (BranchNode) node1;</span>
<span class="fc" id="L928">            BranchNode branchNode2 = (BranchNode) node2;</span>
            // same type
<span class="fc" id="L930">            if (</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">                branchNode1.size() == branchNode2.size() &amp;&amp;</span>
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">                branchNode1._children != branchNode2._children // The only difference is somewhere deep down!</span>
            ) {
<span class="fc bfc" id="L934" title="All 2 branches covered.">                for ( int i = 0; i &lt; branchNode1._children.length; i++ ) {</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">                    if ( !_recursiveEquals(branchNode1._children[i], branchNode2._children[i], allowsNull, type) ) {</span>
<span class="fc" id="L936">                        return false;</span>
                    }
                }
<span class="fc" id="L939">                return true;</span>
            }
        }
<span class="fc" id="L942">        return _exhaustiveEquals(</span>
<span class="fc" id="L943">                new TupleTree&lt;&gt;(node1.size(), allowsNull, type, node1),</span>
<span class="fc" id="L944">                new TupleTree&lt;&gt;(node2.size(), allowsNull, type, node2)</span>
        );
    }


    @Override
    public int hashCode() {
<span class="fc" id="L951">        Integer cached = _cachedHashCode.get();</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        if ( cached != null )</span>
<span class="fc" id="L953">            return cached;</span>
<span class="fc" id="L954">        int hash = _type.hashCode() ^ _size;</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">        for (int i = 0; i &lt; _size; i++) {</span>
<span class="fc" id="L956">            T item = get(i);</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">            hash = 31 * hash + (item == null ? 0 : item.hashCode());</span>
        }
<span class="fc bfc" id="L959" title="All 2 branches covered.">        int result = hash ^ (_allowsNull ? 1 : 0);</span>
<span class="fc" id="L960">        _cachedHashCode.set(result);</span>
<span class="fc" id="L961">        return result;</span>
    }

    private static final class TupleIterator&lt;T&gt; implements Iterator&lt;T&gt;
    {
        private final ArrayItemAccess&lt;T, Object&gt; itemGetter;
<span class="fc" id="L967">        private @Nullable IteratorFrame currentFrame = null;</span>

<span class="fc" id="L969">        TupleIterator(TupleTree&lt;T&gt; tree, ArrayItemAccess&lt;T, Object&gt; itemGetter) {</span>
<span class="fc" id="L970">            this.itemGetter = itemGetter;</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">            if (tree._size &gt; 0)</span>
<span class="fc" id="L972">                currentFrame = new IteratorFrame(tree._root, null);</span>
<span class="fc" id="L973">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L977" title="All 2 branches covered.">            while ( currentFrame != null ) {</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">                if ( currentFrame.index &gt;= currentFrame.end ) {</span>
<span class="fc" id="L979">                    currentFrame = currentFrame.parent;</span>
                } else {
<span class="fc bfc" id="L981" title="All 2 branches covered.">                    if (currentFrame.node instanceof LeafNode) {</span>
<span class="fc" id="L982">                        return true;</span>
                    } else {
<span class="fc" id="L984">                        BranchNode bn = (BranchNode) currentFrame.node;</span>
<span class="fc" id="L985">                        Node[] children = bn._children;</span>
<span class="fc" id="L986">                        Node child = children[currentFrame.index++];</span>
<span class="fc bfc" id="L987" title="All 2 branches covered.">                        if (child != null)</span>
<span class="fc" id="L988">                            currentFrame = new IteratorFrame(child, currentFrame);</span>
<span class="fc" id="L989">                    }</span>
                }
            }
<span class="fc" id="L992">            return false;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T next() {
<span class="pc bpc" id="L998" title="2 of 4 branches missed.">            if ( !hasNext() || currentFrame == null )</span>
<span class="nc" id="L999">                throw new NoSuchElementException();</span>

<span class="pc bpc" id="L1001" title="1 of 2 branches missed.">            if ( currentFrame.node instanceof LeafNode ) {</span>
<span class="fc" id="L1002">                LeafNode leaf = (LeafNode) currentFrame.node;</span>
<span class="fc" id="L1003">                T item = itemGetter.get(currentFrame.index, leaf.data());</span>
<span class="fc" id="L1004">                currentFrame.index++;</span>
<span class="fc" id="L1005">                return item;</span>
            } else {
<span class="nc" id="L1007">                return next();</span>
            }
        }
    }

    private static final class TupleSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
        private final TupleTree.Node root;
        private final Class&lt;T&gt; type;
        private final ArrayItemAccess&lt;T, Object&gt; itemGetter;
        private final boolean allowsNull;
        private final int fence;
        private int index; // position in the current node

        TupleSpliterator(
            int start,
            int end,
            Class&lt;T&gt; type,
            ArrayItemAccess&lt;T, Object&gt; itemGetter,
            boolean allowsNull,
            TupleTree.Node root
<span class="fc" id="L1027">        ) {</span>
<span class="fc" id="L1028">            this.index = start;</span>
<span class="fc" id="L1029">            this.fence = end;</span>
<span class="fc" id="L1030">            this.type = type;</span>
<span class="fc" id="L1031">            this.itemGetter = itemGetter;</span>
<span class="fc" id="L1032">            this.allowsNull = allowsNull;</span>
<span class="fc" id="L1033">            this.root = root;</span>
<span class="fc" id="L1034">        }</span>

        @Override
        public @Nullable Spliterator&lt;T&gt; trySplit() {
<span class="fc" id="L1038">            int lo = index;</span>
<span class="fc" id="L1039">            int mid = (lo + fence) &gt;&gt;&gt; 1;</span>
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">            if (mid &lt;= lo)</span>
<span class="nc" id="L1041">                return null;</span>
            // left half will handle [lo, mid), this spliterator becomes [mid, fence)
<span class="fc" id="L1043">            Spliterator&lt;T&gt; prefix = _createFastSpliteratorFor(root, type, itemGetter, allowsNull, lo, mid);</span>
<span class="fc" id="L1044">            this.index = mid;</span>
<span class="fc" id="L1045">            return prefix;</span>
        }

        @Override
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L1050" title="All 2 branches covered.">            if (index &lt; fence) {</span>
<span class="fc" id="L1051">                T item = root.getAt(index, itemGetter);</span>
<span class="fc" id="L1052">                index++;</span>
<span class="fc" id="L1053">                action.accept(item);</span>
<span class="fc" id="L1054">                return true;</span>
            }
<span class="fc" id="L1056">            return false;</span>
        }

        @Override
        public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L1061" title="All 2 branches covered.">            while (index &lt; fence) {</span>
<span class="fc" id="L1062">                T item = root.getAt(index, itemGetter);</span>
<span class="fc" id="L1063">                index++;</span>
<span class="fc" id="L1064">                action.accept(item);</span>
<span class="fc" id="L1065">            }</span>
<span class="fc" id="L1066">        }</span>

        @Override
        public long estimateSize() {
<span class="fc" id="L1070">            return (long) fence - index;</span>
        }

        @Override
        public int characteristics() {
<span class="fc" id="L1075">            return _spliteratorCharacteristics(allowsNull);</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public Comparator&lt;? super T&gt; getComparator() {
            // we don't have a comparator; streams will only call this if SORTED characteristic is set
<span class="nc" id="L1082">            throw new IllegalStateException(TupleTree.class.getName()+&quot; spliterator is not SORTED&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>