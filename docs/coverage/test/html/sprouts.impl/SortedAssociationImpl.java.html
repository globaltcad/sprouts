<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SortedAssociationImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">SortedAssociationImpl.java</span></div><h1>SortedAssociationImpl.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.*;

import java.util.*;

import static sprouts.impl.ArrayUtil.*;

final class SortedAssociationImpl&lt;K, V&gt; implements Association&lt;K, V&gt; {

    private static final boolean ALLOWS_NULL = false;
<span class="fc" id="L13">    private static final Node NULL_NODE = new Node(</span>
<span class="fc" id="L14">            _createArray(Object.class, ALLOWS_NULL, 0),</span>
<span class="fc" id="L15">            _createArray(Object.class, ALLOWS_NULL, 0)</span>
        );

<span class="fc" id="L18">    private static int BASE_ENTRIES_PER_NODE(int depth) { return Math.max( 1, depth * depth / 2 ); }</span>


    private final Class&lt;K&gt; _keyType;
    private final Class&lt;V&gt; _valueType;
    private final ArrayItemAccess&lt;K, Object&gt; _keyGetter;
    private final ArrayItemAccess&lt;V, Object&gt; _valueGetter;
    private final Comparator&lt;K&gt; _keyComparator;
    private final Node _root;


    static class Node {
        private final int _size;
        private final Object _keysArray;
        private final Object _valuesArray;
        private final @Nullable Node _left;
        private final @Nullable Node _right;

        Node(Object keysArray, Object valuesArray) {
<span class="fc" id="L37">            this(_length(keysArray), keysArray, valuesArray, null, null);</span>
<span class="fc" id="L38">        }</span>

<span class="fc" id="L40">        Node(Object keysArray, Object valuesArray, @Nullable Node left, @Nullable Node right) {</span>
<span class="pc bpc" id="L41" title="1 of 4 branches missed.">            _size = _length(keysArray) + (left == null ? 0 : left.size()) + (right == null ? 0 : right.size());</span>
<span class="fc" id="L42">            _keysArray = keysArray;</span>
<span class="fc" id="L43">            _valuesArray = valuesArray;</span>
<span class="fc" id="L44">            _left = left;</span>
<span class="fc" id="L45">            _right = right;</span>
<span class="fc" id="L46">        }</span>

<span class="fc" id="L48">        Node(int size, Object keysArray, Object valuesArray, @Nullable Node left, @Nullable Node right) {</span>
<span class="fc" id="L49">            _size = size;</span>
<span class="fc" id="L50">            _keysArray = keysArray;</span>
<span class="fc" id="L51">            _valuesArray = valuesArray;</span>
<span class="fc" id="L52">            _left = left;</span>
<span class="fc" id="L53">            _right = right;</span>
<span class="fc" id="L54">        }</span>

        public Object keysArray() {
<span class="fc" id="L57">            return _keysArray;</span>
        }
        public Object valuesArray() {
<span class="fc" id="L60">            return _valuesArray;</span>
        }
        public @Nullable Node left() {
<span class="fc" id="L63">            return _left;</span>
        }
        public @Nullable Node right() {
<span class="fc" id="L66">            return _right;</span>
        }
        public int size() {
<span class="fc" id="L69">            return _size;</span>
        }
        public Node withNewArrays(Object newKeysArray, Object newValuesArray) {
<span class="fc" id="L72">            int newSize = _computeSize(newKeysArray, _left, _right);</span>
<span class="fc" id="L73">            return new Node(newSize, newKeysArray, newValuesArray, _left, _right);</span>
        }
        public Node withNewLeft(@Nullable Node left) {
<span class="fc" id="L76">            int newSize = _computeSize(_keysArray, left, _right);</span>
<span class="fc" id="L77">            return new Node(newSize, _keysArray, _valuesArray, left, _right);</span>
        }
        public Node withNewRight(@Nullable Node right) {
<span class="fc" id="L80">            int newSize = _computeSize(_keysArray, _left, right);</span>
<span class="fc" id="L81">            return new Node(newSize, _keysArray, _valuesArray, _left, right);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L86">            int keysHash = Val.hashCode(_keysArray);</span>
<span class="nc" id="L87">            int valuesHash = Val.hashCode(_valuesArray);</span>
<span class="nc" id="L88">            return Objects.hash(_size, keysHash, valuesHash, _left, _right);</span>
        }
        @Override
        public boolean equals(@Nullable Object obj) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L93">                return true;</span>
            }
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (!(obj instanceof Node)) {</span>
<span class="nc" id="L96">                return false;</span>
            }
<span class="nc" id="L98">            Node other = (Node) obj;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">            return _size == other._size &amp;&amp;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                    Val.equals(_keysArray, other._keysArray) &amp;&amp;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">                    Val.equals(_valuesArray, other._valuesArray) &amp;&amp;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                    Objects.equals(_left, other._left) &amp;&amp;</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                    Objects.equals(_right, other._right);</span>
        }

        private static int _computeSize(
            Object keysArray,
            @Nullable Node left,
            @Nullable Node right
        ) {
<span class="fc" id="L111">            int size = _length(keysArray);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (left != null) {</span>
<span class="fc" id="L113">                size += left.size();</span>
            }
<span class="fc bfc" id="L115" title="All 2 branches covered.">            if (right != null) {</span>
<span class="fc" id="L116">                size += right.size();</span>
            }
<span class="fc" id="L118">            return size;</span>
        }
    }

    SortedAssociationImpl(
        final Class&lt;K&gt; keyType,
        final Class&lt;V&gt; valueType,
        final Comparator&lt;K&gt; keyComparator
    ) {
<span class="fc" id="L127">        this(</span>
            keyType,
            valueType,
            keyComparator,
            NULL_NODE
        );
<span class="fc" id="L133">    }</span>

    private SortedAssociationImpl(
        final Class&lt;K&gt; keyType,
        final Class&lt;V&gt; valueType,
        final Comparator&lt;K&gt; keyComparator,
        final Node root
<span class="fc" id="L140">    ) {</span>
<span class="fc" id="L141">        _keyType = keyType;</span>
<span class="fc" id="L142">        _valueType = valueType;</span>
<span class="fc" id="L143">        _keyGetter = ArrayItemAccess.of(keyType, false);</span>
<span class="fc" id="L144">        _valueGetter = ArrayItemAccess.of(valueType, false);</span>
<span class="fc" id="L145">        _keyComparator = keyComparator;</span>
<span class="fc" id="L146">        _root = root;</span>
<span class="fc" id="L147">    }</span>

    private SortedAssociationImpl&lt;K,V&gt; withNewRoot(Node newRoot) {
<span class="fc" id="L150">        return new SortedAssociationImpl&lt;&gt;(</span>
                _keyType,
                _valueType,
                _keyComparator,
                newRoot
        );
    }

    @Override
    public int size() {
<span class="fc" id="L160">        return _root.size();</span>
    }

    @Override
    public boolean isLinked() {
<span class="fc" id="L165">        return false;</span>
    }

    @Override
    public boolean isSorted() {
<span class="fc" id="L170">        return true;</span>
    }

    @Override
    public Class&lt;K&gt; keyType() {
<span class="fc" id="L175">        return _keyType;</span>
    }

    @Override
    public Class&lt;V&gt; valueType() {
<span class="fc" id="L180">        return _valueType;</span>
    }

    @Override
    public ValueSet&lt;K&gt; keySet() {
<span class="fc" id="L185">        return ValueSet.ofSorted(this.keyType(), _keyComparator).addAll(this.entrySet().stream().map(Pair::first));</span>
    }

    @Override
    public Tuple&lt;V&gt; values() {
<span class="fc" id="L190">        List&lt;V&gt; values = new ArrayList&lt;&gt;(_root.size());</span>
<span class="fc" id="L191">        _populateValues(_root, _valueGetter, values);</span>
<span class="fc" id="L192">        return Tuple.of(valueType(), values);</span>
    }

    private static &lt;V&gt; void _populateValues(Node node, ArrayItemAccess&lt;V, Object&gt; itemGetter, List&lt;V&gt; values) {
<span class="fc" id="L196">        _each(node.valuesArray(), itemGetter, values::add);</span>
<span class="fc" id="L197">        Node left = node.left();</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (left != null) {</span>
<span class="fc" id="L199">            _populateValues(left, itemGetter, values);</span>
        }
<span class="fc" id="L201">        Node right = node.right();</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (right != null) {</span>
<span class="fc" id="L203">            _populateValues(right, itemGetter, values);</span>
        }
<span class="fc" id="L205">    }</span>

    private static &lt;K,V&gt; @Nullable V _findValueOfKey(
            final Node node,
            final ArrayItemAccess&lt;K, Object&gt; keyGetter,
            final ArrayItemAccess&lt;V, Object&gt; valueGetter,
            final Comparator&lt;K&gt; keyComparator,
            final K key
    ) {
<span class="fc" id="L214">        int numberOfKeys = _length(node.keysArray());</span>
<span class="fc" id="L215">        int index = _binarySearch(node.keysArray(), keyGetter, keyComparator, key);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if ( index &lt; 0 ) {</span>
<span class="fc" id="L217">            Node left = node.left();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if ( left != null ) {</span>
<span class="fc" id="L219">                V value = _findValueOfKey(left, keyGetter, valueGetter, keyComparator, key);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if ( value != null ) {</span>
<span class="fc" id="L221">                    return value;</span>
                }
            }
        }
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if ( index &gt;= numberOfKeys ) {</span>
<span class="fc" id="L226">            Node right = node.right();</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">            if ( right != null ) {</span>
<span class="fc" id="L228">                V value = _findValueOfKey(right, keyGetter, valueGetter, keyComparator, key);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                if ( value != null ) {</span>
<span class="fc" id="L230">                    return value;</span>
                }
            }
        }
<span class="fc bfc" id="L234" title="All 4 branches covered.">        if ( index &gt;= 0 &amp;&amp; index &lt; numberOfKeys ) {</span>
<span class="fc" id="L235">            boolean keyAlreadyExists = Objects.equals(key, keyGetter.get(index, node.keysArray()));</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if ( !keyAlreadyExists ) {</span>
<span class="pc bpc" id="L237" title="3 of 4 branches missed.">                if ( index == 0 &amp;&amp; node.left() != null ) {</span>
<span class="nc" id="L238">                    return _findValueOfKey(node.left(), keyGetter, valueGetter, keyComparator, key);</span>
<span class="pc bpc" id="L239" title="1 of 4 branches missed.">                } else if ( index == numberOfKeys - 1 &amp;&amp; node.right() != null ) {</span>
<span class="fc" id="L240">                    return _findValueOfKey(node.right(), keyGetter, valueGetter, keyComparator, key);</span>
                }
<span class="fc" id="L242">                return null;</span>
            }
<span class="fc" id="L244">            return valueGetter.get(index, node.valuesArray());</span>
        }
<span class="fc" id="L246">        return null;</span>
    }

    private static &lt;K,V&gt; Node _updateValueOfKey(
        final Node node,
        final Class&lt;K&gt; keyType,
        final Class&lt;V&gt; valueType,
        final ArrayItemAccess&lt;K, Object&gt; keyGetter,
        final ArrayItemAccess&lt;V, Object&gt; valueGetter,
        final Comparator&lt;K&gt; keyComparator,
        final K key,
        final V value,
        final boolean putIfAbsent,
        final int depth
    ) {
<span class="fc" id="L261">        int numberOfKeys = _length(node.keysArray());</span>
<span class="fc" id="L262">        int index = _binarySearch(node.keysArray(), keyGetter, keyComparator, key);</span>
<span class="fc bfc" id="L263" title="All 4 branches covered.">        boolean foundInCurrentNode = index &gt;= 0 &amp;&amp; index &lt; numberOfKeys;</span>
<span class="fc bfc" id="L264" title="All 4 branches covered.">        boolean leftAndRightAreNull = node.left() == null &amp;&amp; node.right() == null;</span>
<span class="fc bfc" id="L265" title="All 6 branches covered.">        if ( leftAndRightAreNull &amp;&amp; !foundInCurrentNode &amp;&amp; numberOfKeys &lt; BASE_ENTRIES_PER_NODE(depth) ) {</span>
            // We add to the left
<span class="fc" id="L267">            Object newKeysArray = _createArray(keyType, ALLOWS_NULL, numberOfKeys+1);</span>
<span class="fc" id="L268">            Object newValuesArray = _createArray(valueType, ALLOWS_NULL, numberOfKeys+1);</span>
            // arraycopy
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if ( index &lt; 0 ) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                if ( numberOfKeys &gt; 0 ) {</span>
<span class="fc" id="L272">                    System.arraycopy(node.keysArray(), 0, newKeysArray, 1, numberOfKeys);</span>
<span class="fc" id="L273">                    System.arraycopy(node.valuesArray(), 0, newValuesArray, 1, numberOfKeys);</span>
                }
<span class="fc" id="L275">                _setAt(0, key, newKeysArray);</span>
<span class="fc" id="L276">                _setAt(0, value, newValuesArray);</span>
            } else {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                if ( numberOfKeys &gt; 0 ) {</span>
<span class="fc" id="L279">                    System.arraycopy(node.keysArray(), 0, newKeysArray, 0, numberOfKeys);</span>
<span class="fc" id="L280">                    System.arraycopy(node.valuesArray(), 0, newValuesArray, 0, numberOfKeys);</span>
                }
<span class="fc" id="L282">                _setAt(numberOfKeys, key, newKeysArray);</span>
<span class="fc" id="L283">                _setAt(numberOfKeys, value, newValuesArray);</span>
            }
<span class="fc" id="L285">            return node.withNewArrays(newKeysArray, newValuesArray);</span>
        }
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if ( index &lt; 0 ) {</span>
<span class="fc" id="L288">            Node left = node.left();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if ( left != null ) {</span>
<span class="fc" id="L290">                Node newLeft = _balance(_updateValueOfKey(left, keyType, valueType, keyGetter, valueGetter, keyComparator, key, value, putIfAbsent, depth+1));</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                if ( Util.refEquals(newLeft, left) ) {</span>
<span class="fc" id="L292">                    return node; // No change</span>
                }
<span class="fc" id="L294">                return node.withNewLeft(newLeft);</span>
            } else { // Left is null, we create a new node
<span class="fc" id="L296">                Object newKeysArray = _createArray(keyType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L297">                Object newValuesArray = _createArray(valueType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L298">                _setAt(0, key, newKeysArray);</span>
<span class="fc" id="L299">                _setAt(0, value, newValuesArray);</span>
<span class="fc" id="L300">                return node.withNewLeft(new Node(newKeysArray, newValuesArray));</span>
            }
        }
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if ( index &gt;= numberOfKeys ) {</span>
<span class="fc" id="L304">            Node right = node.right();</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">            if ( right != null ) {</span>
<span class="fc" id="L306">                Node newRight = _balance(_updateValueOfKey(right, keyType, valueType, keyGetter, valueGetter, keyComparator, key, value, putIfAbsent, depth+1));</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                if ( Util.refEquals(newRight, right) ) {</span>
                    // No change in the right node, we can return the current node
<span class="fc" id="L309">                    return node;</span>
                }
<span class="fc" id="L311">                return node.withNewRight(newRight);</span>
            } else { // Right is null, we create a new node
<span class="fc" id="L313">                Object newKeysArray = _createArray(keyType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L314">                Object newValuesArray = _createArray(valueType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L315">                _setAt(0, key, newKeysArray);</span>
<span class="fc" id="L316">                _setAt(0, value, newValuesArray);</span>
<span class="fc" id="L317">                return node.withNewRight(new Node(newKeysArray, newValuesArray));</span>
            }
        }

<span class="fc" id="L321">        boolean keyAlreadyExists = Objects.equals(key, keyGetter.get(index, node.keysArray()));</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if ( !keyAlreadyExists ) {</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            if ( numberOfKeys &lt; BASE_ENTRIES_PER_NODE(depth) ) {</span>
                // We need to insert the key in the right place
<span class="fc" id="L325">                Object newKeysArray = _createArray(keyType, ALLOWS_NULL, numberOfKeys + 1);</span>
<span class="fc" id="L326">                Object newValuesArray = _createArray(valueType, ALLOWS_NULL, numberOfKeys + 1);</span>
                // arraycopy up to index, item, and then trailing item copy
                // First keys:
<span class="fc" id="L329">                System.arraycopy(node.keysArray(), 0, newKeysArray, 0, index);</span>
<span class="fc" id="L330">                _setAt(index, key, newKeysArray);</span>
<span class="fc" id="L331">                System.arraycopy(node.keysArray(), index, newKeysArray, index + 1, numberOfKeys - index);</span>
                // Then values:
<span class="fc" id="L333">                System.arraycopy(node.valuesArray(), 0, newValuesArray, 0, index);</span>
<span class="fc" id="L334">                _setAt(index, value, newValuesArray);</span>
<span class="fc" id="L335">                System.arraycopy(node.valuesArray(), index, newValuesArray, index + 1, numberOfKeys - index);</span>
<span class="fc" id="L336">                return node.withNewArrays(newKeysArray, newValuesArray);</span>
            } else {
                /*
                    Ok, so this is an interesting case. We have a full node, and we need to INSERT a new key
                    somewhere in the middle of the node. We do this by popping an excess entry from
                    one of the sides of the local arrays and then let this popped-off entry trickle down
                    to the left or right side of the tree.
                */
<span class="fc" id="L344">                Object newKeysArray = _createArray(keyType, ALLOWS_NULL, numberOfKeys);</span>
<span class="fc" id="L345">                Object newValuesArray = _createArray(valueType, ALLOWS_NULL, numberOfKeys);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                int numberOfEntriesLeft = node.left() == null ? 0 : _length(node.left().keysArray());</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                int numberOfEntriesRight = node.right() == null ? 0 : _length(node.right().keysArray());</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if ( numberOfEntriesLeft &lt; numberOfEntriesRight ) {</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                    if ( index == 0 ) {</span>
                        // we just update the left node
                        Node newLeft;
<span class="nc bnc" id="L352" title="All 2 branches missed.">                        if ( node.left() != null ) {</span>
                            // Re-add the popped key and value to the left node
<span class="nc" id="L354">                            newLeft = _balance(_updateValueOfKey(node.left(), keyType, valueType, keyGetter, valueGetter, keyComparator, key, value, putIfAbsent, depth+1));</span>
                        } else {
<span class="nc" id="L356">                            newLeft = _createSingleEntryNode(keyType, valueType, key, value);</span>
                        }
<span class="nc" id="L358">                        return node.withNewLeft(newLeft);</span>
                    }
<span class="fc" id="L360">                    K poppedOffKey = _getNonNullAt(0, node.keysArray(), keyType);</span>
<span class="fc" id="L361">                    V poppedOffValue = _getNonNullAt(0, node.valuesArray(), valueType);</span>
                    Node newLeft;
<span class="fc bfc" id="L363" title="All 2 branches covered.">                    if ( node.left() != null ) {</span>
                        // Re-add the popped key and value to the left node
<span class="fc" id="L365">                        newLeft = _balance(_updateValueOfKey(node.left(), keyType, valueType, keyGetter, valueGetter, keyComparator, poppedOffKey, poppedOffValue, putIfAbsent, depth+1));</span>
                    } else {
<span class="fc" id="L367">                        newLeft = _createSingleEntryNode(keyType, valueType, poppedOffKey, poppedOffValue);</span>
                    }
                    // We pop from the left
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">                    if ( numberOfKeys == 1 ) {</span>
                        // We add the actual key and value to the current node as well as the new left node
<span class="nc" id="L372">                        _setAt(0, key, newKeysArray);</span>
<span class="nc" id="L373">                        _setAt(0, value, newValuesArray);</span>
                    } else {
                        // First, insert the key and value at the index (adjust for the popped key)
<span class="fc" id="L376">                        _setAt(index-1, key, newKeysArray);</span>
<span class="fc" id="L377">                        _setAt(index-1, value, newValuesArray);</span>
                        // Then, copy up to the index
<span class="fc" id="L379">                        System.arraycopy(node.keysArray(), 1, newKeysArray, 0, index-1);</span>
<span class="fc" id="L380">                        System.arraycopy(node.valuesArray(), 1, newValuesArray, 0, index-1);</span>
                        // Finally, copy the rest of the keys and values
<span class="fc" id="L382">                        System.arraycopy(node.keysArray(), index, newKeysArray, index, numberOfKeys - index);</span>
<span class="fc" id="L383">                        System.arraycopy(node.valuesArray(), index, newValuesArray, index, numberOfKeys - index);</span>
                    }
<span class="fc" id="L385">                    return new Node(newKeysArray, newValuesArray, newLeft, node.right());</span>
                } else {
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                    if ( index == numberOfKeys ) {</span>
                        // we just update the right node
                        Node newRight;
<span class="nc bnc" id="L390" title="All 2 branches missed.">                        if ( node.right() != null ) {</span>
                            // Re-add the popped key and value to the right node
<span class="nc" id="L392">                            newRight = _balance(_updateValueOfKey(node.right(), keyType, valueType, keyGetter, valueGetter, keyComparator, key, value, putIfAbsent, depth+1));</span>
                        } else {
<span class="nc" id="L394">                            newRight = _createSingleEntryNode(keyType, valueType, key, value);</span>
                        }
<span class="nc" id="L396">                        return node.withNewRight(newRight);</span>
                    }
<span class="fc" id="L398">                    K poppedOffKey = _getNonNullAt(numberOfKeys-1, node.keysArray(), keyType);</span>
<span class="fc" id="L399">                    V poppedOffValue = _getNonNullAt(numberOfKeys-1, node.valuesArray(), valueType);</span>
                    Node newRight;
<span class="fc bfc" id="L401" title="All 2 branches covered.">                    if ( node.right() != null ) {</span>
                        // Re-add the popped key and value to the right node
<span class="fc" id="L403">                        newRight = _balance(_updateValueOfKey(node.right(), keyType, valueType, keyGetter, valueGetter, keyComparator, poppedOffKey, poppedOffValue, putIfAbsent, depth+1));</span>
                    } else {
<span class="fc" id="L405">                        newRight = _createSingleEntryNode(keyType, valueType, poppedOffKey, poppedOffValue);</span>
                    }
                    // We pop from the right
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">                    if ( numberOfKeys == 1 ) {</span>
                        // We add the actual key and value to the current node as well as the new right node
<span class="nc" id="L410">                        _setAt(0, key, newKeysArray);</span>
<span class="nc" id="L411">                        _setAt(0, value, newValuesArray);</span>
                    } else {
                        // First, insert the key and value at the index (adjust for the popped key)
<span class="fc" id="L414">                        _setAt(index, key, newKeysArray);</span>
<span class="fc" id="L415">                        _setAt(index, value, newValuesArray);</span>
                        // Then, copy up to the index
<span class="fc" id="L417">                        System.arraycopy(node.keysArray(), 0, newKeysArray, 0, index);</span>
<span class="fc" id="L418">                        System.arraycopy(node.valuesArray(), 0, newValuesArray, 0, index);</span>
                        // Finally, copy the rest of the keys and values
<span class="fc" id="L420">                        System.arraycopy(node.keysArray(), index, newKeysArray, index+1, numberOfKeys - index - 1);</span>
<span class="fc" id="L421">                        System.arraycopy(node.valuesArray(), index, newValuesArray, index+1, numberOfKeys - index - 1);</span>
                    }
<span class="fc" id="L423">                    return new Node(newKeysArray, newValuesArray, node.left(), newRight);</span>
                }
            }
        }

        // We found the key, we need to update the value at index, only if &quot;putIfAbsent&quot; is false
<span class="fc bfc" id="L429" title="All 2 branches covered.">        if ( putIfAbsent ) {</span>
            // We don't want to update the value
<span class="fc" id="L431">            return node;</span>
        }
        // First, we check if the value is already there
<span class="fc" id="L434">        V existingValue = _getAt(index, node.valuesArray(), valueType);</span>
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if ( Objects.equals( existingValue, value ) ) {</span>
            // Nothing to do
<span class="fc" id="L437">            return node;</span>
        }
<span class="fc" id="L439">        Object newValuesArray = _clone(node.valuesArray(), valueType, ALLOWS_NULL);</span>
<span class="fc" id="L440">        _setAt(index, value, newValuesArray);</span>
<span class="fc" id="L441">        return node.withNewArrays(node.keysArray(), newValuesArray);</span>
    }

    private static @Nullable Node _balanceNullable(@Nullable Node node){
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (node == null)</span>
<span class="fc" id="L446">            return null;</span>
<span class="fc" id="L447">        return _balance(node);</span>
    }

    private static Node _balance(Node node){
<span class="fc" id="L451">        final Node right = node.right();</span>
<span class="fc" id="L452">        final Node left = node.left();</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">        final int leftSize = left == null ? 0 : left.size();</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        final int rightSize = right == null ? 0 : right.size();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">        if ( leftSize == rightSize ) {</span>
<span class="fc" id="L456">            return node;</span>
        }
<span class="fc" id="L458">        final int currentNodeArraySize = _length(node.keysArray());</span>
<span class="pc bpc" id="L459" title="1 of 4 branches missed.">        if ( leftSize &lt; rightSize &amp;&amp; right != null ) {</span>
<span class="fc" id="L460">            final int imbalance = rightSize - leftSize;</span>
<span class="fc" id="L461">            final int rightArraySize = _length(right.keysArray());</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            final int rightLeftSize = right.left() == null ? 0 : right.left().size();</span>
<span class="fc" id="L463">            final int newRightSize = rightSize - rightLeftSize - rightArraySize;</span>
<span class="fc" id="L464">            final int newLeftSize = leftSize + rightLeftSize + currentNodeArraySize;</span>
<span class="fc" id="L465">            final int newImbalance = Math.abs(newRightSize - newLeftSize);</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if ( newImbalance &lt; imbalance ) { // We only re-balance if it is worth it!</span>
<span class="fc" id="L467">                Node newLeft = new Node(newLeftSize, node.keysArray(), node.valuesArray(), left, right.left());</span>
<span class="fc" id="L468">                return new Node(</span>
<span class="fc" id="L469">                        node.size(), right.keysArray(), right.valuesArray(), newLeft, right.right()</span>
                    );
            }
        }
<span class="pc bpc" id="L473" title="1 of 4 branches missed.">        if ( rightSize &lt; leftSize &amp;&amp; left != null ) {</span>
<span class="fc" id="L474">            final int imbalance = leftSize - rightSize;</span>
<span class="fc" id="L475">            final int leftArraySize = _length(left.keysArray());</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">            final int leftRightSize = left.right() == null ? 0 : left.right().size();</span>
<span class="fc" id="L477">            final int newLeftSize = leftSize - leftRightSize - leftArraySize;</span>
<span class="fc" id="L478">            final int newRightSize = rightSize + leftRightSize + currentNodeArraySize;</span>
<span class="fc" id="L479">            final int newImbalance = Math.abs(newLeftSize - newRightSize);</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">            if ( newImbalance &lt; imbalance ) { // We only re-balance if it is worth it!</span>
<span class="fc" id="L481">                Node newRight = new Node(newRightSize, node.keysArray(), node.valuesArray(), left.right(), right);</span>
<span class="fc" id="L482">                return new Node(</span>
<span class="fc" id="L483">                        node.size(), left.keysArray(), left.valuesArray(), left.left(), newRight</span>
                    );
            }
        }
<span class="fc" id="L487">        return node;</span>
    }

    private static Node _createSingleEntryNode(
        Class&lt;?&gt; keyType, Class&lt;?&gt; valueType, Object key, Object value
    ) {
<span class="fc" id="L493">        Object newKeysArray = _createArray(keyType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L494">        Object newValuesArray = _createArray(valueType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L495">        _setAt(0, key, newKeysArray);</span>
<span class="fc" id="L496">        _setAt(0, value, newValuesArray);</span>
<span class="fc" id="L497">        return new Node(newKeysArray, newValuesArray);</span>
    }

    @Override
    public boolean containsKey(K key) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L503">            throw new NullPointerException(&quot;Null key&quot;);</span>
        }
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if ( !_keyType.isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L506">            throw new IllegalArgumentException(</span>
<span class="fc" id="L507">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _keyType + &quot;'.&quot;
                );
        }
<span class="fc bfc" id="L511" title="All 2 branches covered.">        return _findValueOfKey(_root, _keyGetter, _valueGetter, _keyComparator, key) != null;</span>
    }

    @Override
    public Optional&lt;V&gt; get(K key) {
<span class="fc bfc" id="L516" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L517">            throw new NullPointerException(&quot;Null key&quot;);</span>
        }
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if ( !_keyType.isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L520">            throw new IllegalArgumentException(</span>
<span class="fc" id="L521">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _keyType + &quot;'.&quot;
                );
        }
<span class="fc" id="L525">        V value = _findValueOfKey(_root, _keyGetter, _valueGetter, _keyComparator, key);</span>
<span class="fc" id="L526">        return Optional.ofNullable(value);</span>
    }

    @Override
    public Association&lt;K, V&gt; put(K key, V value) {
<span class="fc bfc" id="L531" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L532">            throw new NullPointerException(&quot;Null key&quot;);</span>
        }
<span class="fc bfc" id="L534" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L535">            throw new NullPointerException(&quot;Null value&quot;);</span>
        }
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if ( !_keyType.isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L538">            throw new IllegalArgumentException(</span>
<span class="fc" id="L539">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _keyType + &quot;'.&quot;
                );
        }
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if ( !_valueType.isAssignableFrom(value.getClass()) ) {</span>
<span class="fc" id="L544">            throw new IllegalArgumentException(</span>
<span class="fc" id="L545">                    &quot;The given value '&quot; + value + &quot;' is of type '&quot; + value.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _valueType + &quot;'.&quot;
                );
        }
<span class="fc" id="L549">        Node newRoot = _balance(_updateValueOfKey(_root, _keyType, _valueType, _keyGetter, _valueGetter, _keyComparator, key, value, false, 0));</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (Util.refEquals(newRoot, _root)) {</span>
<span class="fc" id="L551">            return this;</span>
        }
<span class="fc" id="L553">        return withNewRoot(</span>
                newRoot
        );
    }

    @Override
    public Association&lt;K, V&gt; putIfAbsent(K key, V value) {
<span class="fc bfc" id="L560" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L561">            throw new NullPointerException(&quot;Null key&quot;);</span>
        }
<span class="fc bfc" id="L563" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L564">            throw new NullPointerException(&quot;Null value&quot;);</span>
        }
<span class="fc bfc" id="L566" title="All 2 branches covered.">        if ( !_keyType.isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L567">            throw new IllegalArgumentException(</span>
<span class="fc" id="L568">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _keyType + &quot;'.&quot;
                );
        }
<span class="fc bfc" id="L572" title="All 2 branches covered.">        if ( !_valueType.isAssignableFrom(value.getClass()) ) {</span>
<span class="fc" id="L573">            throw new IllegalArgumentException(</span>
<span class="fc" id="L574">                    &quot;The given value '&quot; + value + &quot;' is of type '&quot; + value.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _valueType + &quot;'.&quot;
                );
        }
<span class="fc" id="L578">        Node newRoot = _balance(_updateValueOfKey(_root, _keyType, _valueType, _keyGetter, _valueGetter, _keyComparator, key, value, true, 0));</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (Util.refEquals(newRoot, _root)) {</span>
<span class="fc" id="L580">            return this;</span>
        }
<span class="fc" id="L582">        return withNewRoot(</span>
                newRoot
        );
    }

    @Override
    public Association&lt;K, V&gt; remove(K key) {
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (key == null) {</span>
<span class="fc" id="L590">            throw new NullPointerException(&quot;Null key&quot;);</span>
        }
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if ( !_keyType.isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L593">            throw new IllegalArgumentException(</span>
<span class="fc" id="L594">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _keyType + &quot;'.&quot;
                );
        }
<span class="fc" id="L598">        Node newRoot = _balanceNullable(_removeKey(_root, _keyType, _valueType, _keyGetter, _valueGetter, _keyComparator, key));</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        newRoot = newRoot == null ? NULL_NODE : newRoot;</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (Util.refEquals(newRoot, _root)) {</span>
<span class="fc" id="L601">            return this;</span>
        }
<span class="fc" id="L603">        return withNewRoot(</span>
                newRoot
        );
    }

    @Override
    public Association&lt;K, V&gt; clear() {
<span class="fc" id="L610">        return Sprouts.factory().associationOfSorted(this.keyType(), this.valueType(), _keyComparator);</span>
    }


    private static &lt;K,V&gt; @Nullable Node _removeKey(
            Node node,
            Class&lt;K&gt; keyType,
            Class&lt;V&gt; valueType,
            final ArrayItemAccess&lt;K, Object&gt; keyGetter,
            final ArrayItemAccess&lt;V, Object&gt; valueGetter,
            Comparator&lt;K&gt; keyComparator,
            K key
    ) {
<span class="fc" id="L623">        int numberOfKeys = _length(node.keysArray());</span>
<span class="fc" id="L624">        int index = _binarySearch(node.keysArray(), keyGetter, keyComparator, key);</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        if ( index &lt; 0 ) {</span>
<span class="fc" id="L626">            Node left = node.left();</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">            if ( left != null ) {</span>
<span class="fc" id="L628">                Node newLeft = _balanceNullable(_removeKey(left, keyType, valueType, keyGetter, valueGetter, keyComparator, key));</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">                if ( Util.refEquals(newLeft, left) ) {</span>
<span class="fc" id="L630">                    return node; // No change in the left node, we can return the current node</span>
                }
<span class="fc" id="L632">                return node.withNewLeft(newLeft);</span>
            }
<span class="fc" id="L634">            return node; // Key not found</span>
        }
<span class="fc bfc" id="L636" title="All 2 branches covered.">        if ( index &gt;= numberOfKeys ) {</span>
<span class="fc" id="L637">            Node right = node.right();</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">            if ( right != null ) {</span>
<span class="fc" id="L639">                Node newRight = _balanceNullable(_removeKey(right, keyType, valueType, keyGetter, valueGetter, keyComparator, key));</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if ( Util.refEquals(newRight, right) ) {</span>
                    // No change in the right node, we can return the current node
<span class="fc" id="L642">                    return node;</span>
                }
<span class="fc" id="L644">                return node.withNewRight(newRight);</span>
            }
<span class="fc" id="L646">            return node; // Key not found</span>
        }
<span class="fc" id="L648">        boolean keyAlreadyExists = Objects.equals(key, _getAt(index, node.keysArray(), keyType));</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">        if ( keyAlreadyExists ) {</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">            if ( numberOfKeys == 1 ) {</span>
<span class="fc" id="L651">                Node left = node.left();</span>
<span class="fc" id="L652">                Node right = node.right();</span>
<span class="fc bfc" id="L653" title="All 4 branches covered.">                if ( left == null || right == null ) {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                    if ( left != null ) {</span>
<span class="fc" id="L655">                        return left;</span>
                    }
<span class="fc bfc" id="L657" title="All 2 branches covered.">                    if ( right != null ) {</span>
<span class="fc" id="L658">                        return right;</span>
                    }
<span class="fc" id="L660">                    return null;</span>
                }
<span class="fc" id="L662">                Object newKeysArray = _createArray(keyType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L663">                Object newValuesArray = _createArray(valueType, ALLOWS_NULL, 1);</span>
<span class="fc" id="L664">                int leftSize = left.size();</span>
<span class="fc" id="L665">                int rightSize = right.size();</span>
                // Only the root node is allowed to be empty, so we rebalance here
<span class="fc bfc" id="L667" title="All 2 branches covered.">                if ( leftSize &gt; rightSize ) {</span>
<span class="fc" id="L668">                    Pair&lt;K,V&gt; rightMostInLeft = _findRightMostElement(left, keyType, valueType);</span>
<span class="fc" id="L669">                    K rightMostKey = rightMostInLeft.first();</span>
<span class="fc" id="L670">                    V rightMostValue = rightMostInLeft.second();</span>
<span class="fc" id="L671">                    _setAt(0, rightMostKey, newKeysArray);</span>
<span class="fc" id="L672">                    _setAt(0, rightMostValue, newValuesArray);</span>
<span class="fc" id="L673">                    left = _balanceNullable(_removeKey(left, keyType, valueType, keyGetter, valueGetter, keyComparator, rightMostKey));</span>
<span class="fc" id="L674">                } else {</span>
<span class="fc" id="L675">                    Pair&lt;K,V&gt; leftMostInRight = _findLeftMostElement(right, keyType, valueType);</span>
<span class="fc" id="L676">                    K leftMostKey = leftMostInRight.first();</span>
<span class="fc" id="L677">                    V leftMostValue = leftMostInRight.second();</span>
<span class="fc" id="L678">                    _setAt(0, leftMostKey, newKeysArray);</span>
<span class="fc" id="L679">                    _setAt(0, leftMostValue, newValuesArray);</span>
<span class="fc" id="L680">                    right = _balanceNullable(_removeKey(right, keyType, valueType, keyGetter, valueGetter, keyComparator, leftMostKey));</span>
                }
<span class="fc" id="L682">                return new Node(node._size - 1, newKeysArray, newValuesArray, left, right);</span>
            }
            // We found the key, we need to remove it
<span class="fc" id="L685">            Object newKeysArray = _createArray(keyType, ALLOWS_NULL, numberOfKeys-1);</span>
<span class="fc" id="L686">            Object newValuesArray = _createArray(valueType, ALLOWS_NULL, numberOfKeys-1);</span>
            // arraycopy
<span class="fc" id="L688">            System.arraycopy(node.keysArray(), 0, newKeysArray, 0, index);</span>
<span class="fc" id="L689">            System.arraycopy(node.keysArray(), index+1, newKeysArray, index, numberOfKeys-index-1);</span>
<span class="fc" id="L690">            System.arraycopy(node.valuesArray(), 0, newValuesArray, 0, index);</span>
<span class="fc" id="L691">            System.arraycopy(node.valuesArray(), index+1, newValuesArray, index, numberOfKeys-index-1);</span>
<span class="fc" id="L692">            return node.withNewArrays(newKeysArray, newValuesArray);</span>
        }
<span class="fc" id="L694">        return node;</span>
    }

    private static &lt;K,V&gt; Pair&lt;K,V&gt; _findRightMostElement(
            Node node,
            Class&lt;K&gt; keyType,
            Class&lt;V&gt; valueType
    ) {
<span class="fc bfc" id="L702" title="All 2 branches covered.">        if ( node.right() != null ) {</span>
<span class="fc" id="L703">            return _findRightMostElement(node.right(), keyType, valueType);</span>
        }
<span class="fc" id="L705">        int numberOfKeys = _length(node.keysArray());</span>
<span class="fc" id="L706">        K key = _getNonNullAt(numberOfKeys-1, node.keysArray(), keyType);</span>
<span class="fc" id="L707">        V value = _getNonNullAt(numberOfKeys-1, node.valuesArray(), valueType);</span>
<span class="fc" id="L708">        return Pair.of(key, value);</span>
    }

    private static &lt;K,V&gt; Pair&lt;K,V&gt; _findLeftMostElement(
            Node node,
            Class&lt;K&gt; keyType,
            Class&lt;V&gt; valueType
    ) {
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if ( node.left() != null ) {</span>
<span class="fc" id="L717">            return _findLeftMostElement(node.left(), keyType, valueType);</span>
        }
<span class="fc" id="L719">        K key = _getNonNullAt(0, node.keysArray(), keyType);</span>
<span class="fc" id="L720">        V value = _getNonNullAt(0, node.valuesArray(), valueType);</span>
<span class="fc" id="L721">        return Pair.of(key, value);</span>
    }

    @Override
    public Map&lt;K, V&gt; toMap() {
<span class="fc" id="L726">        return new AbstractMap&lt;K, V&gt;() {</span>
            @Override
            public V get(Object key) {
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">                if (key == null) {</span>
<span class="nc" id="L730">                    throw new NullPointerException(&quot;Null key&quot;);</span>
                }
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">                if (!keyType().isAssignableFrom(key.getClass())) {</span>
<span class="nc" id="L733">                    throw new ClassCastException(&quot;Key type mismatch&quot;);</span>
                }
<span class="fc" id="L735">                return SortedAssociationImpl.this.get((K) key).orElseThrow(</span>
<span class="nc" id="L736">                                () -&gt; new NoSuchElementException(&quot;Key not found&quot;)</span>
                            );
            }
            @Override
            public boolean containsKey(Object key) {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">                if (key == null) {</span>
<span class="nc" id="L742">                    throw new NullPointerException(&quot;Null key&quot;);</span>
                }
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">                if (!keyType().isAssignableFrom(key.getClass())) {</span>
<span class="nc" id="L745">                    throw new ClassCastException(&quot;Key type mismatch&quot;);</span>
                }
<span class="fc" id="L747">                return SortedAssociationImpl.this.containsKey((K) key);</span>
            }
            @Override
            public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc" id="L751">                return new AbstractSet&lt;Entry&lt;K, V&gt;&gt;() {</span>
                    @Override
                    public Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L754">                        return new Iterator&lt;Entry&lt;K, V&gt;&gt;() {</span>
<span class="fc" id="L755">                            private final Iterator&lt;Pair&lt;K, V&gt;&gt; _iterator = SortedAssociationImpl.this.iterator();</span>

                            @Override
                            public boolean hasNext() {
<span class="fc" id="L759">                                return _iterator.hasNext();</span>
                            }

                            @Override
                            public Entry&lt;K, V&gt; next() {
<span class="fc" id="L764">                                Pair&lt;K, V&gt; pair = _iterator.next();</span>
<span class="fc" id="L765">                                return new SimpleEntry&lt;&gt;(pair.first(), pair.second());</span>
                            }
                        };
                    }

                    @Override
                    public int size() {
<span class="fc" id="L772">                        return SortedAssociationImpl.this.size();</span>
                    }
                };
            }
        };
    }

    @Override
    public Spliterator&lt;Pair&lt;K, V&gt;&gt; spliterator() {
<span class="fc" id="L781">        return Spliterators.spliterator(iterator(), _root.size(),</span>
                Spliterator.SORTED   |
                Spliterator.ORDERED  |
                Spliterator.DISTINCT |
                Spliterator.SIZED    |
                Spliterator.SUBSIZED |
                Spliterator.NONNULL  |
                Spliterator.IMMUTABLE
        );
    }

    static class IteratorFrame {
        final @Nullable IteratorFrame parent;
        final Node node;
<span class="fc" id="L795">        byte stage = 0;  // 0=left, 1=values, 2=right, 3=done</span>
<span class="fc" id="L796">        int index = 0;</span>
<span class="fc" id="L797">        IteratorFrame(@Nullable IteratorFrame parent, Node n) {</span>
<span class="fc" id="L798">            this.parent = parent;</span>
<span class="fc" id="L799">            this.node = n;</span>
<span class="fc" id="L800">        }</span>
    }

    @Override
    public Iterator&lt;Pair&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L805">        return new SortedAssociationIterator&lt;&gt;(this);</span>
    }

    private static final class SortedAssociationIterator&lt;K,V&gt; implements Iterator&lt;Pair&lt;K, V&gt;&gt;
    {
        private final ArrayItemAccess&lt;K, Object&gt; keyGetter;
        private final ArrayItemAccess&lt;V, Object&gt; valueGetter;
<span class="fc" id="L812">        private @Nullable IteratorFrame currentFrame = null;</span>

<span class="fc" id="L814">        SortedAssociationIterator(SortedAssociationImpl&lt;K,V&gt; association) {</span>
<span class="fc" id="L815">            keyGetter = ArrayItemAccess.of(association._keyType, false);</span>
<span class="fc" id="L816">            valueGetter = ArrayItemAccess.of(association._valueType, false);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">            if ( association._root.size() &gt; 0 )</span>
<span class="fc" id="L818">                currentFrame = new IteratorFrame(null, association._root);</span>
<span class="fc" id="L819">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L823" title="All 2 branches covered.">            while (currentFrame != null) {</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">                if (currentFrame.stage == 0) {</span>
<span class="fc" id="L825">                    currentFrame.stage = 1;</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">                    if (currentFrame.node.left() != null)</span>
<span class="fc" id="L827">                        this.currentFrame = new IteratorFrame(currentFrame, currentFrame.node.left());</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                } else if (currentFrame.stage == 1) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">                    if (currentFrame.index &lt; _length(currentFrame.node.keysArray())) return true;</span>
<span class="fc" id="L830">                    currentFrame.stage = 2;</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">                } else if (currentFrame.stage == 2) {</span>
<span class="fc" id="L832">                    currentFrame.stage = 3;</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">                    if (currentFrame.node.right() != null)</span>
<span class="fc" id="L834">                        this.currentFrame = new IteratorFrame(currentFrame, currentFrame.node.right());</span>
                } else {
<span class="fc" id="L836">                    this.currentFrame = currentFrame.parent;</span>
                }
            }
<span class="fc" id="L839">            return false;</span>
        }

        @Override
        public Pair&lt;K, V&gt; next() {
<span class="pc bpc" id="L844" title="2 of 4 branches missed.">            if ( !hasNext() || currentFrame == null )</span>
<span class="nc" id="L845">                throw new NoSuchElementException();</span>
<span class="fc" id="L846">            K key = keyGetter.get(currentFrame.index, currentFrame.node.keysArray());</span>
<span class="fc" id="L847">            V value = valueGetter.get(currentFrame.index, currentFrame.node.valuesArray());</span>
<span class="fc" id="L848">            currentFrame.index++;</span>
<span class="fc" id="L849">            return Pair.of(key, value);</span>
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L855">        int headerHash = Objects.hash(_keyType, _valueType, _keyComparator);</span>
<span class="fc" id="L856">        int contentHash = 31;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">        for (Pair&lt;K, V&gt; thisPair : this) {</span>
<span class="fc" id="L858">            contentHash = 31 * contentHash + Objects.hash(thisPair.first(), thisPair.second());</span>
<span class="fc" id="L859">        }</span>
<span class="fc" id="L860">        return 31 * headerHash + contentHash;</span>
    }

    @Override
    public boolean equals(@Nullable Object obj) {
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L866">            return true;</span>
        }
<span class="pc bpc" id="L868" title="2 of 4 branches missed.">        if (obj == null || getClass() != obj.getClass()) {</span>
<span class="nc" id="L869">            return false;</span>
        }
<span class="fc" id="L871">        SortedAssociationImpl&lt;K, V&gt; other = (SortedAssociationImpl) obj;</span>
<span class="fc" id="L872">        boolean headersEqual =</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">                Objects.equals(_keyType, other._keyType) &amp;&amp;</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">                Objects.equals(_valueType, other._valueType) &amp;&amp;</span>
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">                Objects.equals(_keyComparator, other._keyComparator);</span>

<span class="pc bpc" id="L877" title="1 of 2 branches missed.">        if (!headersEqual)</span>
<span class="nc" id="L878">            return false;</span>

<span class="fc" id="L880">        Iterator&lt;Pair&lt;K, V&gt;&gt; thisIterator = iterator();</span>
<span class="fc" id="L881">        Iterator&lt;Pair&lt;K, V&gt;&gt; otherIterator = other.iterator();</span>
<span class="pc bpc" id="L882" title="1 of 4 branches missed.">        while (thisIterator.hasNext() &amp;&amp; otherIterator.hasNext()) {</span>
<span class="fc" id="L883">            Pair&lt;K, V&gt; thisPair = thisIterator.next();</span>
<span class="fc" id="L884">            Pair&lt;K, V&gt; otherPair = otherIterator.next();</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (!Objects.equals(thisPair.first(), otherPair.first()) ||</span>
<span class="pc bpc" id="L886" title="1 of 2 branches missed.">                !Objects.equals(thisPair.second(), otherPair.second())) {</span>
<span class="fc" id="L887">                return false;</span>
            }
<span class="fc" id="L889">        }</span>
<span class="pc bpc" id="L890" title="1 of 4 branches missed.">        return !thisIterator.hasNext() &amp;&amp; !otherIterator.hasNext();</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L895">        final int MAX_ITEMS = 8;</span>
<span class="fc" id="L896">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L897">        sb.append(&quot;SortedAssociation&quot;);</span>
<span class="fc" id="L898">        sb.append(&quot;&lt;&quot;);</span>
<span class="fc" id="L899">        sb.append(_keyType.getSimpleName());</span>
<span class="fc" id="L900">        sb.append(&quot;,&quot;);</span>
<span class="fc" id="L901">        sb.append(_valueType.getSimpleName());</span>
<span class="fc" id="L902">        sb.append(&quot;&gt;&quot;);</span>
<span class="fc" id="L903">        sb.append(&quot;[&quot;);</span>
<span class="fc" id="L904">        Iterator&lt;Pair&lt;K, V&gt;&gt; iterator = iterator();</span>
<span class="fc" id="L905">        int count = 0;</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">            if (count &gt;= MAX_ITEMS) {</span>
<span class="fc" id="L908">                int itemsLeft = _root.size() - count;</span>
<span class="fc" id="L909">                sb.append(&quot;... &quot;).append(itemsLeft).append(&quot; items left&quot;);</span>
<span class="fc" id="L910">                break;</span>
            }
<span class="fc" id="L912">            Pair&lt;K, V&gt; pair = iterator.next();</span>
<span class="fc" id="L913">            sb.append(Util._toString(pair.first(), _keyType));</span>
<span class="fc" id="L914">            sb.append(&quot;  &quot;);</span>
<span class="fc" id="L915">            sb.append(Util._toString(pair.second(), _valueType));</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">            if (iterator.hasNext()) {</span>
<span class="fc" id="L917">                sb.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L919">            count++;</span>
<span class="fc" id="L920">        }</span>
<span class="fc" id="L921">        return sb.append(&quot;]&quot;).toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>