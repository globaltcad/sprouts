<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinkedValueSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">LinkedValueSet.java</span></div><h1>LinkedValueSet.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.ValueSet;

import java.util.*;
import java.util.stream.Stream;

final class LinkedValueSet&lt;E&gt; implements ValueSet&lt;E&gt; {

    private static final class LinkedEntry&lt;K&gt; {
        private final @Nullable K previousElement;
        private final @Nullable K nextElement;

<span class="fc" id="L15">        LinkedEntry(@Nullable K previousElement, @Nullable K nextElement) {</span>
<span class="fc" id="L16">            this.previousElement = previousElement;</span>
<span class="fc" id="L17">            this.nextElement = nextElement;</span>
<span class="fc" id="L18">        }</span>
        @Nullable
        K previousElement() {
<span class="fc" id="L21">            return this.previousElement;</span>
        }
        @Nullable
        K nextElement() {
<span class="fc" id="L25">            return this.nextElement;</span>
        }
        LinkedEntry&lt;K&gt; withPreviousElement(@Nullable K previousElement) {
<span class="fc" id="L28">            return new LinkedEntry&lt;&gt;(previousElement, this.nextElement);</span>
        }
        LinkedEntry&lt;K&gt; withNextElement(@Nullable K nextKey) {
<span class="fc" id="L31">            return new LinkedEntry&lt;&gt;(this.previousElement, nextKey);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L36">            return &quot;LinkedEntry[previousElement=&quot; + previousElement + &quot;, nextElement=&quot; + nextElement + &quot;]&quot;;</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">            if (!(o instanceof LinkedEntry)) return false;</span>
<span class="fc" id="L43">            LinkedEntry&lt;?&gt; entry = (LinkedEntry&lt;?&gt;) o;</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            return Objects.equals(previousElement, entry.previousElement) &amp;&amp;</span>
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">                   Objects.equals(nextElement, entry.nextElement);</span>
        }

        @Override
        public int hashCode() {
<span class="nc bnc" id="L50" title="All 2 branches missed.">            int result = previousElement != null ? previousElement.hashCode() : 0;</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">            result = 31 * result + (nextElement != null ? nextElement.hashCode() : 0);</span>
<span class="nc" id="L52">            return result;</span>
        }
    }

    private final AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; _entries;
    private final @Nullable E _firstInsertedKey;
    private final @Nullable E _lastInsertedKey;

    LinkedValueSet(
            final Class&lt;E&gt; elementType
    ) {
<span class="fc" id="L63">        this(new AssociationImpl(elementType, LinkedEntry.class), null, null);</span>
<span class="fc" id="L64">    }</span>

    private LinkedValueSet(
            final AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; entries,
            final @Nullable E firstInsertedKey,
            final @Nullable E lastInsertedKey
<span class="fc" id="L70">    ) {</span>
<span class="fc" id="L71">        _entries = entries;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        _firstInsertedKey = firstInsertedKey != null ? firstInsertedKey : lastInsertedKey;</span>
<span class="fc" id="L73">        _lastInsertedKey = lastInsertedKey;</span>
<span class="fc" id="L74">    }</span>


    @Override
    public int size() {
<span class="fc" id="L79">        return _entries.size();</span>
    }

    @Override
    public boolean isLinked() {
<span class="fc" id="L84">        return true;</span>
    }

    @Override
    public boolean isSorted() {
<span class="fc" id="L89">        return false;</span>
    }

    @Override
    public Class&lt;E&gt; type() {
<span class="fc" id="L94">        return _entries.keyType();</span>
    }

    @Override
    public boolean contains(E element) {
<span class="fc" id="L99">        return _entries.containsKey(element);</span>
    }

    @Override
    public ValueSet&lt;E&gt; add(E element) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (Util.refEquals(element, null)) {</span>
<span class="fc" id="L105">            throw new NullPointerException(&quot;Element cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (_entries.containsKey(element)) {</span>
<span class="fc" id="L108">            return this; // Element already exists, return unchanged set</span>
        }

<span class="fc" id="L111">        LinkedEntry&lt;E&gt; newEntry = new LinkedEntry&lt;&gt;(_lastInsertedKey, null);</span>
<span class="fc" id="L112">        AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) _entries.put(element, newEntry);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (Util.refEquals(newEntries, _entries)) {</span>
<span class="nc" id="L114">            return this; // No change in entries, return unchanged set</span>
        }
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (_lastInsertedKey != null) {</span>
<span class="fc" id="L117">            LinkedEntry&lt;E&gt; previousEntry = newEntries.get(_lastInsertedKey).orElse(null);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if (previousEntry != null) {</span>
<span class="fc" id="L119">                previousEntry = previousEntry.withNextElement(element);</span>
<span class="fc" id="L120">                newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(_lastInsertedKey, previousEntry);</span>
            }
        }
<span class="fc" id="L123">        return new LinkedValueSet&lt;&gt;(newEntries, _firstInsertedKey, element);</span>
    }

    @Override
    public ValueSet&lt;E&gt; addAll(Stream&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (Util.refEquals(elements, null)) {</span>
<span class="nc" id="L129">            throw new NullPointerException(&quot;Elements stream cannot be null&quot;);</span>
        }
<span class="fc" id="L131">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        for (Iterator&lt;? extends E&gt; it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L133">            E element = it.next();</span>
<span class="fc" id="L134">            result = result.add(element);</span>
<span class="fc" id="L135">        }</span>
<span class="fc" id="L136">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; remove(E element) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (Util.refEquals(element, null)) {</span>
<span class="nc" id="L142">            throw new NullPointerException(&quot;Element cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (!_entries.containsKey(element)) {</span>
<span class="fc" id="L145">            return this; // Element does not exist, return unchanged set</span>
        }

<span class="fc" id="L148">        AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) _entries.remove(element);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (Util.refEquals(newEntries,_entries)) {</span>
<span class="nc" id="L150">            return this; // No change in entries, return unchanged set</span>
        }

<span class="fc" id="L153">        LinkedEntry&lt;E&gt; entry = _entries.get(element).orElse(null);</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (entry != null) {</span>
<span class="fc" id="L155">            E firstInsertedKey = _firstInsertedKey;</span>
<span class="fc" id="L156">            E lastInsertedKey = _lastInsertedKey;</span>
<span class="pc bpc" id="L157" title="1 of 4 branches missed.">            if (firstInsertedKey != null &amp;&amp; firstInsertedKey.equals(element)) {</span>
<span class="fc" id="L158">                firstInsertedKey = entry.nextElement(); // Update firstInsertedKey if it is the removed element</span>
            }
<span class="pc bpc" id="L160" title="1 of 4 branches missed.">            if (lastInsertedKey != null &amp;&amp; lastInsertedKey.equals(element)) {</span>
<span class="fc" id="L161">                lastInsertedKey = entry.previousElement(); // Update lastInsertedKey if it is the removed element</span>
            }
<span class="fc" id="L163">            E previousKey = entry.previousElement();</span>
<span class="fc" id="L164">            E nextKey = entry.nextElement();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (previousKey != null) {</span>
<span class="fc" id="L166">                LinkedEntry&lt;E&gt; previousEntry = newEntries.get(previousKey).orElse(null);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (previousEntry != null) {</span>
<span class="fc" id="L168">                    previousEntry = previousEntry.withNextElement(nextKey);</span>
<span class="fc" id="L169">                    newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(previousKey, previousEntry);</span>
                }
            }
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (nextKey != null) {</span>
<span class="fc" id="L173">                LinkedEntry&lt;E&gt; nextEntry = newEntries.get(nextKey).orElse(null);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                if (nextEntry != null) {</span>
<span class="fc" id="L175">                    nextEntry = nextEntry.withPreviousElement(previousKey);</span>
<span class="fc" id="L176">                    newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(nextKey, nextEntry);</span>
                }
            }
<span class="fc" id="L179">            return new LinkedValueSet&lt;&gt;(newEntries, firstInsertedKey, lastInsertedKey);</span>
        }
<span class="nc" id="L181">        return this; // If the entry was not found, return unchanged set</span>
    }

    @Override
    public ValueSet&lt;E&gt; removeAll(Stream&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L187">            throw new NullPointerException(&quot;Elements stream cannot be null&quot;);</span>
        }
<span class="fc" id="L189">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (Iterator&lt;? extends E&gt; it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L191">            E element = it.next();</span>
<span class="fc" id="L192">            result = result.remove(element); // Remove each element from the set</span>
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; retainAll(Set&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L200">            throw new NullPointerException(&quot;Elements set cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (elements.isEmpty()) {</span>
<span class="fc" id="L203">            return clear(); // If no elements to retain, clear the set</span>
        }
<span class="fc" id="L205">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (E element : result) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (!elements.contains(element)) {</span>
<span class="fc" id="L208">                result = result.remove(element); // Remove elements not in the provided set</span>
            }
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; clear() {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (_entries.isEmpty()) {</span>
<span class="fc" id="L217">            return this; // Already empty, return unchanged set</span>
        }
<span class="fc" id="L219">        return new LinkedValueSet&lt;&gt;((AssociationImpl) new AssociationImpl&lt;&gt;(type(), LinkedEntry.class), null, null);</span>
    }

    @Override
    public Spliterator&lt;E&gt; spliterator() {
<span class="fc" id="L224">        return Spliterators.spliterator(iterator(), _entries.size(),</span>
                Spliterator.ORDERED |
                        Spliterator.DISTINCT |
                        Spliterator.SIZED |
                        Spliterator.SUBSIZED |
                        Spliterator.NONNULL |
                        Spliterator.IMMUTABLE
        );
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L236">        return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L237">            private @Nullable E current = _firstInsertedKey;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L241" title="All 2 branches covered.">                return current != null;</span>
            }

            @Override
            public E next() {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                if (current == null) {</span>
<span class="nc" id="L247">                    throw new java.util.NoSuchElementException(&quot;No more elements in the set&quot;);</span>
                }
<span class="fc" id="L249">                E nextElement = current;</span>
<span class="fc" id="L250">                LinkedEntry&lt;E&gt; entry = _entries.get(current).orElse(null);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">                if (entry != null) {</span>
<span class="fc" id="L252">                    current = entry.nextElement();</span>
                } else {
<span class="nc" id="L254">                    current = null; // No next element</span>
                }
<span class="fc" id="L256">                return nextElement;</span>
            }
        };
    }

    @Override
    public String toString() {
<span class="fc" id="L263">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L264">        sb.append(&quot;LinkedValueSet&lt;&quot;).append(type().getSimpleName()).append(&quot;&gt;[&quot;);</span>
<span class="fc" id="L265">        final int howMany = 8;</span>
<span class="fc" id="L266">        sb = _appendRecursivelyUpTo(sb, howMany);</span>
<span class="fc" id="L267">        int numberOfElementsLeft = size() - howMany;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if ( numberOfElementsLeft &gt; 0 ) {</span>
<span class="fc" id="L269">            sb.append(&quot;, ... &quot;).append(numberOfElementsLeft).append(&quot; items left&quot;);</span>
        }
<span class="fc" id="L271">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L272">        return sb.toString();</span>
    }

    private StringBuilder _appendRecursivelyUpTo(StringBuilder sb, int howMany) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (howMany &lt;= 0) {</span>
<span class="nc" id="L277">            return sb;</span>
        }
<span class="fc" id="L279">        Iterator&lt;E&gt; it = iterator();</span>
<span class="fc" id="L280">        int count = 0;</span>
<span class="fc bfc" id="L281" title="All 4 branches covered.">        while (it.hasNext() &amp;&amp; count &lt; howMany) {</span>
<span class="fc" id="L282">            E element = it.next();</span>
<span class="fc" id="L283">            sb.append(Util._toString(element, type()));</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (it.hasNext()) {</span>
<span class="fc" id="L285">                sb.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L287">            count++;</span>
<span class="fc" id="L288">        }</span>
<span class="fc" id="L289">        return sb;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (!(o instanceof LinkedValueSet))</span>
<span class="nc" id="L296">            return false;</span>
<span class="fc" id="L297">        LinkedValueSet&lt;E&gt; other = (LinkedValueSet) o;</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if ( !_entries.keyType().equals(other._entries.keyType()) )</span>
<span class="nc" id="L299">            return false;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if ( _entries.size() != other._entries.size() )</span>
<span class="fc" id="L301">            return false;</span>

<span class="fc" id="L303">        return _recursiveEquals(this._entries._root, other._entries._root, this.type());</span>
    }

    private static &lt;K&gt; boolean _exhaustiveEquals(
            AssociationImpl&lt;K,LinkedEntry&lt;K&gt;&gt; assoc1, AssociationImpl&lt;K,LinkedEntry&lt;K&gt;&gt; assoc2
    ) {
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if ( assoc2.size() != assoc1.size() ) {</span>
<span class="fc" id="L310">            return false;</span>
        }
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for ( K key : assoc1.keySet() ) {</span>
<span class="fc" id="L313">            int keyHash = key.hashCode();</span>
<span class="fc" id="L314">            LinkedEntry&lt;K&gt; firstEntry = AssociationImpl._get(assoc1._root, assoc1._keyGetter, assoc1._valueGetter, key, keyHash);</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">            if ( firstEntry == null ) {</span>
<span class="nc" id="L316">                return false;</span>
            }
<span class="fc" id="L318">            LinkedEntry&lt;K&gt; otherEntry = AssociationImpl._get(assoc2._root, assoc2._keyGetter, assoc2._valueGetter, key, keyHash);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if ( otherEntry == null ) {</span>
<span class="fc" id="L320">                return false;</span>
            }
<span class="fc" id="L322">        }</span>
<span class="fc" id="L323">        return true;</span>
    }

    private static &lt;K&gt; boolean _recursiveEquals(
            AssociationImpl.@Nullable Node&lt;K,LinkedEntry&lt;K&gt;&gt; node1,
            AssociationImpl.@Nullable Node&lt;K,LinkedEntry&lt;K&gt;&gt; node2,
            Class&lt;K&gt; keyType
    ) {
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if ( node1 == node2 ) {</span>
<span class="fc" id="L332">            return true;</span>
        } else {
<span class="fc bfc" id="L334" title="All 4 branches covered.">            if ( node1 == null || node2 == null ) {</span>
<span class="fc" id="L335">                return false;</span>
            }
<span class="pc bpc" id="L337" title="3 of 12 branches missed.">            if (</span>
                node1._size == node2._size &amp;&amp;
                node1._keysArray == node2._keysArray &amp;&amp;
                node1._valuesArray == node2._valuesArray &amp;&amp;
                node1._keyHashes == node2._keyHashes &amp;&amp;
                node1._branches.length == node2._branches.length &amp;&amp;
                node1._branches != node2._branches // The only difference is somewhere deep down!
            ) {
<span class="fc bfc" id="L345" title="All 2 branches covered.">                for ( int i = 0; i &lt; node1._branches.length; i++ ) {</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">                    if ( !_recursiveEquals(node1._branches[i], node2._branches[i], keyType) ) {</span>
<span class="fc" id="L347">                        return false;</span>
                    }
                }
<span class="fc" id="L350">                return true;</span>
            } else {
<span class="fc" id="L352">                return _exhaustiveEquals(</span>
                        new AssociationImpl(keyType, LinkedEntry.class, node1),
                        new AssociationImpl(keyType, LinkedEntry.class, node2)
                );
            }
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L362">        int hash = 7;</span>
<span class="fc" id="L363">        hash = 31 * hash + Objects.hashCode(_entries.keyType());</span>
<span class="fc" id="L364">        hash = 31 * hash + toSet().hashCode();</span>
<span class="fc" id="L365">        return hash;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>