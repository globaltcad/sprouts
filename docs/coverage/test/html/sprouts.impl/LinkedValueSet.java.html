<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinkedValueSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">LinkedValueSet.java</span></div><h1>LinkedValueSet.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.ValueSet;

import java.util.*;
import java.util.stream.Stream;

final class LinkedValueSet&lt;E&gt; implements ValueSet&lt;E&gt; {

    private static final class LinkedEntry&lt;K&gt; {
        private final @Nullable K previousElement;
        private final @Nullable K nextElement;

<span class="fc" id="L15">        LinkedEntry(@Nullable K previousElement, @Nullable K nextElement) {</span>
<span class="fc" id="L16">            this.previousElement = previousElement;</span>
<span class="fc" id="L17">            this.nextElement = nextElement;</span>
<span class="fc" id="L18">        }</span>
        @Nullable
        K previousElement() {
<span class="fc" id="L21">            return this.previousElement;</span>
        }
        @Nullable
        K nextElement() {
<span class="fc" id="L25">            return this.nextElement;</span>
        }
        LinkedEntry&lt;K&gt; withPreviousElement(@Nullable K previousElement) {
<span class="fc" id="L28">            return new LinkedEntry&lt;&gt;(previousElement, this.nextElement);</span>
        }
        LinkedEntry&lt;K&gt; withNextElement(@Nullable K nextKey) {
<span class="fc" id="L31">            return new LinkedEntry&lt;&gt;(this.previousElement, nextKey);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L36">            return &quot;LinkedEntry[previousElement=&quot; + previousElement + &quot;, nextElement=&quot; + nextElement + &quot;]&quot;;</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">            if (!(o instanceof LinkedEntry)) return false;</span>
<span class="fc" id="L43">            LinkedEntry&lt;?&gt; entry = (LinkedEntry&lt;?&gt;) o;</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            return Objects.equals(previousElement, entry.previousElement) &amp;&amp;</span>
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">                   Objects.equals(nextElement, entry.nextElement);</span>
        }

        @Override
        public int hashCode() {
<span class="nc bnc" id="L50" title="All 2 branches missed.">            int result = previousElement != null ? previousElement.hashCode() : 0;</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">            result = 31 * result + (nextElement != null ? nextElement.hashCode() : 0);</span>
<span class="nc" id="L52">            return result;</span>
        }
    }

    private final AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; _entries;
    private final @Nullable E _firstInsertedKey;
    private final @Nullable E _lastInsertedKey;

    LinkedValueSet(
            final Class&lt;E&gt; elementType
    ) {
<span class="fc" id="L63">        this(new AssociationImpl(elementType, LinkedEntry.class), null, null);</span>
<span class="fc" id="L64">    }</span>

    private LinkedValueSet(
            final AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; entries,
            final @Nullable E firstInsertedKey,
            final @Nullable E lastInsertedKey
<span class="fc" id="L70">    ) {</span>
<span class="fc" id="L71">        _entries = entries;</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        _firstInsertedKey = firstInsertedKey != null ? firstInsertedKey : lastInsertedKey;</span>
<span class="fc" id="L73">        _lastInsertedKey = lastInsertedKey;</span>
<span class="fc" id="L74">    }</span>


    @Override
    public int size() {
<span class="fc" id="L79">        return _entries.size();</span>
    }

    @Override
    public boolean isLinked() {
<span class="fc" id="L84">        return true;</span>
    }

    @Override
    public boolean isSorted() {
<span class="fc" id="L89">        return false;</span>
    }

    @Override
    public Class&lt;E&gt; type() {
<span class="fc" id="L94">        return _entries.keyType();</span>
    }

    @Override
    public boolean contains(E element) {
<span class="fc" id="L99">        return _entries.containsKey(element);</span>
    }

    @Override
    public ValueSet&lt;E&gt; add(E element) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (Util.refEquals(element, null)) {</span>
<span class="fc" id="L105">            throw new NullPointerException(&quot;Element cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (_entries.containsKey(element)) {</span>
<span class="fc" id="L108">            return this; // Element already exists, return unchanged set</span>
        }

<span class="fc" id="L111">        LinkedEntry&lt;E&gt; newEntry = new LinkedEntry&lt;&gt;(_lastInsertedKey, null);</span>
<span class="fc" id="L112">        AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) _entries.put(element, newEntry);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (Util.refEquals(newEntries, _entries)) {</span>
<span class="nc" id="L114">            return this; // No change in entries, return unchanged set</span>
        }
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (_lastInsertedKey != null) {</span>
<span class="fc" id="L117">            LinkedEntry&lt;E&gt; previousEntry = newEntries.get(_lastInsertedKey).orElse(null);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if (previousEntry != null) {</span>
<span class="fc" id="L119">                previousEntry = previousEntry.withNextElement(element);</span>
<span class="fc" id="L120">                newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(_lastInsertedKey, previousEntry);</span>
            }
        }
<span class="fc" id="L123">        return new LinkedValueSet&lt;&gt;(newEntries, _firstInsertedKey, element);</span>
    }

    @Override
    public ValueSet&lt;E&gt; addAll(Stream&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (Util.refEquals(elements, null)) {</span>
<span class="nc" id="L129">            throw new NullPointerException(&quot;Elements stream cannot be null&quot;);</span>
        }
<span class="fc" id="L131">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        for (Iterator&lt;? extends E&gt; it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L133">            E element = it.next();</span>
<span class="fc" id="L134">            result = result.add(element);</span>
<span class="fc" id="L135">        }</span>
<span class="fc" id="L136">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; remove(E element) {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (Util.refEquals(element, null)) {</span>
<span class="nc" id="L142">            throw new NullPointerException(&quot;Element cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (!_entries.containsKey(element)) {</span>
<span class="fc" id="L145">            return this; // Element does not exist, return unchanged set</span>
        }

<span class="fc" id="L148">        AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) _entries.remove(element);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (Util.refEquals(newEntries,_entries)) {</span>
<span class="nc" id="L150">            return this; // No change in entries, return unchanged set</span>
        }

<span class="fc" id="L153">        LinkedEntry&lt;E&gt; entry = _entries.get(element).orElse(null);</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        if (entry != null) {</span>
<span class="fc" id="L155">            E firstInsertedKey = _firstInsertedKey;</span>
<span class="fc" id="L156">            E lastInsertedKey = _lastInsertedKey;</span>
<span class="pc bpc" id="L157" title="1 of 4 branches missed.">            if (firstInsertedKey != null &amp;&amp; firstInsertedKey.equals(element)) {</span>
<span class="fc" id="L158">                firstInsertedKey = entry.nextElement(); // Update firstInsertedKey if it is the removed element</span>
            }
<span class="pc bpc" id="L160" title="1 of 4 branches missed.">            if (lastInsertedKey != null &amp;&amp; lastInsertedKey.equals(element)) {</span>
<span class="fc" id="L161">                lastInsertedKey = entry.previousElement(); // Update lastInsertedKey if it is the removed element</span>
            }
<span class="fc" id="L163">            E previousKey = entry.previousElement();</span>
<span class="fc" id="L164">            E nextKey = entry.nextElement();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (previousKey != null) {</span>
<span class="fc" id="L166">                LinkedEntry&lt;E&gt; previousEntry = newEntries.get(previousKey).orElse(null);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">                if (previousEntry != null) {</span>
<span class="fc" id="L168">                    previousEntry = previousEntry.withNextElement(nextKey);</span>
<span class="fc" id="L169">                    newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(previousKey, previousEntry);</span>
                }
            }
<span class="fc bfc" id="L172" title="All 2 branches covered.">            if (nextKey != null) {</span>
<span class="fc" id="L173">                LinkedEntry&lt;E&gt; nextEntry = newEntries.get(nextKey).orElse(null);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                if (nextEntry != null) {</span>
<span class="fc" id="L175">                    nextEntry = nextEntry.withPreviousElement(previousKey);</span>
<span class="fc" id="L176">                    newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(nextKey, nextEntry);</span>
                }
            }
<span class="fc" id="L179">            return new LinkedValueSet&lt;&gt;(newEntries, firstInsertedKey, lastInsertedKey);</span>
        }
<span class="nc" id="L181">        return this; // If the entry was not found, return unchanged set</span>
    }

    @Override
    public ValueSet&lt;E&gt; removeAll(Stream&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L187">            throw new NullPointerException(&quot;Elements stream cannot be null&quot;);</span>
        }
<span class="fc" id="L189">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        for (Iterator&lt;? extends E&gt; it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L191">            E element = it.next();</span>
<span class="fc" id="L192">            result = result.remove(element); // Remove each element from the set</span>
<span class="fc" id="L193">        }</span>
<span class="fc" id="L194">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; retainAll(Set&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L200">            throw new NullPointerException(&quot;Elements set cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (elements.isEmpty()) {</span>
<span class="fc" id="L203">            return clear(); // If no elements to retain, clear the set</span>
        }
<span class="fc" id="L205">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">        for (E element : result) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (!elements.contains(element)) {</span>
<span class="fc" id="L208">                result = result.remove(element); // Remove elements not in the provided set</span>
            }
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; clear() {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if (_entries.isEmpty()) {</span>
<span class="fc" id="L217">            return this; // Already empty, return unchanged set</span>
        }
<span class="fc" id="L219">        return new LinkedValueSet&lt;&gt;((AssociationImpl) new AssociationImpl&lt;&gt;(type(), LinkedEntry.class), null, null);</span>
    }

    @Override
    public Spliterator&lt;E&gt; spliterator() {
<span class="fc" id="L224">        return Spliterators.spliterator(iterator(), _entries.size(),</span>
                Spliterator.ORDERED |
                        Spliterator.DISTINCT |
                        Spliterator.SIZED |
                        Spliterator.SUBSIZED |
                        Spliterator.NONNULL |
                        Spliterator.IMMUTABLE
        );
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L236">        return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L237">            private @Nullable E current = _firstInsertedKey;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L241" title="All 2 branches covered.">                return current != null;</span>
            }

            @Override
            public E next() {
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">                if (current == null) {</span>
<span class="nc" id="L247">                    throw new java.util.NoSuchElementException(&quot;No more elements in the set&quot;);</span>
                }
<span class="fc" id="L249">                E nextElement = current;</span>
<span class="fc" id="L250">                LinkedEntry&lt;E&gt; entry = _entries.get(current).orElse(null);</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">                if (entry != null) {</span>
<span class="fc" id="L252">                    current = entry.nextElement();</span>
                } else {
<span class="nc" id="L254">                    current = null; // No next element</span>
                }
<span class="fc" id="L256">                return nextElement;</span>
            }
        };
    }

    @Override
    public String toString() {
<span class="fc" id="L263">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L264">        sb.append(&quot;LinkedValueSet&lt;&quot;).append(type().getSimpleName()).append(&quot;&gt;[&quot;);</span>
<span class="fc" id="L265">        final int howMany = 8;</span>
<span class="fc" id="L266">        sb = _appendRecursivelyUpTo(sb, howMany);</span>
<span class="fc" id="L267">        int numberOfElementsLeft = size() - howMany;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if ( numberOfElementsLeft &gt; 0 ) {</span>
<span class="fc" id="L269">            sb.append(&quot;, ... &quot;).append(numberOfElementsLeft).append(&quot; items left&quot;);</span>
        }
<span class="fc" id="L271">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L272">        return sb.toString();</span>
    }

    private StringBuilder _appendRecursivelyUpTo(StringBuilder sb, int howMany) {
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        if (howMany &lt;= 0) {</span>
<span class="nc" id="L277">            return sb;</span>
        }
<span class="fc" id="L279">        Iterator&lt;E&gt; it = iterator();</span>
<span class="fc" id="L280">        int count = 0;</span>
<span class="fc bfc" id="L281" title="All 4 branches covered.">        while (it.hasNext() &amp;&amp; count &lt; howMany) {</span>
<span class="fc" id="L282">            E element = it.next();</span>
<span class="fc" id="L283">            sb.append(Util._toString(element, type()));</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (it.hasNext()) {</span>
<span class="fc" id="L285">                sb.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L287">            count++;</span>
<span class="fc" id="L288">        }</span>
<span class="fc" id="L289">        return sb;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L295">            return true;</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (!(o instanceof LinkedValueSet))</span>
<span class="nc" id="L297">            return false;</span>
<span class="fc" id="L298">        LinkedValueSet&lt;?&gt; that = (LinkedValueSet&lt;?&gt;) o;</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if ( !that.type().equals(type()) )</span>
<span class="nc" id="L300">            return false;</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (that.size() != size())</span>
<span class="fc" id="L302">            return false;</span>

<span class="fc" id="L304">        return this.toSet().equals(that.toSet());</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L309">        int hash = 7;</span>
<span class="fc" id="L310">        hash = 31 * hash + Objects.hashCode(_entries.keyType());</span>
<span class="fc" id="L311">        hash = 31 * hash + toSet().hashCode();</span>
<span class="fc" id="L312">        return hash;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>