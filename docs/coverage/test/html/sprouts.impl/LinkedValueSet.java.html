<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinkedValueSet.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">LinkedValueSet.java</span></div><h1>LinkedValueSet.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.ValueSet;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Stream;

final class LinkedValueSet&lt;E&gt; implements ValueSet&lt;E&gt; {

    private static final class LinkedEntry&lt;K&gt; {
        private final @Nullable K previousElement;
        private final @Nullable K nextElement;

<span class="fc" id="L16">        LinkedEntry(@Nullable K previousElement, @Nullable K nextElement) {</span>
<span class="fc" id="L17">            this.previousElement = previousElement;</span>
<span class="fc" id="L18">            this.nextElement = nextElement;</span>
<span class="fc" id="L19">        }</span>
        @Nullable
        K previousElement() {
<span class="fc" id="L22">            return this.previousElement;</span>
        }
        @Nullable
        K nextElement() {
<span class="fc" id="L26">            return this.nextElement;</span>
        }
        LinkedEntry&lt;K&gt; withPreviousElement(@Nullable K previousElement) {
<span class="fc" id="L29">            return new LinkedEntry&lt;&gt;(previousElement, this.nextElement);</span>
        }
        LinkedEntry&lt;K&gt; withNextElement(@Nullable K nextKey) {
<span class="fc" id="L32">            return new LinkedEntry&lt;&gt;(this.previousElement, nextKey);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L37">            return &quot;LinkedEntry[previousElement=&quot; + previousElement + &quot;, nextElement=&quot; + nextElement + &quot;]&quot;;</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">            if (!(o instanceof LinkedEntry)) return false;</span>
<span class="fc" id="L44">            LinkedEntry&lt;?&gt; entry = (LinkedEntry&lt;?&gt;) o;</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">            return Objects.equals(previousElement, entry.previousElement) &amp;&amp;</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">                   Objects.equals(nextElement, entry.nextElement);</span>
        }

        @Override
        public int hashCode() {
<span class="nc bnc" id="L51" title="All 2 branches missed.">            int result = previousElement != null ? previousElement.hashCode() : 0;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">            result = 31 * result + (nextElement != null ? nextElement.hashCode() : 0);</span>
<span class="nc" id="L53">            return result;</span>
        }
    }

    private final AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; _entries;
    private final @Nullable E _firstInsertedKey;
    private final @Nullable E _lastInsertedKey;
<span class="fc" id="L60">    private final AtomicReference&lt;@Nullable Integer&gt; _cachedHashCode = new AtomicReference&lt;&gt;(null);</span>

    LinkedValueSet(
            final Class&lt;E&gt; elementType
    ) {
<span class="fc" id="L65">        this(new AssociationImpl(elementType, LinkedEntry.class), null, null);</span>
<span class="fc" id="L66">    }</span>

    private LinkedValueSet(
            final AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; entries,
            final @Nullable E firstInsertedKey,
            final @Nullable E lastInsertedKey
<span class="fc" id="L72">    ) {</span>
<span class="fc" id="L73">        _entries = entries;</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">        _firstInsertedKey = firstInsertedKey != null ? firstInsertedKey : lastInsertedKey;</span>
<span class="fc" id="L75">        _lastInsertedKey = lastInsertedKey;</span>
<span class="fc" id="L76">    }</span>


    @Override
    public int size() {
<span class="fc" id="L81">        return _entries.size();</span>
    }

    @Override
    public boolean isLinked() {
<span class="fc" id="L86">        return true;</span>
    }

    @Override
    public boolean isSorted() {
<span class="fc" id="L91">        return false;</span>
    }

    @Override
    public Class&lt;E&gt; type() {
<span class="fc" id="L96">        return _entries.keyType();</span>
    }

    @Override
    public boolean contains(E element) {
<span class="fc" id="L101">        return _entries.containsKey(element);</span>
    }

    @Override
    public ValueSet&lt;E&gt; add(E element) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (Util.refEquals(element, null)) {</span>
<span class="fc" id="L107">            throw new NullPointerException(&quot;Element cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (_entries.containsKey(element)) {</span>
<span class="fc" id="L110">            return this; // Element already exists, return unchanged set</span>
        }

<span class="fc" id="L113">        LinkedEntry&lt;E&gt; newEntry = new LinkedEntry&lt;&gt;(_lastInsertedKey, null);</span>
<span class="fc" id="L114">        AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) _entries.put(element, newEntry);</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (Util.refEquals(newEntries, _entries)) {</span>
<span class="nc" id="L116">            return this; // No change in entries, return unchanged set</span>
        }
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (_lastInsertedKey != null) {</span>
<span class="fc" id="L119">            LinkedEntry&lt;E&gt; previousEntry = newEntries.get(_lastInsertedKey).orElse(null);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if (previousEntry != null) {</span>
<span class="fc" id="L121">                previousEntry = previousEntry.withNextElement(element);</span>
<span class="fc" id="L122">                newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(_lastInsertedKey, previousEntry);</span>
            }
        }
<span class="fc" id="L125">        return new LinkedValueSet&lt;&gt;(newEntries, _firstInsertedKey, element);</span>
    }

    @Override
    public ValueSet&lt;E&gt; addAll(Stream&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        if (Util.refEquals(elements, null)) {</span>
<span class="nc" id="L131">            throw new NullPointerException(&quot;Elements stream cannot be null&quot;);</span>
        }
<span class="fc" id="L133">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (Iterator&lt;? extends E&gt; it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L135">            E element = it.next();</span>
<span class="fc" id="L136">            result = result.add(element);</span>
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; remove(E element) {
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        if (Util.refEquals(element, null)) {</span>
<span class="nc" id="L144">            throw new NullPointerException(&quot;Element cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (!_entries.containsKey(element)) {</span>
<span class="fc" id="L147">            return this; // Element does not exist, return unchanged set</span>
        }

<span class="fc" id="L150">        AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt; newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) _entries.remove(element);</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">        if (Util.refEquals(newEntries,_entries)) {</span>
<span class="nc" id="L152">            return this; // No change in entries, return unchanged set</span>
        }

<span class="fc" id="L155">        LinkedEntry&lt;E&gt; entry = _entries.get(element).orElse(null);</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (entry != null) {</span>
<span class="fc" id="L157">            E firstInsertedKey = _firstInsertedKey;</span>
<span class="fc" id="L158">            E lastInsertedKey = _lastInsertedKey;</span>
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">            if (firstInsertedKey != null &amp;&amp; firstInsertedKey.equals(element)) {</span>
<span class="fc" id="L160">                firstInsertedKey = entry.nextElement(); // Update firstInsertedKey if it is the removed element</span>
            }
<span class="pc bpc" id="L162" title="1 of 4 branches missed.">            if (lastInsertedKey != null &amp;&amp; lastInsertedKey.equals(element)) {</span>
<span class="fc" id="L163">                lastInsertedKey = entry.previousElement(); // Update lastInsertedKey if it is the removed element</span>
            }
<span class="fc" id="L165">            E previousKey = entry.previousElement();</span>
<span class="fc" id="L166">            E nextKey = entry.nextElement();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            if (previousKey != null) {</span>
<span class="fc" id="L168">                LinkedEntry&lt;E&gt; previousEntry = newEntries.get(previousKey).orElse(null);</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">                if (previousEntry != null) {</span>
<span class="fc" id="L170">                    previousEntry = previousEntry.withNextElement(nextKey);</span>
<span class="fc" id="L171">                    newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(previousKey, previousEntry);</span>
                }
            }
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (nextKey != null) {</span>
<span class="fc" id="L175">                LinkedEntry&lt;E&gt; nextEntry = newEntries.get(nextKey).orElse(null);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">                if (nextEntry != null) {</span>
<span class="fc" id="L177">                    nextEntry = nextEntry.withPreviousElement(previousKey);</span>
<span class="fc" id="L178">                    newEntries = (AssociationImpl&lt;E, LinkedEntry&lt;E&gt;&gt;) newEntries.put(nextKey, nextEntry);</span>
                }
            }
<span class="fc" id="L181">            return new LinkedValueSet&lt;&gt;(newEntries, firstInsertedKey, lastInsertedKey);</span>
        }
<span class="nc" id="L183">        return this; // If the entry was not found, return unchanged set</span>
    }

    @Override
    public ValueSet&lt;E&gt; removeAll(Stream&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L189">            throw new NullPointerException(&quot;Elements stream cannot be null&quot;);</span>
        }
<span class="fc" id="L191">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">        for (Iterator&lt;? extends E&gt; it = elements.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L193">            E element = it.next();</span>
<span class="fc" id="L194">            result = result.remove(element); // Remove each element from the set</span>
<span class="fc" id="L195">        }</span>
<span class="fc" id="L196">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; retainAll(Set&lt;? extends E&gt; elements) {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">        if (elements == null) {</span>
<span class="nc" id="L202">            throw new NullPointerException(&quot;Elements set cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (elements.isEmpty()) {</span>
<span class="fc" id="L205">            return clear(); // If no elements to retain, clear the set</span>
        }
<span class="fc" id="L207">        ValueSet&lt;E&gt; result = this;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (E element : result) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (!elements.contains(element)) {</span>
<span class="fc" id="L210">                result = result.remove(element); // Remove elements not in the provided set</span>
            }
<span class="fc" id="L212">        }</span>
<span class="fc" id="L213">        return result;</span>
    }

    @Override
    public ValueSet&lt;E&gt; clear() {
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (_entries.isEmpty()) {</span>
<span class="fc" id="L219">            return this; // Already empty, return unchanged set</span>
        }
<span class="fc" id="L221">        return new LinkedValueSet&lt;&gt;((AssociationImpl) new AssociationImpl&lt;&gt;(type(), LinkedEntry.class), null, null);</span>
    }

    @Override
    public Spliterator&lt;E&gt; spliterator() {
<span class="fc" id="L226">        return Spliterators.spliterator(iterator(), _entries.size(),</span>
                Spliterator.ORDERED |
                        Spliterator.DISTINCT |
                        Spliterator.SIZED |
                        Spliterator.SUBSIZED |
                        Spliterator.NONNULL |
                        Spliterator.IMMUTABLE
        );
    }

    @Override
    public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L238">        return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L239">            private @Nullable E current = _firstInsertedKey;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L243" title="All 2 branches covered.">                return current != null;</span>
            }

            @Override
            public E next() {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">                if (current == null) {</span>
<span class="nc" id="L249">                    throw new java.util.NoSuchElementException(&quot;No more elements in the set&quot;);</span>
                }
<span class="fc" id="L251">                E nextElement = current;</span>
<span class="fc" id="L252">                LinkedEntry&lt;E&gt; entry = _entries.get(current).orElse(null);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                if (entry != null) {</span>
<span class="fc" id="L254">                    current = entry.nextElement();</span>
                } else {
<span class="nc" id="L256">                    current = null; // No next element</span>
                }
<span class="fc" id="L258">                return nextElement;</span>
            }
        };
    }

    @Override
    public String toString() {
<span class="fc" id="L265">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L266">        sb.append(&quot;LinkedValueSet&lt;&quot;).append(type().getSimpleName()).append(&quot;&gt;[&quot;);</span>
<span class="fc" id="L267">        final int howMany = 8;</span>
<span class="fc" id="L268">        sb = _appendRecursivelyUpTo(sb, howMany);</span>
<span class="fc" id="L269">        int numberOfElementsLeft = size() - howMany;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if ( numberOfElementsLeft &gt; 0 ) {</span>
<span class="fc" id="L271">            sb.append(&quot;, ... &quot;).append(numberOfElementsLeft).append(&quot; items left&quot;);</span>
        }
<span class="fc" id="L273">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L274">        return sb.toString();</span>
    }

    private StringBuilder _appendRecursivelyUpTo(StringBuilder sb, int howMany) {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (howMany &lt;= 0) {</span>
<span class="nc" id="L279">            return sb;</span>
        }
<span class="fc" id="L281">        Iterator&lt;E&gt; it = iterator();</span>
<span class="fc" id="L282">        int count = 0;</span>
<span class="fc bfc" id="L283" title="All 4 branches covered.">        while (it.hasNext() &amp;&amp; count &lt; howMany) {</span>
<span class="fc" id="L284">            E element = it.next();</span>
<span class="fc" id="L285">            sb.append(Util._toString(element, type()));</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            if (it.hasNext()) {</span>
<span class="fc" id="L287">                sb.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L289">            count++;</span>
<span class="fc" id="L290">        }</span>
<span class="fc" id="L291">        return sb;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (!(o instanceof LinkedValueSet))</span>
<span class="nc" id="L298">            return false;</span>
<span class="fc" id="L299">        LinkedValueSet&lt;E&gt; other = (LinkedValueSet) o;</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if ( !_entries.keyType().equals(other._entries.keyType()) )</span>
<span class="nc" id="L301">            return false;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if ( _entries.size() != other._entries.size() )</span>
<span class="fc" id="L303">            return false;</span>

<span class="fc" id="L305">        return _recursiveEquals(this._entries._root, other._entries._root, this.type());</span>
    }

    private static &lt;K&gt; boolean _exhaustiveEquals(
            AssociationImpl&lt;K,LinkedEntry&lt;K&gt;&gt; assoc1, AssociationImpl&lt;K,LinkedEntry&lt;K&gt;&gt; assoc2
    ) {
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if ( assoc2.size() != assoc1.size() ) {</span>
<span class="fc" id="L312">            return false;</span>
        }
<span class="fc bfc" id="L314" title="All 2 branches covered.">        for ( K key : assoc1.keySet() ) {</span>
<span class="fc" id="L315">            int keyHash = key.hashCode();</span>
<span class="fc" id="L316">            LinkedEntry&lt;K&gt; firstEntry = AssociationImpl._get(assoc1._root, assoc1._keyGetter, assoc1._valueGetter, key, keyHash);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            if ( firstEntry == null ) {</span>
<span class="nc" id="L318">                return false;</span>
            }
<span class="fc" id="L320">            LinkedEntry&lt;K&gt; otherEntry = AssociationImpl._get(assoc2._root, assoc2._keyGetter, assoc2._valueGetter, key, keyHash);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">            if ( otherEntry == null ) {</span>
<span class="fc" id="L322">                return false;</span>
            }
<span class="fc" id="L324">        }</span>
<span class="fc" id="L325">        return true;</span>
    }

    private static &lt;K&gt; boolean _recursiveEquals(
            AssociationImpl.@Nullable Node&lt;K,LinkedEntry&lt;K&gt;&gt; node1,
            AssociationImpl.@Nullable Node&lt;K,LinkedEntry&lt;K&gt;&gt; node2,
            Class&lt;K&gt; keyType
    ) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if ( node1 == node2 ) {</span>
<span class="fc" id="L334">            return true;</span>
        } else {
<span class="fc bfc" id="L336" title="All 4 branches covered.">            if ( node1 == null || node2 == null ) {</span>
<span class="fc" id="L337">                return false;</span>
            }
<span class="pc bpc" id="L339" title="3 of 12 branches missed.">            if (</span>
                node1._size == node2._size &amp;&amp;
                node1._keysArray == node2._keysArray &amp;&amp;
                node1._valuesArray == node2._valuesArray &amp;&amp;
                node1._keyHashes == node2._keyHashes &amp;&amp;
                node1._branches.length == node2._branches.length &amp;&amp;
                node1._branches != node2._branches // The only difference is somewhere deep down!
            ) {
<span class="fc bfc" id="L347" title="All 2 branches covered.">                for ( int i = 0; i &lt; node1._branches.length; i++ ) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                    if ( !_recursiveEquals(node1._branches[i], node2._branches[i], keyType) ) {</span>
<span class="fc" id="L349">                        return false;</span>
                    }
                }
<span class="fc" id="L352">                return true;</span>
            } else {
<span class="fc" id="L354">                return _exhaustiveEquals(</span>
                        new AssociationImpl(keyType, LinkedEntry.class, node1),
                        new AssociationImpl(keyType, LinkedEntry.class, node2)
                );
            }
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L364">        Integer cached = _cachedHashCode.get();</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if ( cached != null ) {</span>
<span class="fc" id="L366">            return cached;</span>
        }
<span class="fc" id="L368">        int hash = 7;</span>
<span class="fc" id="L369">        hash = 31 * hash + Objects.hashCode(_entries.keyType());</span>
<span class="fc" id="L370">        int elementsHash = 0;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">        for ( E element : this ) {</span>
<span class="fc" id="L372">            elementsHash += Objects.hashCode(element);</span>
<span class="fc" id="L373">        }</span>
<span class="fc" id="L374">        hash = 31 * hash + elementsHash;</span>
<span class="fc" id="L375">        _cachedHashCode.set(hash);</span>
<span class="fc" id="L376">        return hash;</span>
    }


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>