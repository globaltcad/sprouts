<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinkedAssociation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sprouts</a> &gt; <a href="index.source.html" class="el_package">sprouts.impl</a> &gt; <span class="el_source">LinkedAssociation.java</span></div><h1>LinkedAssociation.java</h1><pre class="source lang-java linenums">package sprouts.impl;

import org.jspecify.annotations.Nullable;
import sprouts.Association;
import sprouts.Pair;
import sprouts.Tuple;
import sprouts.ValueSet;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.StreamSupport;

final class LinkedAssociation&lt;K,V&gt; implements Association&lt;K, V&gt;
{
    private static final class LinkedEntry&lt;K, V&gt; {
        private final V value;
        private final @Nullable K previousKey;
        private final @Nullable K nextKey;

<span class="fc" id="L20">        LinkedEntry(V value, @Nullable K previousKey, @Nullable K nextKey) {</span>
<span class="fc" id="L21">            this.value = value;</span>
<span class="fc" id="L22">            this.previousKey = previousKey;</span>
<span class="fc" id="L23">            this.nextKey = nextKey;</span>
<span class="fc" id="L24">        }</span>
        V value() {
<span class="fc" id="L26">            return this.value;</span>
        }
        @Nullable
        K previousKey() {
<span class="fc" id="L30">            return this.previousKey;</span>
        }
        @Nullable
        K nextKey() {
<span class="fc" id="L34">            return this.nextKey;</span>
        }
        LinkedEntry&lt;K,V&gt; withValue(V value) {
<span class="fc" id="L37">            return new LinkedEntry&lt;&gt;(value, this.previousKey, this.nextKey);</span>
        }
        LinkedEntry&lt;K,V&gt; withPreviousKey(@Nullable K previousKey) {
<span class="fc" id="L40">            return new LinkedEntry&lt;&gt;(this.value, previousKey, this.nextKey);</span>
        }
        LinkedEntry&lt;K,V&gt; withNextKey(@Nullable K nextKey) {
<span class="fc" id="L43">            return new LinkedEntry&lt;&gt;(this.value, this.previousKey, nextKey);</span>
        }

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">            if (this == obj) return true;</span>
<span class="pc bpc" id="L49" title="1 of 2 branches missed.">            if (!(obj instanceof LinkedEntry)) return false;</span>
<span class="fc" id="L50">            LinkedEntry&lt;?, ?&gt; entry = (LinkedEntry&lt;?, ?&gt;) obj;</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">            return Objects.equals(value, entry.value) &amp;&amp;</span>
<span class="fc bfc" id="L52" title="All 2 branches covered.">                   Objects.equals(previousKey, entry.previousKey) &amp;&amp;</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">                   Objects.equals(nextKey, entry.nextKey);</span>
        }
        @Override
        public int hashCode() {
<span class="nc" id="L57">            return Objects.hash(value, previousKey, nextKey);</span>
        }
        @Override
        public String toString() {
<span class="nc" id="L61">            return &quot;LinkedEntry[value=&quot; + value +</span>
                   &quot;, previousKey=&quot; + previousKey +
                   &quot;, nextKey=&quot; + nextKey + &quot;]&quot;;
        }
    }

    private final Class&lt;V&gt; _valueType;
    private final AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; _entries;
    private final @Nullable K _firstInsertedKey;
    private final @Nullable K _lastInsertedKey;
<span class="fc" id="L71">    private final AtomicReference&lt;@Nullable Integer&gt; _cachedHashCode = new AtomicReference&lt;&gt;(null);</span>

    LinkedAssociation(
        final Class&lt;K&gt; keyType,
        final Class&lt;V&gt; valueType
    ) {
<span class="fc" id="L77">        this(valueType, new AssociationImpl(keyType, LinkedEntry.class), null, null);</span>
<span class="fc" id="L78">    }</span>

    private LinkedAssociation(
            final Class&lt;V&gt; valueType,
            final AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; entries,
            final @Nullable K firstInsertedKey,
            final @Nullable K lastInsertedKey
<span class="fc" id="L85">    ) {</span>
<span class="fc" id="L86">        _valueType = valueType;</span>
<span class="fc" id="L87">        _entries = entries;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        _firstInsertedKey = firstInsertedKey != null ? firstInsertedKey : lastInsertedKey;</span>
<span class="fc" id="L89">        _lastInsertedKey = lastInsertedKey;</span>
<span class="fc" id="L90">    }</span>



    @Override
    public int size() {
<span class="fc" id="L96">        return _entries.size();</span>
    }

    @Override
    public boolean isLinked() {
<span class="fc" id="L101">        return true;</span>
    }

    @Override
    public boolean isSorted() {
<span class="fc" id="L106">        return false;</span>
    }

    @Override
    public Class&lt;K&gt; keyType() {
<span class="fc" id="L111">        return _entries.keyType();</span>
    }

    @Override
    public Class&lt;V&gt; valueType() {
<span class="fc" id="L116">        return _valueType;</span>
    }

    @Override
    public ValueSet&lt;K&gt; keySet() {
<span class="fc" id="L121">        return StreamSupport.stream(spliterator(), false)</span>
<span class="fc" id="L122">                .reduce(</span>
<span class="fc" id="L123">                        new LinkedValueSet&lt;&gt;(keyType()),</span>
<span class="fc" id="L124">                        (set, pair) -&gt; (LinkedValueSet&lt;K&gt;) set.add(pair.first()),</span>
<span class="nc" id="L125">                        (a, b) -&gt; a</span>
                );
    }

    @Override
    public Tuple&lt;V&gt; values() {
<span class="fc" id="L131">        return StreamSupport.stream(spliterator(), false)</span>
<span class="fc" id="L132">                .map(Pair::second)</span>
<span class="fc" id="L133">                .collect(Tuple.collectorOf(valueType()));</span>
    }

    @Override
    public boolean containsKey(K key) {
<span class="fc" id="L138">        return _entries.containsKey(key);</span>
    }

    @Override
    public Optional&lt;V&gt; get(K key) {
<span class="fc" id="L143">        return _entries.get(key).map(LinkedEntry::value);</span>
    }

    @Override
    public Association&lt;K, V&gt; put(K key, V value) {
<span class="fc bfc" id="L148" title="All 4 branches covered.">        if (key == null || value == null) {</span>
<span class="fc" id="L149">            throw new NullPointerException(&quot;Key and value must not be null&quot;);</span>
        }
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if ( !_entries.keyType().isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L152">            throw new IllegalArgumentException(</span>
<span class="fc" id="L153">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
<span class="fc" id="L154">                            &quot;instead of the expected type '&quot; + _entries.keyType() + &quot;'.&quot;</span>
            );
        }
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if ( !_valueType.isAssignableFrom(value.getClass()) ) {</span>
<span class="fc" id="L158">            throw new IllegalArgumentException(</span>
<span class="fc" id="L159">                    &quot;The given value '&quot; + value + &quot;' is of type '&quot; + value.getClass().getSimpleName() + &quot;', &quot; +</span>
                            &quot;instead of the expected type '&quot; + _valueType + &quot;'.&quot;
            );
        }
<span class="fc" id="L163">        Optional&lt;LinkedEntry&lt;K, V&gt;&gt; entry = _entries.get(key);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (entry.isPresent()) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (entry.get().value().equals(value)) {</span>
                // If the value is the same, we do not need to change anything
<span class="fc" id="L167">                return this;</span>
            }
<span class="fc" id="L169">            LinkedEntry&lt;K, V&gt; existingEntry = entry.get();</span>
<span class="fc" id="L170">            AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; newEntries = (AssociationImpl)_entries.put(</span>
                    key,
<span class="fc" id="L172">                    existingEntry.withValue(value)</span>
            );
<span class="fc" id="L174">            return new LinkedAssociation&lt;&gt;(valueType(), newEntries, _firstInsertedKey, _lastInsertedKey);</span>
        } else {
            // If the key does not exist, we create a new entry
<span class="fc" id="L177">            LinkedEntry&lt;K, V&gt; newEntry = new LinkedEntry&lt;&gt;(value, _lastInsertedKey, null);</span>
<span class="fc" id="L178">            AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; newEntries = (AssociationImpl)_entries.put(</span>
                    key,
                    newEntry
            );
<span class="fc bfc" id="L182" title="All 2 branches covered.">            if (_lastInsertedKey != null) {</span>
                // Update the previous entry's nextKey to point to the new key
<span class="fc" id="L184">                Optional&lt;LinkedEntry&lt;K, V&gt;&gt; lastEntry = _entries.get(_lastInsertedKey);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                if (lastEntry.isPresent()) {</span>
<span class="fc" id="L186">                    LinkedEntry&lt;K, V&gt; updatedLastEntry = lastEntry.get().withNextKey(key);</span>
<span class="fc" id="L187">                    newEntries = (AssociationImpl)newEntries.put(</span>
                            _lastInsertedKey,
                            updatedLastEntry
                    );
                }
            }
<span class="fc" id="L193">            return new LinkedAssociation&lt;&gt;(valueType(), newEntries, _firstInsertedKey, key);</span>
        }
    }

    @Override
    public Association&lt;K, V&gt; putIfAbsent(K key, V value) {
<span class="fc bfc" id="L199" title="All 4 branches covered.">        if (key == null || value == null) {</span>
<span class="fc" id="L200">            throw new NullPointerException(&quot;Key and value must not be null&quot;);</span>
        }
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if ( !_entries.keyType().isAssignableFrom(key.getClass()) ) {</span>
<span class="fc" id="L203">            throw new IllegalArgumentException(</span>
<span class="fc" id="L204">                    &quot;The given key '&quot; + key + &quot;' is of type '&quot; + key.getClass().getSimpleName() + &quot;', &quot; +</span>
<span class="fc" id="L205">                    &quot;instead of the expected type '&quot; + _entries.keyType() + &quot;'.&quot;</span>
                );
        }
<span class="fc bfc" id="L208" title="All 2 branches covered.">        if ( !_valueType.isAssignableFrom(value.getClass()) ) {</span>
<span class="fc" id="L209">            throw new IllegalArgumentException(</span>
<span class="fc" id="L210">                    &quot;The given value '&quot; + value + &quot;' is of type '&quot; + value.getClass().getSimpleName() + &quot;', &quot; +</span>
                    &quot;instead of the expected type '&quot; + _valueType + &quot;'.&quot;
                );
        }
<span class="fc" id="L214">        Optional&lt;LinkedEntry&lt;K, V&gt;&gt; entry = _entries.get(key);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (entry.isPresent()) {</span>
            // If the key already exists, we do nothing
<span class="fc" id="L217">            return this;</span>
        } else {
            // If the key does not exist, we create a new entry
<span class="fc" id="L220">            LinkedEntry&lt;K, V&gt; newEntry = new LinkedEntry&lt;&gt;(value, _lastInsertedKey, null);</span>
<span class="fc" id="L221">            AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; newEntries = (AssociationImpl)_entries.put(</span>
                    key,
                    newEntry
            );
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (_lastInsertedKey != null) {</span>
                // Update the previous entry's nextKey to point to the new key
<span class="fc" id="L227">                Optional&lt;LinkedEntry&lt;K, V&gt;&gt; lastEntry = _entries.get(_lastInsertedKey);</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                if (lastEntry.isPresent()) {</span>
<span class="fc" id="L229">                    LinkedEntry&lt;K, V&gt; updatedLastEntry = lastEntry.get().withNextKey(key);</span>
<span class="fc" id="L230">                    newEntries = (AssociationImpl)newEntries.put(</span>
                            _lastInsertedKey,
                            updatedLastEntry
                    );
                }
            }
<span class="fc" id="L236">            return new LinkedAssociation&lt;&gt;(valueType(), newEntries, _firstInsertedKey, key);</span>
        }
    }

    @Override
    public Association&lt;K, V&gt; remove(K key) {
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (Util.refEquals(key, null)) {</span>
<span class="fc" id="L243">            throw new NullPointerException(&quot;Key must not be null&quot;);</span>
        }
<span class="fc" id="L245">        Optional&lt;LinkedEntry&lt;K, V&gt;&gt; entry = _entries.get(key);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (entry.isPresent()) {</span>
<span class="fc" id="L247">            K firstInsertedKey = _firstInsertedKey;</span>
<span class="fc" id="L248">            K lastInsertedKey = _lastInsertedKey;</span>
<span class="pc bpc" id="L249" title="1 of 4 branches missed.">            if (firstInsertedKey != null &amp;&amp; firstInsertedKey.equals(key)) {</span>
                // If we are removing the first inserted key, we need to update it
<span class="fc" id="L251">                firstInsertedKey = entry.get().nextKey();</span>
            }
<span class="pc bpc" id="L253" title="1 of 4 branches missed.">            if (lastInsertedKey != null &amp;&amp; lastInsertedKey.equals(key)) {</span>
                // If we are removing the last inserted key, we need to update it
<span class="fc" id="L255">                lastInsertedKey = entry.get().previousKey();</span>
            }
<span class="fc" id="L257">            LinkedEntry&lt;K, V&gt; existingEntry = entry.get();</span>
<span class="fc" id="L258">            AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; newEntries = (AssociationImpl)_entries.remove(key);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">            if (existingEntry.previousKey() != null) {</span>
                // Update the previous entry's nextKey to point to the next key
<span class="fc" id="L261">                Optional&lt;LinkedEntry&lt;K, V&gt;&gt; previousEntry = _entries.get(existingEntry.previousKey());</span>
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">                if (previousEntry.isPresent()) {</span>
<span class="fc" id="L263">                    LinkedEntry&lt;K, V&gt; updatedPreviousEntry = previousEntry.get().withNextKey(existingEntry.nextKey());</span>
<span class="fc" id="L264">                    newEntries = (AssociationImpl)newEntries.put(</span>
<span class="fc" id="L265">                            existingEntry.previousKey(),</span>
                            updatedPreviousEntry
                    );
                }
            }
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (existingEntry.nextKey() != null) {</span>
                // Update the next entry's previousKey to point to the previous key
<span class="fc" id="L272">                Optional&lt;LinkedEntry&lt;K, V&gt;&gt; nextEntry = _entries.get(existingEntry.nextKey());</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">                if (nextEntry.isPresent()) {</span>
<span class="fc" id="L274">                    LinkedEntry&lt;K, V&gt; updatedNextEntry = nextEntry.get().withPreviousKey(existingEntry.previousKey());</span>
<span class="fc" id="L275">                    newEntries = (AssociationImpl)newEntries.put(</span>
<span class="fc" id="L276">                            existingEntry.nextKey(),</span>
                            updatedNextEntry
                    );
                }
            }
<span class="fc" id="L281">            return new LinkedAssociation&lt;&gt;(valueType(), newEntries, firstInsertedKey, lastInsertedKey);</span>
        }
<span class="fc" id="L283">        return this; // If the key does not exist, we do nothing</span>
    }

    @Override
    public Association&lt;K, V&gt; clear() {
<span class="fc" id="L288">        AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt; clearedEntries = (AssociationImpl&lt;K, LinkedEntry&lt;K, V&gt;&gt;) _entries.clear();</span>
<span class="fc" id="L289">        return new LinkedAssociation&lt;&gt;(valueType(), clearedEntries, null, null);</span>
    }

    @Override
    public Spliterator&lt;Pair&lt;K,V&gt;&gt; spliterator() {
<span class="fc" id="L294">        return Spliterators.spliterator(iterator(), _entries.size(),</span>
                        Spliterator.ORDERED |
                        Spliterator.DISTINCT |
                        Spliterator.SIZED |
                        Spliterator.SUBSIZED |
                        Spliterator.NONNULL |
                        Spliterator.IMMUTABLE
                    );
    }

    @Override
    public Iterator&lt;Pair&lt;K, V&gt;&gt; iterator() {
<span class="fc" id="L306">        return new Iterator&lt;Pair&lt;K, V&gt;&gt;() {</span>
<span class="fc" id="L307">            private @Nullable K currentKey = null;</span>
<span class="fc" id="L308">            private @Nullable K nextKey = _firstInsertedKey;</span>

            @Override
            public boolean hasNext() {
<span class="fc bfc" id="L312" title="All 2 branches covered.">                return nextKey != null;</span>
            }

            @Override
            public Pair&lt;K, V&gt; next() {
<span class="pc bpc" id="L317" title="2 of 4 branches missed.">                if (!hasNext() || nextKey == null) {</span>
<span class="nc" id="L318">                    throw new NoSuchElementException();</span>
                }
<span class="fc" id="L320">                currentKey = nextKey;</span>
<span class="fc" id="L321">                LinkedEntry&lt;K, V&gt; entry = _entries.get(currentKey).orElseThrow(NoSuchElementException::new);</span>
<span class="fc" id="L322">                nextKey = entry.nextKey();</span>
<span class="fc" id="L323">                return Pair.of(currentKey, entry.value());</span>
            }
        };
    }


    @Override
    public String toString() {
<span class="fc" id="L331">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L332">        sb.append(&quot;LinkedAssociation&lt;&quot;);</span>
<span class="fc" id="L333">        sb.append(keyType().getSimpleName()).append(&quot;,&quot;);</span>
<span class="fc" id="L334">        sb.append(_valueType.getSimpleName()).append(&quot;&gt;[&quot;);</span>
<span class="fc" id="L335">        final int howMany = 8;</span>
<span class="fc" id="L336">        sb = _appendRecursivelyUpTo(sb, howMany);</span>
<span class="fc" id="L337">        int numberOfEntriesLeft = size() - howMany;</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if ( numberOfEntriesLeft &gt; 0 ) {</span>
<span class="fc" id="L339">            sb.append(&quot;, ...&quot;).append(numberOfEntriesLeft).append(&quot; more entries&quot;);</span>
        }
<span class="fc" id="L341">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L342">        return sb.toString();</span>
    }

    private StringBuilder _appendRecursivelyUpTo(StringBuilder sb, int howMany) {
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (howMany &lt;= 0) {</span>
<span class="nc" id="L347">            return sb;</span>
        }
<span class="fc" id="L349">        Iterator&lt;Pair&lt;K, V&gt;&gt; it = iterator();</span>
<span class="fc" id="L350">        int count = 0;</span>
<span class="fc bfc" id="L351" title="All 4 branches covered.">        while (it.hasNext() &amp;&amp; count &lt; howMany) {</span>
<span class="fc" id="L352">            Pair&lt;K, V&gt; pair = it.next();</span>
<span class="fc" id="L353">            String keyString = Util._toString(pair.first(), keyType());</span>
<span class="fc" id="L354">            String valueString = Util._toString(pair.second(), valueType());</span>
<span class="fc" id="L355">            sb.append(keyString).append(&quot; â†¦ &quot;).append(valueString);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (it.hasNext()) {</span>
<span class="fc" id="L357">                sb.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L359">            count++;</span>
<span class="fc" id="L360">        }</span>
<span class="fc" id="L361">        return sb;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (this == o) return true;</span>
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (!(o instanceof LinkedAssociation))</span>
<span class="nc" id="L368">            return false;</span>
<span class="fc" id="L369">        LinkedAssociation&lt;K,V&gt; other = (LinkedAssociation) o;</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">        if ( !_valueType.equals(other._valueType) )</span>
<span class="nc" id="L371">            return false;</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">        if ( !_entries.keyType().equals(other._entries.keyType()) )</span>
<span class="nc" id="L373">            return false;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if ( _entries.size() != other._entries.size() )</span>
<span class="fc" id="L375">            return false;</span>

<span class="fc" id="L377">        return _recursiveEquals(this._entries._root, other._entries._root, this.keyType());</span>
    }

    private static &lt;K,V&gt; boolean _exhaustiveEquals(
            AssociationImpl&lt;K,LinkedEntry&lt;K,V&gt;&gt; assoc1, AssociationImpl&lt;K,LinkedEntry&lt;K,V&gt;&gt; assoc2
    ) {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if ( assoc2.size() != assoc1.size() ) {</span>
<span class="fc" id="L384">            return false;</span>
        }
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for ( K key : assoc1.keySet() ) {</span>
<span class="fc" id="L387">            int keyHash = key.hashCode();</span>
<span class="fc" id="L388">            LinkedEntry&lt;K,V&gt; firstEntry = AssociationImpl._get(assoc1._root, assoc1._keyGetter, assoc1._valueGetter, key, keyHash);</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">            if ( firstEntry == null ) {</span>
<span class="nc" id="L390">                return false;</span>
            }
<span class="fc" id="L392">            LinkedEntry&lt;K,V&gt; otherEntry = AssociationImpl._get(assoc2._root, assoc2._keyGetter, assoc2._valueGetter, key, keyHash);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            if ( otherEntry == null ) {</span>
<span class="fc" id="L394">                return false;</span>
            }
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (!Objects.equals(firstEntry.value, otherEntry.value) ) {</span>
<span class="fc" id="L397">                return false;</span>
            }
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">        return true;</span>
    }

    private static &lt;K,V&gt; boolean _recursiveEquals(
            AssociationImpl.@Nullable Node&lt;K,LinkedEntry&lt;K,V&gt;&gt; node1,
            AssociationImpl.@Nullable Node&lt;K,LinkedEntry&lt;K,V&gt;&gt; node2,
            Class&lt;K&gt; keyType
    ) {
<span class="fc bfc" id="L408" title="All 2 branches covered.">        if ( node1 == node2 ) {</span>
<span class="fc" id="L409">            return true;</span>
        } else {
<span class="fc bfc" id="L411" title="All 4 branches covered.">            if ( node1 == null || node2 == null ) {</span>
<span class="fc" id="L412">                return false;</span>
            }
<span class="pc bpc" id="L414" title="2 of 12 branches missed.">            if (</span>
                node1._size == node2._size &amp;&amp;
                node1._keysArray == node2._keysArray &amp;&amp;
                node1._valuesArray == node2._valuesArray &amp;&amp;
                node1._keyHashes == node2._keyHashes &amp;&amp;
                node1._branches.length == node2._branches.length &amp;&amp;
                node1._branches != node2._branches // The only difference is somewhere deep down!
            ) {
<span class="fc bfc" id="L422" title="All 2 branches covered.">                for ( int i = 0; i &lt; node1._branches.length; i++ ) {</span>
<span class="fc bfc" id="L423" title="All 2 branches covered.">                    if ( !_recursiveEquals(node1._branches[i], node2._branches[i], keyType) ) {</span>
<span class="fc" id="L424">                        return false;</span>
                    }
                }
<span class="fc" id="L427">                return true;</span>
            } else {
<span class="fc" id="L429">                return _exhaustiveEquals(</span>
                        new AssociationImpl(keyType, LinkedEntry.class, node1),
                        new AssociationImpl(keyType, LinkedEntry.class, node2)
                );
            }
        }
    }

    @Override
    public int hashCode() {
<span class="fc" id="L439">        Integer cached = _cachedHashCode.get();</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if ( cached != null ) {</span>
<span class="fc" id="L441">            return cached;</span>
        }
<span class="fc" id="L443">        int result = _valueType.hashCode();</span>
<span class="fc" id="L444">        result = 31 * result + _entries.keyType().hashCode();</span>
<span class="fc" id="L445">        result = 31 * result + _entries.size();</span>
<span class="fc" id="L446">        int pairsHash = 0;</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (Pair&lt;K, V&gt; kvPair : this)</span>
<span class="fc" id="L448">            pairsHash += kvPair.hashCode();</span>
<span class="fc" id="L449">        result = 31 * result + pairsHash;</span>
<span class="fc" id="L450">        _cachedHashCode.set(result);</span>
<span class="fc" id="L451">        return result;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>